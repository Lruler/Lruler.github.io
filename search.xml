<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cookie/Session/Token/localStorage</title>
    <url>/2021/09/24/Cookie-Session-Token-localStorage/</url>
    <content><![CDATA[<p>目前对于和http相关的东西了解不算多，认知还比较浅，就来写一篇博客对cookie这些东西简单的了解一下</p>
<span id="more"></span>

<h1 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="什么是Cookie"></a>什么是Cookie</h1><p>什么是cookie？</p>
<ol>
<li>Cookie是浏览器访问服务器后，服务器传给浏览器的数据</li>
<li>浏览器需要保存这段数据，不能轻易删除</li>
<li>以后每次浏览器都要访问该服务器，都需要带上刚数据</li>
</ol>
<h2 id="如何使用Cookie"><a href="#如何使用Cookie" class="headerlink" title="如何使用Cookie"></a>如何使用Cookie</h2><p>cookie一般有两个作用</p>
<ol>
<li>识别用户身份<br>如果用户A用浏览器访问了服务器a.com,a.com的服务器就会立刻给A返回一段数据“uid = 1”(可以理解为这就是cookie)。当A再次访问a.com的其他页面时，就会附带上”uid = 1”的数据。<br>同理，用户B再次访问服务器a.com,然后a.com发现用户B没有附带uid数据，就给B分配了一个新的uid,为2，然后给B返回一段数据”uid = 2”,B之后再次访问a.com的时候就会一直带上“uid = 2”这段数据，借此a.com就能就能区分A和B两个用户了。</li>
<li>记录历史<br>假设 <a href="http://a.com/">http://a.com</a> 是一个购物网站，当 A 在上面将商品 A1 、A2 加入购物车时，JS 可以改写 Cookie，改为「uid=1; cart=A1,A2」，表示购物车里有 A1 和 A2 两样商品了。<br>这样一来，当用户关闭网页，过三天再打开网页的时候，依然可以看到 A1、A2 躺在购物车里，因为浏览器并不会无缘无故地删除这个 Cookie。<br>借此，就达到里记录用户操作历史的目的了。<br>（上面的例子只是为了让大家了解 Cookie 的作用而构想出来的，实际的网站使用 Cookie 时会更谨慎一些。）</li>
</ol>
<h2 id="cookie和localstorage-sessionStorge"><a href="#cookie和localstorage-sessionStorge" class="headerlink" title="cookie和localstorage,sessionStorge"></a>cookie和localstorage,sessionStorge</h2><p><img src="/2021/09/24/Cookie-Session-Token-localStorage/cookie.png" alt="cookie"></p>
<h3 id="场景考虑"><a href="#场景考虑" class="headerlink" title="场景考虑"></a>场景考虑</h3><p>因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 当然是能精简就精简啦，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假了~</p>
<p>而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。</p>
<p>需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。</p>
<h2 id="cookie和session，token"><a href="#cookie和session，token" class="headerlink" title="cookie和session，token"></a>cookie和session，token</h2><p><img src="/2021/09/24/Cookie-Session-Token-localStorage/1515111-20200405090920745-1422513552.png" alt="1"></p>
<h3 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie/session"></a>cookie/session</h3><p>HTTP 协议是一种无状态协议，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。</p>
<p>Session 是什么<br>客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个对象便是 Session 对象，存储结构为 ConcurrentHashMap。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。</p>
<p>Session 如何判断是否是同一会话<br>服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 **Set-Cookie：JSESSIONID=XXXXXXX **命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 **JSESSIONID=XXXXXXX **的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束<br><img src="/2021/09/24/Cookie-Session-Token-localStorage/2.png" alt="2"><br>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。</p>
<p>Session 的缺点<br>Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p>
<p>而HTTP 协议中的 Cookie 包括 Web Cookie 和浏览器 Cookie，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。</p>
<p>也就是说<br>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下</p>
<ol>
<li>首先，客户端会发送一个http请求到服务器端。</li>
<li>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看Cookie详解 Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</li>
<li>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</li>
<li>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端<br><img src="/2021/09/24/Cookie-Session-Token-localStorage/3.png" alt="3"></li>
</ol>
<p><strong>注意</strong><br>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中<br>现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用<br>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。<br>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大<br>简而言之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证</p>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。<br>组成</p>
<ul>
<li>uid: 用户唯一身份标识</li>
<li>time: 当前时间的时间戳</li>
<li>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li>
<li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li>
</ul>
<p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p>
<p>token 的认证流程与cookie很相似</p>
<ul>
<li>用户登录，成功后服务器返回Token给客户端。</li>
<li>客户端收到数据后保存在客户端</li>
<li>客户端再次访问服务器，将token放入headers中</li>
<li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li>
</ul>
<p><strong>token可以抵抗csrf，cookie+session不行</strong><br>假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为<a href="http://www.bank.com/api/transfer%EF%BC%8Cbody%E4%B8%BAcount=1000&amp;to=Tom%E3%80%82%E5%80%98%E8%8B%A5%E6%98%AFsession+cookie%EF%BC%8C%E7%94%A8%E6%88%B7%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E5%B7%B2%E7%BB%8F%E8%BD%AC%E7%BB%99Tom1000%E5%85%83%E4%BA%86.%E5%9B%A0%E4%B8%BAform">http://www.bank.com/api/transfer，body为count=1000&amp;to=Tom。倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了.因为form</a> 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p>
<p>分布式情况下的session和token<br>我们已经知道session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。</p>
<ul>
<li>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。当今的几种解决session负载均衡的方法。</li>
</ul>
<p>而token是无状态的，token字符串里就保存了所有的用户信息</p>
<ul>
<li>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token)<br>关于JWT可以看 （<a href="https://www.cnblogs.com/cxuanBlog/p/12635842.html%EF%BC%89">https://www.cnblogs.com/cxuanBlog/p/12635842.html）</a></li>
</ul>
<p>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie<br>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。<br>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。<br>jwt只是一个跨域认证的方案</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit11-背景、阴影、和混合模式</title>
    <url>/2021/06/12/CssU11/</url>
    <content><![CDATA[<p>Css in depth 第四部分高级话题 第十一章笔记</p>
<span id="more"></span>

<h1 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h1><p>首先对background 这个属性有了解</p>
<pre><code>    background-image  //指定一个文件或者生成颜色渐变作为背景图片
    background-position  //设置背景图片的初始位置
    background-size  //指定背景图片的渲染尺寸
    background-repeat  //决定在需要填充整个元素的时候是否平铺图片
    background-origin  //决定背景图片的相对区域(content-box，border-box，默认是padding-box)
    background-clip  //决定背景图片的绘制区域，值和上述一样
    background-attachment  //决定背景图片是否随着页面其余部分的滚动而滚动
    background-color  //指定背景颜色(渲染到背景图片下方)
</code></pre>
<h2 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h2><p>然后我们就知道了渐变其实就是一种背景图片，用background-image 来定义，那如何定义一个渐变？ 这里就要引入 liner-gradient()这个函数了，</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fade</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: liner-gradient (to right,white,blue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下<br><img src="/2021/06/12/CssU11/1.png" alt="01"></p>
<p>该函数有三个参数，第一个是角度，后面两个是起始颜色和终止颜色。<br>对于角度的设置可以为xdeg,比如0deg表示向上渐变，90deg表示向右渐变(顺时针旋转)，还有rad,turn,grad等单位，这里就不详细说了。<br>如果我们采用<br><code>background-image: liner-gradient (to right,red 0%,white 50%,blue 100%);</code><br>就可以实现多颜色渐变并确定它们渐变完成的位置。</p>
<p>如果在同一位置放多种颜色的话 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fade</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>,</span><br><span class="line"> red <span class="number">40%</span>, white <span class="number">40%</span>,</span><br><span class="line"> white <span class="number">60%</span>, blue <span class="number">60%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会出现下图的条纹效果<br><img src="/2021/06/12/CssU11/2.png"></p>
<p>线性渐变还有一种效果就是重复渐变，除了使用的函数repeating-linear-gradient()与线性渐变不同外，其接受参数参数和重复部分的效果都和线性渐变相同</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fade</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">repeating-linear-gradient</span>(-<span class="number">45deg</span>,</span><br><span class="line"> <span class="number">#57b</span>, <span class="number">#57b</span> <span class="number">10px</span>, <span class="number">#148</span> <span class="number">10px</span>, <span class="number">#148</span> <span class="number">20px</span>);</span><br><span class="line"> <span class="attribute">border-radius</span>: <span class="number">0.3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/12/CssU11/Snipaste_2021-06-03_18-49-51.png"></p>
<h2 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h2><p>和线性渐变的从一端沿直线到另一端不同，径向渐变是从一个点开始全方位向外扩展，如图<br><img src="/2021/06/12/CssU11/Snipaste_2021-06-03_18-56-45.png"></p>
<p>该渐变的函数是radial-gradient() ,通过类似于线性渐变函数的参数改变可以产生多种渐变效果，这里因为用的不多就不多说了。</p>
<h1 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h1><p>分为两种，box-shadow / text-shadow。<br>box-shadow的属性值为<br><code>box-shadow: 1em(水平位移) 1em(垂直位移) 2px(模糊半径) 1px(扩展半径) black</code><br>其中模糊半径设置阴影边缘模糊区域(更柔和)，扩展半径使阴影变大或变小</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line"> <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">0.8rem</span>;</span><br><span class="line"> <span class="attribute">color</span>: white;</span><br><span class="line"> <span class="attribute">border-radius</span>: <span class="number">0.5em</span>;</span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to bottom, <span class="number">#57b</span>, <span class="number">#148</span>);</span><br><span class="line"> <span class="attribute">box-shadow</span>: <span class="number">0.1em</span> <span class="number">0.1em</span> <span class="number">0.5em</span> <span class="number">#124</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line"> <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">0</span> <span class="number">0.5em</span> <span class="number">#124</span>,</span><br><span class="line"> inset <span class="number">0</span> <span class="number">0.5em</span> <span class="number">1em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码实现了如图效果<img src="/2021/06/12/CssU11/Snipaste_2021-06-03_19-09-31.png"><br>渐变阴影让元素更立体以及inset 让阴影在内部实现</p>
<h1 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h1><p><em><strong>background-blend-mode</strong></em> 具体不介绍，知道有这么个东西就行，要用到就现查现用</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit1-层叠，优先级，继承</title>
    <url>/2021/06/12/CssU1/</url>
    <content><![CDATA[<p>从现在开始系统学习Css啦，也就是把css in depth 好好看一遍，这是第一单元的笔记</p>
<span id="more"></span>

<h1 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>先理解CSS中的C(Cascading)，层叠:<br>CSS样式在针对同一元素配置同一属性时，依据层叠规则（权重）来处理冲突，选择应用权重高的CSS选择器所指定的属性，一般也被描述为权重高的覆盖权重低的，因此也称作层叠。</p>
<p>而CSS的本质就是声明规则，即在各种条件下产生我们所希望的特定效果。在一份庞大的工作项目中,CSS代码就会变得很复杂，因为在CSS里实现同一种效果会有好几种不同的方式，而当HTML的结构发生改变后，这些不同的CSS实现方式又会产生不同的结果，浏览器在解释这部分样式规则的时候，可能会出现一个元素应用多个规则，这时就会产生<strong>冲突</strong>。</p>
<p>所以层叠大体上就上应对这种冲突情况产生的一种解决规则，层叠有三个条件:</p>
<pre><code>    1.样式表的来源：样式来源，包括自己的CSS文件和浏览器默认(用户代理)样式
    2.选择器优先级：哪些选择器的权重
    3.源码顺序：CSS代码块里面的声明顺序 
    // !important声明权重最高，内联style样式其次
</code></pre>
<p>浏览器就会根据以上三条规则按顺序解析CSS从而解决冲突问题。</p>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><h2 id="选择器的权重"><a href="#选择器的权重" class="headerlink" title="选择器的权重"></a>选择器的权重</h2><pre><code>    #id -- 100
    .class -- 10
    tag -- 1
    // 伪类选择器和属性选择器的权重和类选择器一致，通配符*和组合器(&gt;/+/~)对优先级权重没有影响
</code></pre>
<h2 id="关于解决冲突的一些方法"><a href="#关于解决冲突的一些方法" class="headerlink" title="关于解决冲突的一些方法"></a>关于解决冲突的一些方法</h2><p>有以下代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#main</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;featured&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>想要让最后一个li变成蓝色，有几种方法可以实现呢？</p>
<p>最简单的当然就是用!important 或者 内联的style样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#main</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.featured</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: blue <span class="meta">!important</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;featured&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;background-color: blue&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但最简单同样也是最不推荐的，应为这样写的话在一些需求大量的CSS中可能会引起很多未知的Bug(比如太多的important让一切冲突回到原点)</p>
<p>所以我们选择提升最后一个li选择器的优先级。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#main</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span></span><br><span class="line"><span class="css">    <span class="selector-id">#main</span> <span class="selector-class">.featured</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>到这一步了，我们来个逆向思维，降低其他li的选择器优先级也是一个方法,我们给ul添加一个class，用class选择器代替id选择器<br><strong>这第三种方法也是 Css in depth 最推荐的一种方法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.class</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.class</span> <span class="selector-class">.featured</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;featured&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后一个方法就是按照层叠条件的第三点来了，也就是源码顺序，把两个声明的优先级放到一致，后声明的样式会覆盖前面的样式，这里也不太推荐使用，因为只会覆盖同名的属性，也会造成很多不一致的样式Bug，就不放代码细述了。</p>
<h2 id="a的伪类选择器"><a href="#a的伪类选择器" class="headerlink" title="a的伪类选择器"></a>a的伪类选择器</h2><p>除开几种基础选择器外，还有一些复合选择器，像什么后代选择啊，子选择，并集选择，伪类选择。这里我们就说一下关于a标签伪类选择器的优先级问题。<br>a标签的伪类选择有四种</p>
<pre><code>    a:link   选择未被访问的
    a:visited 选择已被访问的
    a:hover 选择鼠标悬停的
    a:active 选择鼠标按下未弹起的
</code></pre>
<p>关于这四种伪类选择器的优先级，记住 LVHA的顺序 (LV包Hao)即可</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这里先明白一个概念，层叠值:<br><strong>层叠值就是作为层叠结果，应用到一个元素上的特定属性的值</strong><br>大白话说就是几个规则都被用于渲染一个元素啊，比武招亲，这叫冲突，然后打架嘛，最后只有一个人获胜，也就是只有一条CSS声明的属性能赢，一夫一妻嘛，这个赢了的声明属性就叫层叠值。<br>还要注意不要过度的使用id选择器和!important规则。这点之前也提到过，因为这些权重很高，很难覆盖，除了可能会引起一些麻烦外，对于后续的修改优化工作也有很大的阻挠。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>除了内联，引入Css文件，用户代理等外，这里还有最后一种给HTML元素添加样式的方法，就是<strong>继承</strong>。<br>首先我们都知道，HTML就是个DOM树。<br>![01](./CssU1/1 .png)<br>当我们给body元素添加font-family时，body以下所有的子节点都会继承这个字体，但不是所有属性都能被继承，一般情况下，能被继承的属性有: 文本相关:<strong>color, font, font-family, font-size, font-weight, font-variant,font-style, line-height, letter-spacing, text-align, text-indent, text-transform,white-space, and word-spacing.</strong>  再比如列表属性:<strong>list-style, list-style-type, list-style-position, and list-style-image.</strong> 以及表格的边框属性:<strong>border-collapse and border-spacing,</strong> (这是控制的边框行为)。</p>
<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><p>有inherit(继承)和initial(初始)两个特殊值可以赋给任意属性，比如一般情况下我们会给一个网页里面所有的a添加一个字体颜色，但放在页脚的颜色却不能那么显眼，我们就可以</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哎，这里就会问，为什么不直接把页脚的a设置成灰色呢，嗯我也在想，书上说这样继承的话可以直接通过修改.footer里面的值来改变页脚链接的文本颜色，唉可能是我还没有接触到太复杂的页面所以没啥感觉吧呜呜呜。但要注意，<strong>继承的优先级连标签选择器都比不上</strong><br>接下来就是initial，也很好理解，就是把属性的值设置为初始值，一般用于重置一个属性，但有以下几点需要注意以下:</p>
<ol>
<li>不要习惯用auto重置，有些属性的默认值是auto，比如width，但auto对很多属性来说是不合法对值，比如padding等、</li>
<li>display的初始值是inline，无论哪种元素的display初始值都是inline，所以小心对display用initial</li>
</ol>
<h2 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h2><p>这里提一下简写属性，就是把很多属性放到同一个属性名下，比如用font来写font-style,font-weight等<br><code>font: italic bold 18px/1.2 &quot;Helvetica&quot;, &quot;Arial&quot;, sans-serif;</code><br>但这种我不喜欢用，主要是记不住顺序，Emmmm，还是写的少了….估计写多点就能记得住了。(尽管它会包容你的顺序错误TnT)</p>
<p>唯一能记得住的简写方式就是一些表大小或位置的属性，比如border-width,这种后面可以跟四个值，分别代表上右下左(顺时针方向),三个值就是上 左右 下，两个就是上下 左右，一个则设置上下左右。</p>
<p>但要注意，有部分的属性后面的值和上右下左的方向刚好相反，比如background-position, box-shadow,和text-shadow，比如他们后面跟两个值的话，就是先指定左右，再指定上下。书上说相反的原因很简单，按照笛卡尔网格来，按照x,y测量啥的，我就理解为阴影嘛，就跟光影差不多，初中物理就知道呈的是倒立的虚像，所以就反着来呗.</p>
<p>至此第一章就结束来…写的还满多的….</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit3-盒模型</title>
    <url>/2021/06/12/CssU3/</url>
    <content><![CDATA[<p>Css in depth 第三章学习笔记</p>
<span id="more"></span>

<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>先了解一下什么是盒模型:<br>就我目前所学的，所谓盒子就是一个一个小区域，用来装内容的，所有可视内容都要放在盒子里，无论是行内，块级还是行内块元素，都可以是盒子模型。<br><img src="/2021/06/12/CssU3/1.png" alt="1"></p>
<p>这是默认的盒子模型，其中盒子的宽高并不影响padding等值，就是可以填充内容区域的高度。<br>而在我们给元素设置为box-sizing: border-box后会改变盒模型<br><img src="/2021/06/12/CssU3/2.png" alt="2"><br>这会让我们能更好的掌控盒模型，因为我们此时设置的宽高就是该盒子整体的宽高，包括padding和border等值。</p>
<p>所以在写CSS的时候还是选择border-box吧，省事嘛。<br>可以全局设置修改盒模型所以在写CSS的时候还是选择border-box吧，省事嘛。<br>可以全局设置修改盒模型</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"><span class="selector-pseudo">::before</span></span><br><span class="line"><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用盒子模型后，对于添加一丢丢内外边距的时候，我们可以不用这么写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    width: 29%;</span><br><span class="line">    magrin-left: 1%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别问，问就是拉，书上给出了一种极为高级的写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    width: calc(30% - 1.5em);</span><br><span class="line">    magrin-left: 1.5em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样不仅能使代码更简单易懂(第一种乍一看看到个29%会感觉莫名其妙)，还能实现不同单位的搭配，% + em ，这谁敢想！？ 总之就是好用就得了，好用且高级。</p>
<h1 id="元素高度问题"><a href="#元素高度问题" class="headerlink" title="元素高度问题"></a>元素高度问题</h1><p>在写项目的时候我们一般不会给盒子限定高度，因为普通的文档流(浏览器默认的布局模型)是为有限的宽度和无限的高度设计的，所以容器的高度应该由其中的内容决定而不能写定。</p>
<h2 id="内容溢出的问题"><a href="#内容溢出的问题" class="headerlink" title="内容溢出的问题"></a>内容溢出的问题</h2><p>如果盒子的高度写死了，里面的内容又太多就会出现内容溢出，对此可以为其添加overflow属性，该属性有四个值</p>
<pre><code>    visible: 默认值，会看见溢出
    hidden: 隐藏溢出内容
    scroll: 容器出现滚动条 不管有没有溢出
    auto: 只有溢出才会出现滚动条
    一般都用auto而不是scroll
</code></pre>
<p>也存在水平溢出的问题，比如一个贼长的url地址，如果让他溢出换行的话会很难看，贼难看，我们就可以用overflow-x单独控制水平溢出(-y单独控制垂直溢出)</p>
<h2 id="百分比高度备选方案"><a href="#百分比高度备选方案" class="headerlink" title="百分比高度备选方案"></a>百分比高度备选方案</h2><p>之前我们知道width和heigh这些可以设置百分比数值，是相对于他们的父元素解析的，所以想在某一个容器上用百分比数值必须确定该容器的父元素对应的属性有明确的值，不然会造成死循环，最好的选择就是用vh啦，当然也有其他的方法，比如<strong>等高列</strong></p>
<p>所谓等高列，就是一行内所有的容器都是等高的，无论增加哪个容器的高度，其余容器都会相应变高，有种苟富贵勿相忘的感觉。实现等高列的方法就是让那些容器自己根据自己的内容决定高度，然后拔高较矮的列就行。 有CSS表格和Flexbox两种方法实现。</p>
<h3 id="CSS表格布局"><a href="#CSS表格布局" class="headerlink" title="CSS表格布局"></a>CSS表格布局</h3><p>表格布局自然就是把父容器的display属性的值设置成table，然后把想要实现等高列的容器的display属性设置为table-cell就行。此时有两个注意点:</p>
<ol>
<li>显示为table的元素宽度不会扩展到100%，所以要写定width: 100%</li>
<li>此时margin值就会失效，等高列之间互相贴合，这时就要用上表格元素的属性 border-spacing来定义单元格之间的间距，该属性接收两个值，分别设置水平间距和垂直间距，但此时直接写的话，由于是水平间距的原因，这就会导致等高列无法跟头部左右两边对齐了，这时就需要在表格容器外面在包一个元素，给他添上一个负的外边距值就可以了，说起来有点复杂，直接看代码</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.table</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">border-spacing</span>: <span class="number">1em</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.table-cell</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Felxbox"><a href="#Felxbox" class="headerlink" title="Felxbox"></a>Felxbox</h3><p>还可以用flex布局实现等高列<strong>不考虑兼容性就用 遇事不决flex！！！</strong> ，因为flex布局默认产生等高的元素，只要一句display:flex;就能解决，后续会有更详细的介绍，左侧栏搜索即可啦。</p>
<p>最后 <em><strong>一定不要轻易明确元素的高度！！！</strong></em></p>
<h2 id="min-height和max-height"><a href="#min-height和max-height" class="headerlink" title="min-height和max-height"></a>min-height和max-height</h2><p>我们可以用这两个属性限定元素的高度在一个范围内，类似的是min-width 和 max-width</p>
<h1 id="垂直居中和水平居中"><a href="#垂直居中和水平居中" class="headerlink" title="垂直居中和水平居中"></a>垂直居中和水平居中</h1><p>这部分是个大头，因为能实现的方法太多了，要根据不同的情况给出不同的方法，这里说一些可能会用到的方法，我们先看水平居中，这部分相对于而言比较简单 <strong>因为一般情况下容器的宽度是给定的而高度是未给定的</strong></p>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><p>那么有哪些方法可以实现水平居中呢？</p>
<h3 id="行内元素水平居中"><a href="#行内元素水平居中" class="headerlink" title="行内元素水平居中"></a>行内元素水平居中</h3><p>这个简单，行内元素就是p啊，button啊啥的这写文本内容，就一句text-align: center;就可以了</p>
<h3 id="块级元素水平居中"><a href="#块级元素水平居中" class="headerlink" title="块级元素水平居中"></a>块级元素水平居中</h3><p>定宽的水平居中: 该元素宽度给定的话，就 margin: 0 auto;**</p>
<p>不定宽的水平居: </p>
<ol>
<li>该元素宽度不固定，就给要居中的元素设置display:table; margin: 0 auto; </li>
<li>该元素设置display: inline-block,父元素设置text-align:center;</li>
<li>flex布局: 只需把要处理的块状元素的父元素设置display:flex,justify-content:center;</li>
<li>position + 负margin；</li>
<li>position + margin：auto</li>
<li>position + transform；</li>
</ol>
<p>这里方法4、5、6同下面垂直居中一样的道理，只不过需要把top/bottom改为left/right，在垂直居中部分会详细讲述</p>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="文本-行内元素-垂直居中"><a href="#文本-行内元素-垂直居中" class="headerlink" title="文本(行内元素)垂直居中"></a>文本(行内元素)垂直居中</h3><p>单行:设置paddingtop=paddingbottom；或 设置line-height=height(容器高度)；</p>
<p>多行:通过设置父元素table，子元素table-cell和vertical-align;vertical-align:middle的意思是把元素放在父元素的中部</p>
<h3 id="块级元素垂直居中"><a href="#块级元素垂直居中" class="headerlink" title="块级元素垂直居中"></a>块级元素垂直居中</h3><ol>
<li>flex布局:在需要垂直居中的父元素上，设置display:flex和align-items：center <strong>父元素的height值必须设置</strong></li>
<li>定位子绝父相后，需要居中元素设置top: 50%; margin-top: -(自身高度的一半); 所以这个要设置该垂直居中元素的高度</li>
<li><strong>定位子绝父相后，需要居中元素设置top: 50%; transform: translate(0,-50%) 这个不需要知道该元素自身尺寸</strong>，所以用这个比较好，可能会有兼容性问题</li>
</ol>
<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>其实水平居中垂直居中都是为了这个服务的，因为这样最好，中国人嘛，讲究规整嘿嘿，然后有以下几种方法</p>
<ol>
<li>绝对定位后加 margin: auto, (top/bottom/rigth/left都为0)</li>
<li>绝对定位后 利用上述水平居中/垂直居中的方法4和方法2 </li>
<li>绝对定位后 top: 50%; left: 50%;transform: translate(-50%,-50%),<strong>在未定义尺寸的情况下</strong></li>
<li>flex布局 就是用上述中flex用的水平/垂直居中方法结合就行</li>
<li>table-cell 不喜欢用 就不写了</li>
</ol>
<p>综上 其实还是推荐用flex布局和transform的，但好像都是C3的写法要考虑兼容性，不太清楚，总之看情况来吧。</p>
<p><em><strong>这里明确一下负margin，如果给margin的left或者top设置负值，则元素会相应的向左或者上方移动，若是设置right和bottom为负值，则会将相应位置的后续元素拉过来与自身重叠，在有些地方会有妙有，比如上面说的实现居中的时候，但还是减少使用</strong></em></p>
<h1 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 在CSS中，两个或多个毗邻的普通流中的盒子（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，这种形成的外边距称之为外边距折叠。<br>  关键字：毗邻、两个或多个、垂直方向和普通流</p>
<h2 id="什么时候会发生外边距折叠呢"><a href="#什么时候会发生外边距折叠呢" class="headerlink" title="什么时候会发生外边距折叠呢"></a>什么时候会发生外边距折叠呢</h2><p>普通流中的块级元素的margin-bottom永远和它相邻的下一个块级元素的margin-top叠加，除非相邻的兄弟元素clear<br>普通流中的块级元素（没有border-top、没有padding-top）的margin-top和它的第一个普通流中的子元素（没有clear）发生margin-top叠加<br>普通流中的块级元素（height为auto、min-height为0、没有border-bottom、没有padding-bottom）和它的最后一个普通流中的子元素（没有自身发生margin叠加或clear）发生margin-bottom叠加<br>如果一个元素的min-height为0、没有border、没有padding、高度为0或者auto、不包含子元素，那么它自身的外边距会发生叠加</p>
<h2 id="外边距折叠的大小"><a href="#外边距折叠的大小" class="headerlink" title="外边距折叠的大小"></a>外边距折叠的大小</h2><pre><code> 1.两个相同大小的正数：取某个外边距的值。即30px与30px发生折叠，折叠后的值为30px。
 2.两个不同大小的正数：取较大的外边距的值。即30px与20px发生折叠，折叠后的值为30px。
 3.一正一负：取正数与负数的和。即30px与-20px发生折叠，折叠后的值为10px。
 4.相同大小的负数：同相同大小正数。-30px与-30px折叠，折叠后为-30px。
 5.不同大小负数： 取绝对值较大的负数。-30px与-20px折叠，折叠后为-30px。
</code></pre>
<h2 id="避免外边距的方法"><a href="#避免外边距的方法" class="headerlink" title="避免外边距的方法"></a>避免外边距的方法</h2><ol>
<li>对容器添加overflow: auto , 防止内部元素的外边距与容器外部外边距折叠，这种方法副作用最小</li>
<li>在发生折叠的外边距之间加上边框或者内边距</li>
<li>如果容器为浮动元素，行内块元素，绝对定位或者固定定位时</li>
<li>使用Flexbox布局或者网格布局</li>
<li>元素显示为, table-cells, table-row等</li>
</ol>
<p>即，创建了BFC的元素不会发生外边距折叠的问题，关于BFC请<a href="https://www.cnblogs.com/libin-1/p/7098468.html">点击这里</a></p>
<h1 id="猫头鹰选择器"><a href="#猫头鹰选择器" class="headerlink" title="猫头鹰选择器 * + *"></a>猫头鹰选择器 * + *</h1><p>叫这个名字的原因无它 就是因为长的像猫头鹰而已，其中 +： 相邻兄弟选择器（Adjacent sibling selector）可选择紧接在另一元素后的元素，且二者有相同父元素。<br>猫头鹰选择器会选中<strong>页面上有着相同父元素的非第一个子元素</strong>(比如ul里面会选择第二个往后的所有li)<br>一般用于给他们添加一个统一的margin-top解决边距问题</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* + * &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最后，有:</p>
<ol>
<li><em><strong>tag + tag 会选择除第一个tag之外的所有tag</strong></em></li>
<li><em><strong>因为’margin-left’ + ‘border-left-width’ + ‘padding-left’ + ‘width’ + ‘padding-right’ +’border-right-width’ + ‘margin-right’ = width of containing block ，在我们只设置了margin-left: auto 后为满足上式 ，就有margin-left =  width,故元素会直接到容器的最右边</strong></em></li>
</ol>
<p> ok 第三章的笔记就到这，书上的基础部分也结束了，接下来就到了关键的布局咯</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit14-过渡</title>
    <url>/2021/07/31/CssU14/</url>
    <content><![CDATA[<p>Css U14 学习笔记</p>
<span id="more"></span>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit2-相对单位</title>
    <url>/2021/06/12/CssU2/</url>
    <content><![CDATA[<p>Css in depth 第二章学习笔记</p>
<span id="more"></span>

<p>接下来开始相对单位的学习啦，因为对于小幸运这种大量适配移动端的网页项目来说，是肯定不能用px这种单位的，直接盲目的学这些相对单位，包括@medium啥的卡了好久，这章节算是帮我捋清了很多东西。</p>
<h1 id="em和rem"><a href="#em和rem" class="headerlink" title="em和rem"></a>em和rem</h1><h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p>em是最常见的相对单位，适于基于特定字号进行排版，在CSS中，1em就等于当前元素的字号。<br>浏览器中默认的字体字号是16px,也就是说再不进行层叠的情况下，1em的值就是16px。其实就是</p>
<pre><code>    body&#123;
        font-size: 16px;
    &#125;
</code></pre>
<p>其余后代元素的font-size会继承这一字号大小(再不加上声明的情况下，这些后代元素也可以用em来定义)，但em会有问题，比如嵌套列表，要不断的用1em覆盖继承来的font-size大小才能解决这一问题，所以我们有更好的选择 rem</p>
<h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>rem,字面上看就是root em,也就是说所有rem都是相对于祖元素的font-size来说的，就不用担心继承的问题了。在DOM树中，html元素是顶级(根)节点，它下面是子节点head和body，再后面就是逐层嵌套的后代节点。根节点是所有其他元素的祖先节点，它有一个伪类选择器(:root)，可以用来选中自己。:root{} === html{}。<br>rem虽然好用，但不是万能的，书里说，CSS关于所有问题的答案只有一种: 看情况。 (真的麻了)<br>所以书里也帮我们总结了一条规律呀:</p>
<p><strong>rem设置字号，px设置边框，em设置其他大部分属性</strong></p>
<h2 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h2><p>这为什么叫反模式我也不清楚，总之就是把默认字号设置成10px(0.625en)，这样就方便计算了，比如什么14px就是1.4em啊啥的，书里不推荐这种方法，因为这其实还是像素思维，脑子里想的一直是大概要多少像素然后写出em，这样其实就根本没有用em的必要，我们用相对单位就是为了在响应式开发中引入一个模糊的概念，也就是到底多少像素不重要，只要在适配屏幕的过程中字体大小等看着舒服就行。书上就说是在跟设计师先规定好根元素的字号后(通常是类似于标题或者页脚的字号)，然后在相对于的地方进行计算。<br>这里就推荐Vscode里面的一个插件！ <strong>px to rem &amp; rpx</strong> 这样编译器会自动帮我们计算哈，偷懒第一人(dog)</p>
<h2 id="构造响应式面板"><a href="#构造响应式面板" class="headerlink" title="构造响应式面板"></a>构造响应式面板</h2><p>顾名思义，就是根据屏幕尺寸的大小来改变网页的字号大小，用媒体查询@media来实现，书上说后面的章节会详细介绍，这里就先不写那么多了。</p>
<h1 id="视口相对单位"><a href="#视口相对单位" class="headerlink" title="视口相对单位"></a>视口相对单位</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>先明白视口的概念:就是浏览器的可视窗口，不包括什么地址栏啊工具栏啊什么的。<br>视口单位有四种:</p>
<pre><code>    vh: 视口高度的1/100
    vw: 视口宽度的1/100
    vmin: 视口宽/高较小的1/100
    vmax: 视口宽/高较大的1/100
    vmin/vmax 用于手机竖屏和横屏变化的情况
</code></pre>
<h2 id="calc-函数"><a href="#calc-函数" class="headerlink" title="calc()函数"></a>calc()函数</h2><p>视口单位一般用于定义div啥的，定义字号会很麻烦，比如屏幕贼大的时候字贼大，屏幕贼小的时候字又贼小，所以为了避免这些极端情况，我们就可以用上calc()函数，该函数内可以对两个极其以上的值进行基本运算，也能结合不同单位。<br>比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">0.5em</span> + <span class="number">1vw</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以保证字体有0.5em的下限不会过小，又有1vw可以随着屏幕增长平滑过渡</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="无单位的值"><a href="#无单位的值" class="headerlink" title="无单位的值"></a>无单位的值</h2><p>有些属性允许无单位，比如line-height,z-index,font-weight(700为bold，400为normal)，而line-height的无单位数值也是相当于字号的相对值，而加上单位可能会出现文字重叠的问题，所以最好不好给行高添加单位</p>
<h2 id="自定义属性-即CSS变量"><a href="#自定义属性-即CSS变量" class="headerlink" title="自定义属性(即CSS变量)"></a>自定义属性(即CSS变量)</h2><p>所谓自定义属性，又叫CSS变量，我们可以声明一个自定义属性，就可以在样式表中的其他地方引用这个值。<br>我们可以这么定义和引用自定义属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    --mian-<span class="attribute">font</span>: Arial,Helvetica;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="built_in">var</span>(--main-font);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义属性的真正意义在于它能够层叠和继承，可以在多个选择器中定义相同的变量，这个变量在不同地方有不同的值。<br>(感觉把这个东西放在react里面用会很高级)</p>
<p>第二章的笔记就到这了，也只是笼统的概述了一下，具体要看后续的学习和实操响应式开发吧，继续加油</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit5-Flexbox</title>
    <url>/2021/06/12/CssU5/</url>
    <content><![CDATA[<p>Css in depth 第五章 flexbox 的学习笔记</p>
<span id="more"></span>


<h1 id="Flexbox-原则"><a href="#Flexbox-原则" class="headerlink" title="Flexbox 原则"></a>Flexbox 原则</h1><p>从display属性开始，当我们给一个元素添加display:flex后，该容器就会变成一个弹性容器，它的直接子元素就变成了弹性子元素，弹性子元素默认是在同一行按照从左到右的顺序并排排列。 弹性容器和块级容器一样自动填满可用的宽度，但弹性子元素不一定会填满容器的宽度弹性子元素高度相等，该高度由他们的内容决定。</p>
<p>然后弹性容器里面有两个坐标轴，主轴为水平x(默认，从左到右)和副轴y(从上到下)，子元素就会默认沿主轴排列，并成等高列形式。</p>
<h1 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h1><p>接下来就要看看flex布局的属性了，这部分是核心，了解他们才能熟练掌握flex布局，接下来先看看容器属性，也就是通过在弹性容器中设置属性来操纵弹性子元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. flex-direction: 设置主轴方向</span><br><span class="line">&#123;</span><br><span class="line">    row  //默认</span><br><span class="line">    row-reverse  //从右到左</span><br><span class="line">    column  //从上到下</span><br><span class="line">    column-reverse //从下到上</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. justify-content: 设置主轴上子元素排列方式</span><br><span class="line">&#123;</span><br><span class="line">    flex-start  //默认</span><br><span class="line">    flex-end  //从尾部开始</span><br><span class="line">    center  //居中对齐</span><br><span class="line">    space-around //平分剩余空间</span><br><span class="line">    space-between //先两边贴合 再平分剩余空间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3. flex-warp: 设置子元素是否换行</span><br><span class="line">&#123;</span><br><span class="line">    nowarp  //默认不换行</span><br><span class="line">    wrap  //换行</span><br><span class="line">    wrap-reverse  //换行，第一行往下</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. align-items: 设置侧轴子元素排列方式 (单行)</span><br><span class="line">&#123;</span><br><span class="line">    flex //侧轴默认方向</span><br><span class="line">    flex-end  //默认反向</span><br><span class="line">    center  //居中</span><br><span class="line">    stretch  //拉伸(默认)</span><br><span class="line">    baseline  //取内容第一行文字基线对齐</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5. align-content: 设置侧轴子元素排列方式(多行)</span><br><span class="line">&#123;</span><br><span class="line">    其他属性和单行相同，多了space-around 和 space-bettwen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6. flex-flow 同时设置 flex-direction 和 flex-warp </span><br></pre></td></tr></table></figure>

<h1 id="item-属性"><a href="#item-属性" class="headerlink" title="item 属性"></a>item 属性</h1><p>接下来再看看子相属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order 定义项目排列顺序 数值越小 排列越靠前</span><br><span class="line">flex-basis 定义了该item(弹性子元素)尺寸的基准值，默认是auto，即项目由本身内容决定的尺寸，该值可以是任意width单位值，</span><br><span class="line">flex-grow  每个item的增长比例，即用于平分剩余空间时所占的比例</span><br><span class="line">flex-shrink  每个item的缩小比例 即内容溢出后所占的缩小比例</span><br><span class="line">flex： flex-gorw，flex-shrink，flex-basis 的合写</span><br><span class="line">align-self 用于设置单个item的对齐方式，可以覆盖align-items 值与其相等</span><br></pre></td></tr></table></figure>

<p>Okey Flex到此为止咯</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit7-定位和层叠上下文</title>
    <url>/2021/06/12/CssU7/</url>
    <content><![CDATA[<p>Css in depth 第七章笔记</p>
<span id="more"></span>


<p>前面介绍的几种布局方式都是按照display属性来的，这次介绍的定位是由 position 决定，position属性的初始值是static，一旦这个值被改变来我们就说这个元素被定位了，接下来就了解一下定位的具体方式吧</p>
<h1 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h1><p>因为固定定位用的较少，就先从它开始了。<br>固定定位的属性值就是 position:fixed;<br>还需要搭配 top/bottom/left/right 四个属性，这些属性决定了定位元素和浏览器视口的距离，这四个值还隐式的定义了元素的宽高，比如指定left:2em;right:2em;则元素的宽度就是浏览器视口减去4em。<br>被固定定位后的元素会固定在浏览器视口的某个位置，并脱离原本的位置。(广告啊弹窗啥的)</p>
<h1 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h1><p>首先绝对定位不像固定定位的元素那样相对于浏览器视口实现边偏移(top/bottom/right/left)，它是相对于自身的被定位的祖先元素(有爹找爹没爹找爷)来说的，如果没有祖先元素才会找到浏览器，添加了绝对定位的元素也会释放原来的位置。绝对定位经常和Js配合实现下拉菜单，消息盒子，工具提示等功能，在这之前，我们先看看它必须得有的搭档，相对定位</p>
<h1 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h1><p>被相对定位的元素是相对于自身原本占有的位置进行移动的，会保留原本拥有的位置。但添加了相对定位的元素我们不会移动它，我们会把它当作绝对定位元素的祖先容器，这就是所谓的<strong>子绝父相</strong><br>因为添加绝对定位的子元素可以放在父容器的任何地方，同时释放自身原有位置也不会影响其他兄弟元素的位置，而容器盒子需要添加一个定位限制住子盒子定位在自身内部，最后容器盒子布局需要在标准流中占一个位置，因此就有了子绝父相这句话的由来。</p>
<h1 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h1><p>定位多了都脱离原来位置了，就容易发生层叠，用z-index属性就好，可以理解为一个z轴嘛，值越大z坐标越高元素位置越高，就不会被其他元素覆盖层叠了。</p>
<h1 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h1><p>粘性定位是固定定位和相对定位的结合，把被粘性定位定位后的某元素固定在浏览器某个位置，一开始会随着浏览器视口的滚动而滚动，到达特定位置后就不会再变了，占有原先位置。</p>
<p>定位到这也就结束啦x</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Flux与Redux</title>
    <url>/2021/09/19/Flux%E4%B8%8ERedux/</url>
    <content><![CDATA[<p>基于React的比较重要的思想和库，这里也简单的写个博客记录一下学习过程</p>
<span id="more"></span>

<p>Flux架构说到底就是一种思想，就比如说我们写一个组件的时候，就很容易在一个组件内又写请求数据的函数又把这些数据展示出来，就会让一个组件显得很长很长，但其实业务逻辑不需要关心数据从哪里来，只需要定义好传入的接口就行了，数据应该抽象到其他地方去做，比如把数据抽象到父组件中去。这样就完成了数据请求和业务逻辑的分开。我们称只有数据请求的组件叫<strong>容器型组件</strong>，而只有业务逻辑没有数据请求的组件叫<strong>展示型组件</strong>。这样抽象后的代码是具有更多的可读性和可维护性，但是！！！！这不是最佳的办法，因为请求数据这部分还是写在了组件当中，数据与逻辑解耦才是我们真正想要的！这是，Flux架构就来了。</p>
<h1 id="Flux架构"><a href="#Flux架构" class="headerlink" title="Flux架构"></a>Flux架构</h1><p>Flux可以说是MVC模式的一种变体，更为清晰和简单，对于MVC可以自行搜索了解。Flux的核心思想就是<strong>数据和逻辑永久单向流动</strong>我们看一下他的流程图<br><img src="/2021/09/19/Flux%E4%B8%8ERedux/flux.png" alt="flux"><br>详细点就是<br><img src="/2021/09/19/Flux%E4%B8%8ERedux/flux2.png" alt="flux"><br>简单的用语言说就是：</p>
<ol>
<li>用户访问 View</li>
<li>View 发出用户的 Action</li>
<li>Dispatcher 收到 Action，要求 Store 进行相应的更新</li>
<li>Store 更新后，发出一个”change”事件</li>
<li>View 收到”change”事件后，更新页面</li>
</ol>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>简单的了解了Flux后，我们就看看Redux，Redux就是基于Flux架构实现的一个react库，用于集中式管理状态，我们先看看他的原理图<br><img src="/2021/09/19/Flux%E4%B8%8ERedux/redux.png" alt="redux"></p>
<ul>
<li>这个原理图就是，比如我们在UI界面端点击了一个按钮，要把这个按钮从白色变成红色，在我们点击后会触发点击时间，调用了store.dispath()方法把一个action传给store，然后store就会再帮我们调用reducer函数。reducer是个纯函数，他会根据action修改相应的状态并返回给store，然后store更新状态，我们button的颜色就会相应更改了(store.getState())</li>
</ul>
<p>我们用形象点的语言来解释一下</p>
<ul>
<li>我们是顾客，去一个饭店吃饭，ReactComponents就是菜单，是我们能看到的UI图，然后我们点菜，就会告诉店小二我们要吃啥，这个店小二就是ActionCreators，店小二就会拿着我们的想要的食物(action)去告诉(dispatch)老板，老板就是store，然后老板再把这个消息告诉后厨(Reducers)，后厨知道我们要吃啥了，就刷刷刷加工给我们上食材(返回新状态)。</li>
</ul>
<p>重点API</p>
<ol>
<li>store.getState() 获取状态</li>
<li>store.dispatch() 更改状态</li>
<li>store.subscribe() 监听状态的改变</li>
</ol>
<p><strong>注意中间件的使用！并且中间件一般是是在dispatch里生效的</strong></p>
<h1 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h1><p>就是 Facebook团队基于redux的影响出了一个可以更好的使用redux的一个库。<br>重点有如下API</p>
<ul>
<li>connect()</li>
<li>&lt;Provider/&gt;组件</li>
</ul>
<p>先看看react-redux的模型图<br><img src="/2021/09/19/Flux%E4%B8%8ERedux/react-redux.png" alt="react-redux"><br>react-redux中把一个组件拆开，分成UI组件和容器组件(更贴合于Flux架构)，然后UI组件不接受任何业务逻辑，就类似与纯函数，他就像一个“纯组件”，只通过接受过来的props参数来改变渲染结果，然后Count组件就负责承担业务逻辑和与redux沟通，并把store中的state以及更改state的方法(dispatch)分发给UI组件，而connect()方法就是起这个作用的。</p>
<h2 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h2><p><code>const Container = connect(mapStateToProp,mapDispatchToProps)(UI)</code><br>这样Container就是一个被加工的容器组件，这传代码的意思是，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。<br>从本质上说connect可以看作是一个高阶函数</p>
<p>mapStateToProps</p>
<ol>
<li>mapStateToProps函数返回的是一个对象；</li>
<li>返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value</li>
<li>mapStateToProps用于传递状态</li>
</ol>
<p>mapDispatchToProps</p>
<ol>
<li>mapDispatchToProps函数返回的是一个对象；</li>
<li>返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value</li>
<li>mapDispatchToProps用于传递操作状态的方法</li>
</ol>
<h2 id="lt-Provider-gt"><a href="#lt-Provider-gt" class="headerlink" title="&lt;Provider/&gt;"></a>&lt;Provider/&gt;</h2><p>Provider组件就是基于react中的Context实现的，connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。这里用Provider就可以直接让容器组件拿到了。具体源码实现这里就不放了。</p>
<h1 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h1><p>就看看redux在生产环境中是如何使用的吧,我们做出这样一个效果<br><img src="/2021/09/19/Flux%E4%B8%8ERedux/ui.png" alt="ui"><br>上方Count组件可以拿到下方Person组件的人数，然后Person组件也可以取到上方Count组件的求和数，先看项目文件<br><img src="/2021/09/19/Flux%E4%B8%8ERedux/code.png" alt="code"></p>
<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>除了redux文件夹里面的东西要讲一讲外其他的都没啥必要了。那就按顺序，我们分析需求，要用到redux，就先把这些文件夹建起来，该装的依赖装好，然后分需求，看看有什么，Count组件要计算， Person组件要添加人数，然后根据这些需求去写action</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// constant.js 文件</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	该模块是用于定义action对象中type类型的常量值，目的只有一个：便于管理的同时防止程序员单词写错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">&#x27;increment&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT = <span class="string">&#x27;decrement&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_PERSON = <span class="string">&#x27;add_person&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	该文件专门为Count组件生成action对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT,DECREMENT&#125; <span class="keyword">from</span> <span class="string">&#x27;../constant&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同步action，就是指action的值为Object类型的一般对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;<span class="attr">type</span>:INCREMENT,data&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;<span class="attr">type</span>:DECREMENT,data&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步action，就是指action的值为函数,异步action中一般都会调用同步action，异步action不是必须要用的。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> incrementAsync = <span class="function">(<span class="params">data,time</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">			dispatch(increment(data))</span><br><span class="line">		&#125;,time)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Person组件生成action对象</span></span><br><span class="line"><span class="keyword">import</span> &#123; ADD_PERSON &#125; <span class="keyword">from</span> <span class="string">&quot;../constant&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addPerson = <span class="function"><span class="params">personObj</span> =&gt;</span> (&#123;<span class="attr">type</span>:ADD_PERSON,<span class="attr">data</span>:personObj&#125;)</span><br></pre></td></tr></table></figure>

<p>然后就根据action写reducer</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	1.该文件是用于创建一个为Count组件服务的reducer，reducer的本质就是一个函数</span></span><br><span class="line"><span class="comment">	2.reducer函数会接到两个参数，分别为：之前的状态(preState)，动作对象(action)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initState = <span class="number">0</span> <span class="comment">//初始化状态</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">countReducer</span>(<span class="params">preState=initState,action</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//从action对象中获取：type、data</span></span><br><span class="line">	<span class="keyword">const</span> &#123;type,data&#125; = action</span><br><span class="line">	<span class="comment">//根据type决定如何加工数据</span></span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>: <span class="comment">//如果是加</span></span><br><span class="line">			<span class="keyword">return</span> preState + data</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>: <span class="comment">//若果是减</span></span><br><span class="line">			<span class="keyword">return</span> preState - data</span><br><span class="line">		<span class="attr">default</span>:</span><br><span class="line">			<span class="keyword">return</span> preState</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person</span></span><br><span class="line"><span class="keyword">import</span> &#123;ADD_PERSON&#125; <span class="keyword">from</span> <span class="string">&#x27;../constant&#x27;</span></span><br><span class="line"><span class="comment">//初始化人的列表</span></span><br><span class="line"><span class="keyword">const</span> initState = [&#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">personReducer</span>(<span class="params">preState=initState,action</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">const</span> &#123;type,data&#125; = action</span><br><span class="line">	<span class="keyword">switch</span> (type) &#123;</span><br><span class="line">		<span class="keyword">case</span> ADD_PERSON: <span class="comment">//若是添加一个人</span></span><br><span class="line">			<span class="keyword">return</span> [data,...preState]</span><br><span class="line">		<span class="attr">default</span>:</span><br><span class="line">			<span class="keyword">return</span> preState</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后联合reducer</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	该文件用于汇总所有的reducer为一个总的reducer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//引入combineReducers，用于汇总多个reducer</span></span><br><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="comment">//引入为Count组件服务的reducer</span></span><br><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">&#x27;./count&#x27;</span></span><br><span class="line"><span class="comment">//引入为Person组件服务的reducer</span></span><br><span class="line"><span class="keyword">import</span> persons <span class="keyword">from</span> <span class="string">&#x27;./person&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//汇总所有的reducer变为一个总的reducer</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  combineReducers(&#123;</span><br><span class="line">	count,</span><br><span class="line">	persons</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后创建store</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	该文件专门用于暴露一个store对象，整个应用只有一个store对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入createStore，专门用于创建redux中最为核心的store对象</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore,applyMiddleware&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="comment">//引入汇总之后的reducer</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="comment">//引入redux-thunk，用于支持异步action</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露store </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer,applyMiddleware(thunk))</span><br></pre></td></tr></table></figure>

<p>至此，关于redux的文件就弄好了，接下来就去弄容器组件，Count组件要的state是Count和跟Person人数，Action是数字的运算，则有</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">	<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">		<span class="attr">count</span>:state.count,</span><br><span class="line">		<span class="attr">personCount</span>:state.persons.length</span><br><span class="line">	&#125;),</span><br><span class="line">	&#123;increment,decrement,incrementAsync&#125;</span><br><span class="line">)(CountUI)</span><br></pre></td></tr></table></figure>
<p>Person类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">	<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">		<span class="attr">count</span>:state.count,</span><br><span class="line">		<span class="attr">personCount</span>:state.persons.length</span><br><span class="line">	&#125;),</span><br><span class="line">	&#123;increment,decrement,incrementAsync&#125;</span><br><span class="line">)(CountUI)</span><br></pre></td></tr></table></figure>
<p>至此，对于react的基本介绍就到这里了。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit4-理解浮动</title>
    <url>/2021/06/12/CssU4/</url>
    <content><![CDATA[<p>Css in depth 第四章笔记</p>
<span id="more"></span>


<h1 id="什么是浮动"><a href="#什么是浮动" class="headerlink" title="什么是浮动"></a>什么是浮动</h1><p>就飘起来浮上去呗，在普通文档流中一个块级元素就是占据一行的，添加浮动后下面的元素就都跑到一行来了，满了塞不下了就换行，这就是浮动(我这解释有点破哈)，<br>并且浮动的元素具有行内块元素的特征，并不会保留原先的位置。<br>块级元素的宽=宽度默认情况下和父元素一致，而添加浮动后它的尺寸就根据内容决定了。<br>而设计浮动的初衷其实是为了实现这种效果</p>
<p><img src="/2021/06/12/CssU4/1.png" alt="1"></p>
<p>实现文字包围图片，跟报纸那样的。虽然现在浮动用的不多，很多东西都能代替浮动，比如flex布局，但还是很有必要学习浮动的，因为想要实现把图片移动到浏览器的一侧，或者文字围绕图片，浮动仍然是唯一的选择</p>
<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><h2 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h2><p>父元素容器很多情况下不方便给定高度，子元素添加浮动后又释放了原本的位置，那么父容器就成了一个高度为0且没有内容的容器，会影响下面普通文档流的其他元素，所以就需要清除该浮动带来的副作用。</p>
<p>如果父元素本身有高度则不需要清除浮动，同样，清除浮动后父元素会根据子元素的内容来改变自身的高度，就不会影响后面的标准流(普通文档流)的元素来</p>
<h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><ol>
<li><p>额外标签法(w3c推荐做法)<br>在浮动的元素后面添加一个 <code>&lt;div class=&#39;clear&#39;&gt;</code>,并写上</p>
<pre><code> .clear&#123;
     clear:both;
 &#125;
</code></pre>
</li>
<li><p>给父元素容器添加overflow属性(不是默认值就行)</p>
</li>
<li><p>伪元素法 类似于额外标签法，不过是用伪元素实现，假设父元素容器class=’clearfix’</p>
<pre><code> .clearfix:after&#123;
     content: &#39;&#39;;
     display: block;
     height: 0;
     clear: both;
     visibility: hidden;
 &#125;
</code></pre>
</li>
</ol>
<p>或者用双伪元素法 //用于清除外边距折叠的时候用 因为有了BFC</p>
<pre><code>    .clearfix:before,clearfix:after&#123;
        content: &#39;&#39;;
        display: table;
    &#125;

    .clearfix:after&#123;
        clear: both;
    &#125;
</code></pre>
<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p>哎 上一章刚说的BFC，这一章就提到了，那就简单聊聊吧<br>BFC(块级格式化上下文 (Block Fromatting Context)) 书上的和网上搜的说的都有点怪，我的理解就是在网页中划分一个一个区域，或大或小，每个区域有着自己的内容，不会干涉到其他区域。以下方式会创建一个BFC</p>
<pre><code>     float: left or float: right—anything but none
     overflow: hidden, auto, or scroll—anything but visible
     display: inline-block, table-cell, table-caption, flex, inline-flex,grid, or inline-grid—these are called block containers.
     position: absolute or position: fixed
</code></pre>
<p><strong>Css也有框架，比如bootstrap啥的，也可以学学，</strong></p>
<h1 id="网格系统"><a href="#网格系统" class="headerlink" title="网格系统"></a>网格系统</h1><p><a href="https://www.w3school.com.cn/css/css_grid.asp">网格系统</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>HOC | render props | hook</title>
    <url>/2021/09/14/HOC-render-props-hook/</url>
    <content><![CDATA[<p>react的中 对于一些复用的节点，我们可以抽成一个组件，而对于一些复用的逻辑，我们也可以抽象化这个逻辑来优化代码，主要有三种方法，HOC，render props，和自定义hook</p>
<span id="more"></span>

<h1 id="HOC"><a href="#HOC" class="headerlink" title="HOC"></a>HOC</h1><p>HOC 就是高阶组件吗，之前有博客介绍了的，虽然写的有点烂但我这里就不赘述了，这里用一个计数器的demo，直接上高阶组件实现计数器的代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;View, Text,Button&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Count</span>(<span class="params">&#123;count,add,minus&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flex:1,alignItems:</span>&#x27;<span class="attr">center</span>&#x27;,<span class="attr">justifyContent:</span>&#x27;<span class="attr">center</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Text</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;add&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">add</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;minus&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">minus</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;changeTheme&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">ChangeTheme</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> countNumber=<span class="function">(<span class="params">initNumber</span>)=&gt;</span> <span class="function">(<span class="params">WrappedComponent</span>)=&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CountNumber</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        state = &#123;<span class="attr">count</span>: initNumber&#125;;</span><br><span class="line">        add = <span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span>&#125;);</span><br><span class="line">        minus = <span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>: <span class="built_in">this</span>.state.count - <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                &#123;<span class="attr">...this.props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">count</span>=<span class="string">&#123;this.state.count&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">add</span>=<span class="string">&#123;this.add.bind(this)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">minus</span>=<span class="string">&#123;this.minus.bind(this)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            /&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> countNumber(<span class="number">0</span>)(Count);</span><br></pre></td></tr></table></figure>
<p>优点:<br>可以看到，高阶组件是把逻辑和UI分开了，Count组件指负责渲染UI，被传入HOC中才有了计数的逻辑，这很好的维护了内层组件的状态，降低了耦合度<br>缺点:</p>
<ol>
<li>注意一下HOC的state是写死的，也就是说传入给Count组件的prop是写死的，这就有可能产生命名冲突，覆盖掉Count组件原有的props</li>
<li>HOC是链式调用，会导致错误难以定位</li>
</ol>
<h1 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h1><p>先直接上代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;View, Text,Button&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">RenderProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flex:1,alignItems:</span>&#x27;<span class="attr">center</span>&#x27;,<span class="attr">justifyContent:</span>&#x27;<span class="attr">center</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">CountNumber</span> <span class="attr">initNumber</span>=<span class="string">&#123;0&#125;</span> <span class="attr">render</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    (&#123;<span class="attr">count</span>,<span class="attr">add</span>,<span class="attr">minus</span>&#125;)=&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Text</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;add&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">add</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;minus&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">minus</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;changeTheme&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">ChangeTheme</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">                &#125;&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">CountNumber</span>&gt;</span></span></span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountNumber</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    state=&#123;<span class="attr">count</span>:<span class="built_in">this</span>.props.initNumber&#125;;</span><br><span class="line">    add=<span class="function">()=&gt;</span><span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span>&#125;);</span><br><span class="line">    minus=<span class="function">()=&gt;</span><span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count-<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.props.render(&#123;</span><br><span class="line">            <span class="attr">count</span>: <span class="built_in">this</span>.state.count,</span><br><span class="line">            <span class="attr">add</span>: <span class="built_in">this</span>.add,</span><br><span class="line">            <span class="attr">minus</span>:<span class="built_in">this</span>.minus</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样也实现了逻辑复用，还留下了一个“插槽”，也就是预留位置，缺点就是不能在return语句外访问数据，同时用的过多的话会跟HOC差不多，HOC是过长的链式调用形成异常栈，而render props则会形成潜逃地狱</p>
<h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><p>最后看一看最新的自定义hook</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;View, Text,Button&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,addCount,minusCount] = useCountNumber(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;backgroundColor:theme,flex:1,alignItems:</span>&#x27;<span class="attr">center</span>&#x27;,<span class="attr">justifyContent:</span>&#x27;<span class="attr">center</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Text</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;addCount&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">add</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;minusCount&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">minus</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;changeTheme&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">ChangeTheme</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCountNumber</span>(<span class="params">initNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(initNumber);</span><br><span class="line">    <span class="keyword">const</span> addCount=<span class="function">()=&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> minusCount=<span class="function">()=&gt;</span>setCount(count -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        count,</span><br><span class="line">        addCount,</span><br><span class="line">        minusCount</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>反正 hook作为最新的语法，最好还是多用他，但也不能完全代替</p>
<ul>
<li>Hooks：<ul>
<li>替代 Class 的大部分用例，除了 getSnapshotBeforeUpdate 和 componentDidCatch 还不支持。</li>
<li>提取复用逻辑。除了有明确父子关系的，其他场景都可以使用 Hooks。</li>
</ul>
</li>
<li>Render Props：在组件渲染上拥有更高的自由度，可以根据父组件提供的数据进行动态渲染。适合有明确父子关系的场景。</li>
<li>高阶组件：适合用来做注入，并且生成一个新的可复用组件。适合用来写插件。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Regexp</title>
    <url>/2021/06/09/Regexp/</url>
    <content><![CDATA[<p>正则表达式就是用于定义某种规则，计算机可以通过该规则检测一个字符串是否符合该规则<br>或者将该字符串中符合正则表达式的内容提取出来</p>
<span id="more"></span>

<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Regexp构造函数</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;正则表达式&#x27;</span>,<span class="string">&#x27;匹配模式&#x27;</span>) <span class="comment">//是一个对象 更简单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/a/i</span>; <span class="comment">//更灵活</span></span><br></pre></td></tr></table></figure>
<p>每个正则表达式就是一个RegExp实例对象，有着自己的属性，包括source，lastIndex等，这些属性可以全面了解正则表达式等信息，但实际用得不多。</p>
<p>在正则表达式中，不属于特殊字符代码的(如\n)的反斜杠会被保留，不像在一般字符串中被忽略，并且问号和加号等特殊字符在正则表达式中具有特殊含义，若要表示该字符本身，前面也要加\说明，如/+/。<br>匹配模式有i g m等，主要用: i忽略大小写 g开启全局匹配。</p>
<p>有一个test方法可以检测某字符串是否符合正则表达式,只要含有正则表达式中的的字符串就回返回true。<br>而exec()方法可以返回一个包含匹配信息的数组对象，该数组对象中有index(字符串中匹配模式的其实位置)和input(查找的字符串)两个属性，如果没有匹配到就返回一个null，如果不开启g，则每次调用该方法就回返回第一个匹配项，开启后则回往后搜寻下一个匹配项，并改变lastIndex属性的值(默认一直为0)。当正则表达式含有括号分组的字表达后，调用该方法后的数组对象第一个元素还是整体匹配的部分，但接下来的元素是由那些括号组所匹配的部分</p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>｜表示或的意思 a|b  []里面也表示｜的关系  /[a-z]/表示任意的小写字母 /[A-z]/任意字母<br>/[^a]/表示不包含a 除了a。<br>字符集也有一些内置的快捷方式。</p>
<pre><code>    \d  任何数字字符
    \w  字母数字字符
    \s  任何空白符字符
    \D  非数字字符
    \W  非字母数字字符
    \S  非空白符字符
    \b  匹配单词边界 (所谓单词就是隶属于\w下的字串)
    \B  匹配非单词边界
    .  除换行符以外的所有字符
</code></pre>
<p>对于要匹配重复的部分 则有以下方法，如：</p>
<pre><code>    /+/ 匹配一个或多个字符
    /*/ 与加号类似，但允许匹配0次
    /?/ 令某一部分可选，即可能出现一次或者零次

    //若要表示精确次数，就用&#123;&#125;，如

    &#123;2&#125; 表示出现两次
    &#123;2,4&#125; 表示出现2-4次
    &#123;2,&#125; 表示出现两次即以上
</code></pre>
<p><strong>记得若要重复多个元素时，要用括号，例如 <code>/(abc)+/</code></strong></p>
<pre><code>    /^a/ 表示必须以a开头
    /a$/ 表示必须以a结尾
</code></pre>
<p>所以/^a$/表示所匹配的字符串中有且只有a</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`Lis, Bar</span></span><br><span class="line"><span class="string">Mc, John</span></span><br><span class="line"><span class="string">Wad, Phio`</span>.replace(<span class="regexp">/(\w+), (\w+)/g</span>, <span class="string">&#x27;$2 $1&#x27;</span>));</span><br><span class="line"><span class="comment">// $1 和 $2 是模式中带括号的组。 整个匹配可以用 $&amp;来表示。</span></span><br><span class="line"><span class="comment">// 上述代码是 $1 指向 Lis / Mc / Wad ，$2 指向 Bar / John / phio ,然后$2 指向的匹配代替了$1匹配原有的位置</span></span><br></pre></td></tr></table></figure>

<p>字符串加正则<br>search 检索与正则表达式匹配的值 类似于indexof()方法 返回索引，搜不到就返回-1，接收正则表达式为参数<br>match   找到一个或多个正则的匹配  默认情况下之检索一个，开启全局匹配后则可以匹配多个， 把匹配到的内容封装成一个数组返回<br>replace 替换与正则表达式匹配的字串 两个参数，第一个是正则表达式，第二个是替换内容<br>split   把字符串拆分成数组</p>
<h2 id="匹配机制"><a href="#匹配机制" class="headerlink" title="匹配机制"></a>匹配机制</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> animalCount = <span class="regexp">/\b\d+ (pig|cow|chicken)s?\b/</span></span><br><span class="line"><span class="built_in">console</span>.log(animalCount.tesr(<span class="string">&quot;15 pigs&quot;</span>)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/09/Regexp/9-1.svg" alt="01"></p>
<p>回溯:<br>正则表达式/\b([01]+b|\d+|[\da-f]h)\b/可以匹配三种字符串：以b结尾的二进制数字，以h结尾的十六进制数字（即以 16 为进制，字母a到f表示数字 10 到 15），或者没有后缀字符的常规十进制数字。这是对应的图表。<br><img src="/2021/06/09/Regexp/9-2.svg" alt="02"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>antd的基本使用</title>
    <url>/2021/05/12/antd%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="引入组件"><a href="#引入组件" class="headerlink" title="引入组件"></a>引入组件</h1><p>先引入antd库嘛<br><code>yarn add antd</code></p>
<p>然后想用什么组件就去官网找相应代码，比如有一个Button按钮想引入，就直接import导入<br><code>import &#123;Button&#125; from &#39;antd&#39;</code><br>在你想要的合适的位置直接放进去就行<br><code>&lt;Button type=&quot;primary&quot;&gt;Primary Button&lt;/Button&gt;</code></p>
<span id="more"></span>
<p>用的比较多的是图标哈，就需要有另一个库<br><code>yarn add @ant-design/icons</code><br>想要啥就import导入然后写下来就行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; WechatOutlined, WeiboOutlined&#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/icons&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;WechatOutlined /&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">WeiboOutlined</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>还有轮播图啥的巴拉巴拉，自己去看官方文档就好了。</p>
<h1 id="按需引入和自定义内容"><a href="#按需引入和自定义内容" class="headerlink" title="按需引入和自定义内容"></a>按需引入和自定义内容</h1><p>这个好好看官方文档吧，3版本和4版本的不一样，暂时还没弄懂。。。。</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>Router base</title>
    <url>/2021/06/12/Router-base/</url>
    <content><![CDATA[<p>一篇关于使用路由的Blog</p>
<span id="more"></span>
<h1 id="路由简介"><a href="#路由简介" class="headerlink" title="路由简介"></a>路由简介</h1><p>在之前的react笔记中，我们已经简单的了解过路由</p>
<h2 id="1-SPA的理解"><a href="#1-SPA的理解" class="headerlink" title="1.SPA的理解"></a>1.SPA的理解</h2><p>1.单页Web应用（single page web application，SPA）。<br>2.整个应用只有一个完整的页面。<br>3.点击页面中的链接不会刷新页面，只会做页面的局部更新。<br>4.数据都需要通过ajax请求获取, 并在前端异步展现。</p>
<h2 id="2-路由的理解"><a href="#2-路由的理解" class="headerlink" title="2.路由的理解"></a>2.路由的理解</h2><ol>
<li>什么是路由?<br>一个路由就是一个映射关系(key:value)<br>key为路径, value可能是function或component</li>
<li>路由分类<br>后端路由：</li>
</ol>
<p>1)理解： value是function, 用来处理客户端提交的请求。<br>2)注册路由： router.get(path, function(req, res))<br>3)工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据<br>前端路由：<br>1)浏览器端路由，value是component，用于展示页面内容。<br>2)注册路由:<br><code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code><br>3)工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</p>
<h2 id="3-react-router-dom的理解"><a href="#3-react-router-dom的理解" class="headerlink" title="3.react-router-dom的理解"></a>3.react-router-dom的理解</h2><ol>
<li>react的一个插件库。</li>
<li>专门用来实现一个SPA应用。<br>基于react的项目基本都会用到此库。</li>
</ol>
<h2 id="4-内置组件"><a href="#4-内置组件" class="headerlink" title="4.内置组件"></a>4.内置组件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.&lt;BrowserRouter&gt; //支持H5history，用于包裹顶层组件，监听该组件中URL的变化，管理路由</span><br><span class="line">2.&lt;HashRouter&gt; //作用与前者相同，但使用URL的hash部分，不支持location.key或location.state</span><br><span class="line">3.&lt;Route&gt; //负责把一般组件注册为路由组件</span><br><span class="line">4.&lt;Redirect&gt; //类似与default，所有路径都不被匹配时就用它指定的路由组件</span><br><span class="line">5.&lt;Link&gt; // 前往路由组件，代替&lt;a&gt;标签</span><br><span class="line">6.&lt;NavLink&gt; // 与&lt;Link&gt;相同，不过会给点击后的链接默认添加一个active类名，与bootstrap联用实现</span><br><span class="line">高亮效果，具体样式可以自己封装</span><br><span class="line">7.&lt;Switch&gt; // 实现单一匹配，</span><br><span class="line"></span><br><span class="line">// 其它</span><br><span class="line">1.history对象</span><br><span class="line">2.match对象</span><br><span class="line">3.withRouter函数</span><br><span class="line">4.Route组件中exact属性的作用：路径进行精确匹配，不会存在包含关系</span><br></pre></td></tr></table></figure>

<p>这里我们可以简略的说一下路由的发展哈<br><strong>最早的最早，用户加载网页，是要等整个页面全部加载完才行，很麻烦很耗时间，后来呢，微软就搞了AJAX的基本概念，也就是XMLHttpRequest的前身，有了AJAX后，用户就不需要每次载完了，比如图片GIF什么的加载慢，就先往后靠靠，我看会儿文字，而不是等你图片加载好我才能看到文字。再后来，Google Map展现了AJAX的真正魅力，让其不仅仅局限于简单的数据和页面交互，为后来异步交互体验方式的繁荣发展带来了根基。</strong></p>
<p><strong>而异步交互体验的更高级版本就是 SPA—— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。</strong></p>
<h1 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h1><p>先要从’react-router-dom’中引入所需要的。</p>
<h2 id="用-lt-Link-gt-代替-lt-a-gt"><a href="#用-lt-Link-gt-代替-lt-a-gt" class="headerlink" title="用&lt;Link &gt; 代替&lt;a &gt;"></a>用&lt;Link &gt; 代替&lt;a &gt;</h2><p>原生Html中，用a标签实现不同页面的跳转：</p>
<p><code>&lt;a herf=&#39;/path&#39;&gt;tab&lt;/a&gt;</code></p>
<p>而在路由中就该用Link实现单页面跳转：</p>
<p><code>&lt;Link to=&#39;/&#39;&gt;tab&lt;/Link&gt;</code></p>
<p>to的值应和路由组件的path一致达成匹配</p>
<p><strong>&lt;NavLink&gt;中有个属性是activeClassName,默认是active，修改它的值就可以做到给点击的链接添加一个修改内容的类名</strong></p>
<h2 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h2><p>确定好要跳转的组件后，用Route把一般组件注册成路由组件，路由组件因为类似一个单页面，就要把他们放在一个名为pages的文件夹中和一般组件区分开。<br>然后再用Switch包裹这些路由组件，实现单一匹配。(防止一个路径匹配多个组件出现bug)<br>最后可以加上Redirect，表示默认</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span></span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;/</span>&gt;</span></span> <span class="comment">//这个就不会被显示</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Redireact</span> <span class="attr">to</span>=<span class="string">&#x27;/about&#x27;</span>/&gt;</span></span></span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<p>别忘了添加路由器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span></span><br><span class="line">&lt;/BrowserRouter&gt;,</span><br></pre></td></tr></table></figure>

<h2 id="路由组件接收到到参数"><a href="#路由组件接收到到参数" class="headerlink" title="路由组件接收到到参数"></a>路由组件接收到到参数</h2><p>路由组件会默认接到三个props</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     history:</span><br><span class="line">         go: f go(n); // n就是跳转到第几个浏览页面，可以是负数</span><br><span class="line">         goBack: f gouBack();</span><br><span class="line">         goForward: f goForWard();</span><br><span class="line">         push: f push(path,state); //state就是指下文的state参数</span><br><span class="line">         repalce: f replace)(path,state);</span><br><span class="line"></span><br><span class="line">     location:</span><br><span class="line">         pathname: &quot;/aboplut&quot;</span><br><span class="line">search: &quot;&quot;</span><br><span class="line">state: undefined</span><br><span class="line"></span><br><span class="line">     match:</span><br><span class="line">         params: &#123;&#125;</span><br><span class="line">         path: &quot;/about&quot;</span><br><span class="line">         url: &quot;/about&quot;</span><br></pre></td></tr></table></figure>

<h2 id="嵌套路由-多级路由"><a href="#嵌套路由-多级路由" class="headerlink" title="嵌套路由(多级路由)"></a>嵌套路由(多级路由)</h2><ol>
<li>注册子路由时要写上父路由的path值</li>
<li>路由的匹配是按照注册路由的顺序进行的</li>
</ol>
<h2 id="解决多级路径刷新页面样式丢失的问题"><a href="#解决多级路径刷新页面样式丢失的问题" class="headerlink" title="解决多级路径刷新页面样式丢失的问题"></a>解决多级路径刷新页面样式丢失的问题</h2><ol>
<li>public/index.html 中 引入样式时不写 ./ 写 / （常用）</li>
<li>public/index.html 中 引入样式时不写 ./ 写 %PUBLIC_URL% （常用）</li>
<li>使用HashRouter</li>
</ol>
<h2 id="路由的严格匹配与模糊匹配"><a href="#路由的严格匹配与模糊匹配" class="headerlink" title="路由的严格匹配与模糊匹配"></a>路由的严格匹配与模糊匹配</h2><ol>
<li>默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致）</li>
<li>开启严格匹配：&lt;Route exact={true} path=”/about” component={About}/ &gt;</li>
<li>严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由</li>
</ol>
<h2 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a>向路由组件传递参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.params参数</span><br><span class="line">路由链接(携带参数)：&lt;Link to=&#x27;/demo/test/tom/18&#x27;&#125;&gt;详情&lt;/Link&gt;</span><br><span class="line">注册路由(声明接收)：&lt;Route path=&quot;/demo/test/:name/:age&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">接收参数：this.props.match.params</span><br><span class="line"></span><br><span class="line">2.search参数/query参数</span><br><span class="line">路由链接(携带参数)：&lt;Link to=&#x27;/demo/test?name=tom&amp;age=18&#x27;&#125;&gt;详情&lt;/Link&gt;</span><br><span class="line">注册路由(无需声明，正常注册即可)：&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">接收参数：this.props.location.search</span><br><span class="line">备注：获取到的search是urlencoded编码字符串，需要借助querystring解析</span><br><span class="line">                </span><br><span class="line">3.state参数</span><br><span class="line">路由链接(携带参数)：&lt;Link to=&#123; &#123; pathname:&#x27;/demo/test&#x27;,state:&#123; name:&#x27;tom&#x27;,age:18 &#125; &#125; &#125;&gt;详情&lt;/Link&gt; 且不在地址栏上显示</span><br><span class="line">注册路由(无需声明，正常注册即可)：&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">接收参数：this.props.location.state</span><br><span class="line">备注：刷新也可以保留住参数(和浏览器的history有关，如果历史记录被清空则刷新就会丢失参数)</span><br></pre></td></tr></table></figure>

<h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><p>就是把一个一般组件加工，让其可以使用一些路由组件的API，比如props.history<br>用法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;withRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom-router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某组件Demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Demo)</span><br></pre></td></tr></table></figure>
<p>这样Demo组件就变成了一个新组件，不同于一般组件和路由组件</p>
<h2 id="BrowserRouter与HashRouter的区别"><a href="#BrowserRouter与HashRouter的区别" class="headerlink" title="BrowserRouter与HashRouter的区别"></a>BrowserRouter与HashRouter的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.底层原理不一样：</span><br><span class="line"></span><br><span class="line">		BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。</span><br><span class="line">		HashRouter使用的是URL的哈希值。</span><br><span class="line"></span><br><span class="line">2.path表现形式不一样</span><br><span class="line"></span><br><span class="line">	    BrowserRouter的路径中没有#,例如：localhost:3000/demo/test</span><br><span class="line">		HashRouter的路径包含#,例如：localhost:3000/#/demo/test</span><br><span class="line"></span><br><span class="line">3.刷新后对路由state参数的影响</span><br><span class="line">		(1).BrowserRouter没有任何影响，因为state保存在history对象中。</span><br><span class="line">		(2).HashRouter刷新后会导致路由state参数的丢失！！！</span><br><span class="line">			</span><br><span class="line">4.备注：HashRouter可以用于解决一些路径错误相关的问题。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>fetch-搜索用户</title>
    <url>/2021/05/10/fetch-%E6%90%9C%E7%B4%A2%E7%94%A8%E6%88%B7/</url>
    <content><![CDATA[<p>做项目嘛，肯定得与后端合作，这就需要从他们那里拿数据过来，也就是网络请求。在引入网络请求前，我们先明白几个概念。</p>
<span id="more"></span>
<h1 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h1><p>大家应该都知道XML是什么东西：<br><strong>XML(Extensible Markup Language)可扩展标记语言,跟html差不多，不过html是用来展示、表现数据，而XML则用来传输和储存数据</strong><br>那什么又是XMLHttpRequest 对象呢？<br>官方给的解释是<br>        <strong>XMLHTTP是一组API函数集，可被JavaScript、JScript、VBScript以及其它web浏览器内嵌的脚本语言调用，通过HTTP在浏览器和web服务器之间收发XML或其它数据</strong><br>也就是说他可以用于在后台与服务器交换数据<br>Emmmm,听上去挺模糊的，但有了XMLhttpRequest 对象，我们就可以：</p>
<pre><code>    在不重新加载页面的情况下更新网页
    在页面已加载后从服务器请求数据
    在页面已加载后从服务器接收数据
    在后台向服务器发送数据
</code></pre>
<p>哎呀，具体细节可以前W3C看看，我们接着往下说</p>
<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>AJAX(Asynchronous JavaScript and XML),异步的Js和XML技术，通俗点说就是通过异步编程实现网络请求数据交换等，快速实现动态网页。</p>
<h2 id="常用的ajax库"><a href="#常用的ajax库" class="headerlink" title="常用的ajax库"></a>常用的ajax库</h2><ol>
<li>jQuery: 比较重, 如果需要另外引入不建议使用</li>
<li>axios: 轻量级, 建议使用<br> 1)封装XmlHttpRequest对象的ajax<ol start="2">
<li>promise风格可以用在浏览器端和node服务</li>
</ol>
</li>
</ol>
<p>简单的看看axios的使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GET请求</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//POST请求</span></span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但这不是我们今天的重点哈，这方面的内容也可以去自行找点资料去看，我们今天的重点是:</p>
<h1 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h1><p>fetch: 原生函数，不再使用XmlHttpRequest对象提交ajax请求 且更符合关注点分离的思想</p>
<p>fetch与ajax的不同</p>
<ol>
<li>当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject， 即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</li>
<li>fetch 不会发送 cookies</li>
</ol>
<p>接下来就看看fetch的简单使用呗，</p>
<h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response.json()</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  fetch(url, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(data),</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="GitHub搜索用户案例"><a href="#GitHub搜索用户案例" class="headerlink" title="GitHub搜索用户案例"></a>GitHub搜索用户案例</h1><p>理论知识就到这了，接下来看看实际案例吧<br><img src="/2021/05/10/fetch-%E6%90%9C%E7%B4%A2%E7%94%A8%E6%88%B7/1.png" alt="1"><br>只有一个需求，就是按下搜索后开始搜索嘛</p>
<p>还是一样的先拆分组件 搜索和展示两个组件而已<br><img src="/2021/05/10/fetch-%E6%90%9C%E7%B4%A2%E7%94%A8%E6%88%B7/2.png" alt="2"></p>
<p>接下来就是写网络请求啦，这个需求只涉及到GET请求，就弄的详细点吧</p>
<h2 id="用axios"><a href="#用axios" class="headerlink" title="用axios"></a>用axios</h2><p>Search组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">search = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户的输入(连续解构赋值+重命名)</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">keyWordElement</span>: &#123; <span class="attr">value</span>: keyWord &#125; &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//发送请求前通知App更新状态</span></span><br><span class="line">    <span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isFirst</span>: <span class="literal">false</span>, <span class="attr">isLoading</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="comment">//发送网络请求</span></span><br><span class="line">    axios.get(<span class="string">`https://api.github.com/search/users?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>).then(</span><br><span class="line">        <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//请求成功后通知App更新状态</span></span><br><span class="line">            <span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">users</span>: response.data.items &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//请求失败后通知App更新状态</span></span><br><span class="line">            <span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">err</span>: error.message &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用fetch"><a href="#用fetch" class="headerlink" title="用fetch"></a>用fetch</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">search = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">       <span class="keyword">const</span>&#123;<span class="attr">keyWordElement</span>:&#123;<span class="attr">value</span>: keyWord&#125;&#125;=<span class="built_in">this</span>;</span><br><span class="line">       <span class="built_in">this</span>.props.updateAppState(&#123;<span class="attr">isFirst</span>:<span class="literal">false</span>,<span class="attr">isLoding</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">       fetch(<span class="string">`https://api.github.com/search/users?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>).then(</span><br><span class="line">           <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> response.json()<span class="comment">//返回一个pending状态的Promise()</span></span><br><span class="line">           &#125;</span><br><span class="line">       ).then(</span><br><span class="line">           <span class="function"><span class="params">data</span> =&gt;</span> &#123;<span class="built_in">this</span>.props.updateAppState(&#123;<span class="attr">isLoding</span>:<span class="literal">false</span>,<span class="attr">users</span>: data.items&#125;)&#125;</span><br><span class="line">       ).catch(</span><br><span class="line">           <span class="function"><span class="params">error</span> =&gt;</span> &#123;<span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">err</span>: error.message &#125;)&#125;</span><br><span class="line">       )</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="优化后的fetch"><a href="#优化后的fetch" class="headerlink" title="优化后的fetch"></a>优化后的fetch</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">search = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">keyWordElement</span>: &#123; <span class="attr">value</span>: keyWord &#125; &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isFirst</span>: <span class="literal">false</span>, <span class="attr">isLoading</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`https://api.github.com/search/users?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> response.json()</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        <span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">users</span>: data.items &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">err</span>: error.message &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





























]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>fetch详解</title>
    <url>/2021/06/12/fetch%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>今天详细学一下fetch的用法</p>
<span id="more"></span>

<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="分派请求和读取响应"><a href="#分派请求和读取响应" class="headerlink" title="分派请求和读取响应"></a>分派请求和读取响应</h2><p>对于fetch的用法在上一篇Blog中有了基本的了解，现在我们在深入的看一下fetch的用法。<br>都知道，fetch是异步的，是关注分离的，fetch有一个必须的参数，就是URL，利用fetch获取URL资源后会返回一个pending状态的Promise。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = fetch(<span class="string">`url`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// Promise(pending)</span></span><br></pre></td></tr></table></figure>

<p>请求URL完成且资源可用后，Promise会生成一个Response对象。这个对象是API的封装，可以通过使用这个对象的属性和方法取得相应资源。<br>用text方法可以读取response对象的纯文本格式内容。</p>
<p><code>response.text()</code></p>
<h2 id="处理状态码和请求失败"><a href="#处理状态码和请求失败" class="headerlink" title="处理状态码和请求失败"></a>处理状态码和请求失败</h2><p>我们首先要知道一点，就是fetch在接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject， 即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</p>
<p>也就是说，只有你断网了或请求错了，fetch啥东西也得不到，才会返回一个reject状态的Promise。从我自己的理解来看，fetch的意思就是取嘛，404，500 都是你访问到了，虽然取不到ok状态的response，但你好歹取到了404 500状态码和一个不知道什么鬼且ok是false的response，是吧，只要能取到东西fetch返回到Promise可以是成功的，就不会被报错。</p>
<p>所以想判断fetch请求后的具体响应状态，就要用下面这些方法了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.status() <span class="comment">//返回http状态码</span></span><br><span class="line">response.statysText() <span class="comment">// 返回状态文本 比如 200 - OK 404 - Not Found 500 - Internal Server Error</span></span><br><span class="line">response .ok() <span class="comment">// 询问请求是否成功，true 对应 200 - 299 状态码，其他都是false</span></span><br><span class="line">responese.url() <span class="comment">// 返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。</span></span><br></pre></td></tr></table></figure>

<h2 id="其余参数"><a href="#其余参数" class="headerlink" title="其余参数"></a>其余参数</h2><p>如果只传一个URL参数，则fetch会默认发送GET请求，要想进一步配置请求方式，则要传入第二个参数————一个init对象，init对象要按照下表的key/value填充<br>(具体的就去MDN上查，这里只写一些常用的)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="comment">//具体的请求方法 ，“GET”，“POST”等</span></span><br><span class="line">    headers: <span class="comment">//一个用来定制HTTP标头的对象</span></span><br><span class="line">    body: <span class="comment">//POST请求的请求体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="常见的Fetch请求模式"><a href="#常见的Fetch请求模式" class="headerlink" title="常见的Fetch请求模式"></a>常见的Fetch请求模式</h1><p>这里是一些关于init对象的配置使用</p>
<h2 id="发送JSON数据"><a href="#发送JSON数据" class="headerlink" title="发送JSON数据"></a>发送JSON数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> postData = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xyy&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fetch (<span class="string">`url`</span>),&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: postDate,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在请求体中发送参数"><a href="#在请求体中发送参数" class="headerlink" title="在请求体中发送参数"></a>在请求体中发送参数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> postData = <span class="string">&#x27;foo=bar&amp;lorem=ipsum&#x27;</span>;</span><br><span class="line"></span><br><span class="line">fetch (<span class="string">`url`</span>),&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: postDate,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/users&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="keyword">new</span> FormData(form)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>因为请求体支持FormData实现，所以fetch()就可以序列化并发送文件字段中的文件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> imageFormData = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="keyword">let</span> imageInput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;input[type=&#x27;file&#x27;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">imageFormData.append(<span class="string">&#x27;image&#x27;</span>,imageInput.file[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现多个文件:</span></span><br><span class="line"><span class="comment">// let imageInput = document.querySelector(&quot;input[type=&#x27;file&#x27;][multiple]&quot;);</span></span><br><span class="line"><span class="comment">// for(let i = 0;i &lt; imageInput.fileslength; ++i)</span></span><br><span class="line"><span class="comment">// imageFormData.append(&#x27;image&#x27;,imageInput.file[i]);</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">`url`</span>,&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: imageFormData</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>具体更高深的就自己去看MDN吧。</p>
<h1 id="其他对象"><a href="#其他对象" class="headerlink" title="其他对象"></a>其他对象</h1><h2 id="Headers对象"><a href="#Headers对象" class="headerlink" title="Headers对象"></a>Headers对象</h2><p>Response对象里面有一个headers属性，指向Header对象，Headers对象就是所有外发请求和入站响应头部的容器，每个外发的Request实例都包涵一个空的Headers实例，可以通过Request.headers访问。</p>
<ol>
<li><p>headers对象形式：<br>headers对象与Map相似，因为Http头部本质上就是序列化后的键值对，所以Headers对象有get,set,has,delete等实例方法，也有相同的keys(),values()和entries()迭代器接口,对于这些方法的运用还是去看看Map吧，这里就不详细赘述了。</p>
</li>
<li><p>headers独有的特性<br>headers初始化的时候可以直接用普通obj形式对象(也就是{}包裹的键/值对对象)，Headers对象可以由append()方法添加多个值，调用不存在的值等同于调用set(),若是用append()多次添加一个键名，则该键名对应的值以逗号为分隔符显示。</p>
</li>
<li><p>头部护卫<br>就是限制Headers对象不被修改的一些知识，自行了解。</p>
</li>
</ol>
<h1 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h1><p>顾名思义，Request对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求题的不同方式。</p>
<h2 id="创建Request对象"><a href="#创建Request对象" class="headerlink" title="创建Request对象"></a>创建Request对象</h2><p>通过构造函数初始化Request对象，为此传入一个input参数，一般是URL;</p>
<p>Request对象也接收第二个参数，一个init对象，和fetch中的第二个参数一样，不加配置的话就传入默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Request(<span class="string">`url`</span>，&#123;<span class="comment">/*一些key/value*/</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="克隆Request对象"><a href="#克隆Request对象" class="headerlink" title="克隆Request对象"></a>克隆Request对象</h2><p>除了构造函数创建Request对象外，还可以用clone()方法，</p>
<p>有两种方法可以克隆一个Request对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一.把Request实例作为input参数传给Request构造函数</span></span><br><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> Request(<span class="string">`url`</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> Request(r1); <span class="comment">// 如果传入init对象，则会覆盖。</span></span><br><span class="line"><span class="built_in">console</span>.log(r1.bodyused); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//不能克隆一摸一样的值，r1会被标记为已使用，bodyused的值为true</span></span><br><span class="line"><span class="comment">//还有一些关于referrer和mode属性的改变，具体属性可以自己去了解一下。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二.Request.clone()</span></span><br><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> Request(<span class="string">`url`</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = r1.clone() <span class="comment">//这个方法会让创建两个一摸一样的副本,bodyused的值为false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r1===r2) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果请求对象的bodyused值为true，那么就不能对该Request对象创建副本。</p>
<h2 id="在fetch-中使用Request对象"><a href="#在fetch-中使用Request对象" class="headerlink" title="在fetch()中使用Request对象"></a>在fetch()中使用Request对象</h2><p>fetch()和Request构造函数拥有相同的函数签名不是巧合，在调用fetch()的时候，可以传入已经构造好的Request实例而不是URL，和Request构造函数一样，传给fetch()的init对象会覆盖默认值。</p>
<p>关键点在于，通过fetch()使用Request实例后会把其bodyused属性设置为true，要想对同一个Request实例多次调用fetch(),必须在第一次发送fetch()请求前调用clone方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Request(<span class="string">`url`</span>);</span><br><span class="line"></span><br><span class="line">fetch(r.clone());</span><br><span class="line">fetch(r);</span><br></pre></td></tr></table></figure>


<h1 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h1><p>Response对象是获取资源响应的接口。这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式。</p>
<h2 id="创建Response对象"><a href="#创建Response对象" class="headerlink" title="创建Response对象"></a>创建Response对象</h2><p>和前面几个对象一样，可以用构造函数的方法创建Response对象，且该构造函数不需要必须参数，此时Response实例的属性均为默认值，因为它并不代表实际的HTTP响应。</p>
<p>Response构造函数接收一个可选的body参数，这个body可以是null，等同于init对象中的body，还可以接收一个可选的init对象，该init对象应有三个键值对</p>
<pre><code>    headers 必须是Headers对象实例
    status 表示HTTP的状态码
    statusText 表示HTTP响应状态的字符串
</code></pre>
<p>但大部分情况下，产生Response对象的主要方式还是调用fetch(),fetch()返回一个最终会成为Response对象的Promise实例，</p>
<p>还有两种生成Response对象的静态方法，分别是Response.redirect()和Response.error()，前者接收一个URL和一个重定向状态码，(301,302…),返回重定向的Response对象:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Response.redirect(<span class="string">`url`</span>,<span class="number">301</span>)</span><br></pre></td></tr></table></figure>
<p>后者则用于产生表示网络错误的Response对象，(网络错误会导致fetch()期约被拒绝).</p>
<p>Response对象只包含一组只读属性，描述了完成后的状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">headers: <span class="comment">//响应包含的Headers对象</span></span><br><span class="line">ok: <span class="comment">//布尔值，表示HTTP状态码的含义</span></span><br><span class="line">redirected: <span class="comment">//布尔值，表示响应是否至少经过一次定向</span></span><br><span class="line">status: <span class="comment">//整数，表示响应的HTTP状态码</span></span><br><span class="line">statusText: <span class="comment">//字符串，对HTTP状态码的描述</span></span><br><span class="line">type: <span class="comment">//字符串，包含响应类型。分为basic/cors/error/opaque/opaqueredirect</span></span><br><span class="line">url: <span class="comment">//包含响应URL的字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="克隆Response对象"><a href="#克隆Response对象" class="headerlink" title="克隆Response对象"></a>克隆Response对象</h2><p>就是使用clone()方法呀，创建一个一摸一样的副本，和Request对象的clone差不多，该方法也主要用于多次读取Response对象，Response对象是只可以读取一次的。</p>
<h2 id="Request、Response、Body的混用"><a href="#Request、Response、Body的混用" class="headerlink" title="Request、Response、Body的混用"></a>Request、Response、Body的混用</h2><p>这部分内容涉及到Body的五个方法，用于将ReadableStream转存到缓冲区的内存里，这部分也没太懂，可能是浏览器机制和HTTP没有过多了解的缘故，打算重看一遍图解HTTP，所以这部分笔记就先不写了，有空再补，</p>
<h2 id="一次性流"><a href="#一次性流" class="headerlink" title="一次性流"></a>一次性流</h2><p>因为Body混入是构建在ReadableStream之上的，所以主体流只能使用一次。这也是为什么要用clone方法的原因。</p>
<h2 id="使用ReadableStream主体"><a href="#使用ReadableStream主体" class="headerlink" title="使用ReadableStream主体"></a>使用ReadableStream主体</h2><p>这部分也后续再补吧，实在没怎么看懂….</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep react</title>
    <url>/2021/09/12/Deep-react/</url>
    <content><![CDATA[<p>《深入react技术栈》读书笔记</p>
<span id="more"></span>

<h1 id="第一章-初入react世界"><a href="#第一章-初入react世界" class="headerlink" title="第一章 初入react世界"></a>第一章 初入react世界</h1><p>这章大致的介绍了react的一些基本概念 ，以及利用一个tab栏的例子引出了state，props，ref和生命周期函数的概念。要点如下：</p>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><ul>
<li>就是react是操纵虚拟DOM的<br><img src="/2021/09/12/Deep-react/vdom.png" alt="vdom"></li>
<li>写react的编程方式是<strong>函数式编程</strong>，也就是声明式。</li>
<li>虚拟DOM其实是以JSON对象的形式存在的，直接上代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">const</span> buttonJSX = <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-blue&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">em</span>&gt;</span>Confirm<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> buttonJSON = &#123;</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                    <span class="attr">props</span>: &#123;</span><br><span class="line">                    <span class="attr">className</span>: <span class="string">&#x27;btn btn-blue&#x27;</span>, </span><br><span class="line">                    <span class="attr">children</span>: [&#123;</span><br><span class="line">                      <span class="attr">type</span>: <span class="string">&#x27;em&#x27;</span>,</span><br><span class="line">                      <span class="attr">props</span>: &#123;</span><br><span class="line">                        <span class="attr">children</span>: <span class="string">&#x27;Confirm&#x27;</span> </span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;] </span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure>
<p>其他的部分没怎么细看了 似懂非懂</p>
<h1 id="第二章-漫谈React"><a href="#第二章-漫谈React" class="headerlink" title="第二章 漫谈React"></a>第二章 漫谈React</h1><h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><p>即react中的事件都是封装好的合成事件。</p>
<ol>
<li>事件委派<br>在虚拟DOM被渲染后，react会把所有的事件处理函数绑定到结构的最外层，用一个统一的事件监听器管理，也就是说并不会直接绑定到单一的DOM节点上。这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是 在这个统一的事件监听器上插入或删除一些对象;当事件发生时，首先被这个统一的事件监听器 处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升。</li>
<li>自动绑定<br>在 React 组件中，每个方法的上下文都会指向该组件的实例，即自动绑定 this 为当前组件。 而且 React 还会对这种引用进行缓存，以达到CPU和内存的最优化。在使用 ES6 classes 或者纯函数时，这种自动绑定就不复存在了，我们需要手动实现 this 的绑定。</li>
</ol>
<p>绑定this用bind方法或者使用箭头函数(在不传参的情况下可以用::的语法代替bind(),也就是说其实bind()方法在某种意义上已经被废弃了)。<br>然后现在有了hooks后函数组件的出现率应该会大于类组件了，而在函数组件中就没必要担心this的指向问题了。<br>然后我们也可以利用ref实现原生Js的事件，但没必要，都用上react不到  万不得已绝不轻易操纵真实DOM。</p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>无非就是受控组件和非受控组件的区别，这个没啥。</p>
<h2 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h2><p>用什么 css_moudles 复杂 看不懂 过</p>
<h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><p>这个看之前的博客， 有总结过的</p>
<h2 id="组件间抽象"><a href="#组件间抽象" class="headerlink" title="组件间抽象"></a>组件间抽象</h2><ol>
<li>mixin 第一次见这个东西 难懂 没理解 先过 <strong>mixin 是一个包含可被其他类使用而无需继承的方法的类</strong>这是维基百科的定义</li>
<li>高阶组件 。。还好没深挖，react就采取高阶组件的方式代替了mixin，关于这个东西的概念C++这种面向对象的语言专业课应该会有讲</li>
</ol>
<h3 id="实现高阶组件"><a href="#实现高阶组件" class="headerlink" title="实现高阶组件"></a>实现高阶组件</h3><p>实现高阶组件的方法有两种吗，一种叫**属性代理(props proxy)<strong>。高阶组件通过被包裹的 React 组件来操作 props，还有一种是</strong>反向继承(inheritance inversion)**。高阶组件继承于被包裹的 React 组件</p>
<p>这个感觉东西有点多啊，专门写一篇博客吧。<br><img src="/2021/09/12/Deep-react/comp:png.png" alt="comp"></p>
<h2 id="组件性能优化"><a href="#组件性能优化" class="headerlink" title="组件性能优化"></a>组件性能优化</h2><p>用purerender去解决不必要的渲染，好像hooks里useEffect可以用依赖解决这个问题</p>
<h3 id="pure-Render"><a href="#pure-Render" class="headerlink" title="pure Render"></a>pure Render</h3><p>先说纯函数 老生常谈的问题了</p>
<ol>
<li>给定相同的输入，它总是返回相同的输出; </li>
<li>过程没有副作用(side effect)1;</li>
<li>没有额外的状态依赖。<br>再往下看好像真的很像useEffect的依赖</li>
</ol>
<h3 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h3><p>没看明白 不懂 用useEffect算了</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>之前有写了篇博客关于key的机制</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>就是可以用react的一些动画库写，就不用写繁琐的css了，好像有点东西，后面再深究<br>现有的动画</p>
<ul>
<li>css</li>
<li>js-svg</li>
<li>react一些动画库 smooth啥的</li>
<li>React Transition 之前有了解过，收藏夹里吃灰好久了</li>
<li>react-motion</li>
<li>cubic-bezier （上面这两条都有关于缓动动画）</li>
</ul>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>这…..还没上线过项目，测试啥的歇会儿吧</p>
<p>然后用了一堆库对第一章的tab优化了我？？？？？？？<br>人傻了  代码歇会儿放吧</p>
<p>后面就是看源码的部分了 难之</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>git的用法</title>
    <url>/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>git 的笔记</p>
<span id="more"></span>
<p>git 管理的是修改<br>工作区里面有个不可见的.git文件， 是这一项目的版本库，版本库里有缓存区和分支</p>
<p>git add 添加文件到缓存区<br>git commit -m “” 把添加到缓存区到文件全部提交到master分支<br>git push 把提交到文件推送到远程仓库<br>git status 查看仓库状态<br>git diff 文件 查看该文件的修改<br>git log 查看修改日志<br>git checkout – [file] 把文件在工作区(就是目录or在编辑器里面)做的修改全部撤销<br>git reset HEAD [file] 当做了某修改并且 git add 后使用撤销</p>
<ul>
<li><p>git恢复版本(作出修改并git commit 后修改的方法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用git commit 多次提交不同版本</span><br><span class="line"></span><br><span class="line">git log --pretty=oneline 简要查看日志</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD^ 恢复到上一个版本 三个以上用 HEAD～3 (HEAD表示当前版本)</span><br><span class="line"></span><br><span class="line">git reset --hard commit Id  恢复到指定版本号</span><br><span class="line"></span><br><span class="line">git reflog </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>在工作区删文件</p>
<p>  git rm [file] 在版本库里删除文件<br>  git checkout – [file] </p>
</li>
</ul>
<h1 id="关于分支"><a href="#关于分支" class="headerlink" title="关于分支"></a>关于分支</h1><p>我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：<br><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/0.png"><br>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。</p>
<p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/l.png"><br>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/l-1.png"></p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>
<p><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/0-1.png"></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p>
<p><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/0-2.png"></p>
<ul>
<li><p>实战代码</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先，我们创建dev分支，然后切换到dev分支：</span><br><span class="line">git checkout -c dev</span><br><span class="line"></span><br><span class="line">git switch命令加上-b参数表示创建并切换，相当于以下两条命令：</span><br><span class="line">git branch dev</span><br><span class="line">git switch dev</span><br><span class="line"></span><br><span class="line">然后，用git branch命令查看当前分支：</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">git branch命令会列出所有分支，当前分支前面会标一个*号。</span><br><span class="line"></span><br><span class="line">然后，我们就可以在dev分支上正常提交</span><br><span class="line"></span><br><span class="line">dev分支的工作完成，我们就可以切换回master分支</span><br><span class="line">git switch master</span><br><span class="line"></span><br><span class="line">我们把dev分支的工作成果合并到master分支上：</span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line">删除dev分支</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用git log –graph命令可以看到分支合并图</p>
<p><code> git log --graph --pretty=oneline --abbrev-commit</code></p>
<ul>
<li>分支策略:</li>
</ul>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/0-3.png"></p>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<p> <code>git stash</code> 把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p>
<p> 场景：出现了一个Bug，但当前分支的工作还未完成提交，却必须马上修复bug,此时就用该命令</p>
<p><code>git stash list</code> 查看隐藏的现场<br><code>git stash pop</code> 恢复工作现场<br><code>git cherry-pic &lt;commmit&gt;</code> 让我们能复制一个特定的提交到当前分支(多个分支修改同一个Bug，即在某一个分支修改完成后直接用该命令复制给其他人)</p>
<ul>
<li><p>feature分支用于开发某一项新需求， issue-n 分支用于改bug</p>
</li>
<li><p><code>git push origin &lt;branch&gt;</code> 推送分支</p>
</li>
</ul>
<p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>
<p>要查看远程库的信息，用<code>git remote -v</code></p>
<p>多人协作的工作模式通常是这样：</p>
<p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p>
<p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p>
<p>如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p>
<p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p><code>git rebase</code> 可以把本地未push的分叉提交历史整理成直线,目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
<h1 id="关于标签"><a href="#关于标签" class="headerlink" title="关于标签"></a>关于标签</h1><p>标签就是某个版本的快照 和某个commit绑定在一起<br><code>git tag &lt;name&gt;</code> 制作标签</p>
<p><code>git tag</code> 查看所有标签</p>
<p>标签默认打在当前版本号上，如果想要打到以前的版本上，找到之前版本的commit id <code>git tag &lt;name&gt; &lt;commit id&gt;</code></p>
<p><code>git show &lt;tagname&gt;</code> 查看详细的标签信息</p>
<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：<br><code>git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</code></p>
<p><code>git tag -d v0.1</code> 删除标签</p>
<p><code>git push origin &lt;tagname</code> 推送某个标签到远程仓库</p>
<p><code>git push origin --tags</code> 一次性推送</p>
<p>从远程删除标签</p>
<ol>
<li>先本地删除 <code> git tag -d v0.9</code></li>
<li>再远程删除 命令也是push <code>git push origin :refs/tags/v0.9</code></li>
</ol>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>iterm2</title>
    <url>/2021/06/09/iterm2/</url>
    <content><![CDATA[<p>关于自己Mac电脑的iterm2终端美化配置方案</p>
<span id="more"></span>

<p><img src="/2021/06/09/iterm2/2.png" alt="2"></p>
<h1 id="oh-my-zsh-安装"><a href="#oh-my-zsh-安装" class="headerlink" title="oh-my-zsh 安装"></a>oh-my-zsh 安装</h1><p>一个美化要用的东西，iterm2就直接App store下载就行了</p>
<p>先切换命令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<p>再安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>

<p>安装失败就先git clone</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br></pre></td></tr></table></figure>

<p>再替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>这样就好啦</p>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>命令高量 代码补全 和一个jump 文件夹<br>前两个不咋用 最后一个好用<br>先安装brew 然后</p>
<p><code>brew install autojump</code></p>
<p>然后编辑 vim ~/.zshrc 文件, 找到 plugins 配置, 增加 autojump 插件.</p>
<h1 id="窗口外观"><a href="#窗口外观" class="headerlink" title="窗口外观"></a>窗口外观</h1><p>就是下拉式嘛 看下面这些就好咯<br><a href="https://www.bilibili.com/read/cv8638110/">链接</a><br>配色 rgb(133,73,71)<br>字体 Andale Moto</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>muxi-workbench总结</title>
    <url>/2021/10/18/muxi-workbench%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>interface和type</title>
    <url>/2021/09/11/interface%E5%92%8Ctype/</url>
    <content><![CDATA[<p>学了ts有段时间了 type跟interface的区别一直处于一个懵懂的状态，感觉很多地方他俩可以互相代替，和react联系起来后对于prop和state的定义上是用type或interface也有不明确的地方，所以写一篇博客谈谈理解和想法。</p>
<span id="more"></span>

<h1 id="简单定义"><a href="#简单定义" class="headerlink" title="简单定义"></a>简单定义</h1><p>在说区别前我们先了解一下什么是 interface 和 type</p>
<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p><strong>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</strong></p>
<p>大致意思就是用来规范对象 ｜ 类 的，对象和类需要满足接口所定义的属性， 接口可以被extend(继承)和implementing(实现)</p>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>type(类型别名)就是用来自定义类型的，什么联合类型交叉类型字面量类型等等，本质上说type其实是给你自定义类型重新取一个可读的名字<br>交叉类型(&amp;)可以实现和extend差不多的效果</p>
<h1 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h1><p>翻了好多博客和官方文档 得到这样一句话<br><strong>“type aliases can act sort of like interfaces, however, there are some subtle differences.”</strong><br>和开头说的差不多，type在很多地方可以替代interface，但还是有一些差别。</p>
<h2 id="是否创建新的变量名"><a href="#是否创建新的变量名" class="headerlink" title="是否创建新的变量名"></a>是否创建新的变量名</h2><p>官网中提到的第一处不同是“One difference is, that interfaces create a new name that is used everywhere. Type aliases don’t create a new name — for instance, error messages won’t use the alias name.”<br>这其实是不对的，在编译器中尝试会发现报错信息是一致的<br>比如</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> PointInterface &#123;</span><br><span class="line">   <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">   <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> PointType = &#123;</span><br><span class="line">   <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">   <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> getSquareI = <span class="function">(<span class="params">args: PointInterface</span>) =&gt;</span> args.x * args.y</span><br><span class="line"> <span class="keyword">const</span> getSquareT = <span class="function">(<span class="params">args: PointType</span>) =&gt;</span> args.x * args.y</span><br><span class="line"></span><br><span class="line"> <span class="comment">// error: 类型&#123;x: number&#125;不能赋值给squareI/T 类型的参数，因为缺少了 &#123;y: number&#125;属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关于extend-和-implemented"><a href="#关于extend-和-implemented" class="headerlink" title="关于extend 和 implemented"></a>关于extend 和 implemented</h2><p>第二处不同<br><strong>“A second more important difference is that type aliases cannot be extended or implemented from”</strong><br>Mad！！！这也是错的！！！ 直接看代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> TreeDimeions <span class="keyword">extends</span> PointType &#123;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Rectangele</span> <span class="title">implements</span> <span class="title">PointType</span> </span>&#123;</span><br><span class="line">    x= <span class="number">2</span></span><br><span class="line">    y= <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">RectangPrism</span> <span class="title">implements</span> <span class="title">TreeDimeions</span> </span>&#123;</span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    y = <span class="number">3</span></span><br><span class="line">    z = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 也可以通过type和interface实现对类的约束</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    area(): <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">type</span> Perimeter = &#123;</span><br><span class="line">    perimeter(): <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="title">implements</span> <span class="title">PointType</span>, <span class="title">Shape</span>, <span class="title">Perimeter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    y = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    area () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.x * <span class="built_in">this</span>.y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">perimeter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">this</span>.x + <span class="built_in">this</span>.y)*<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="type不能对其他type-extend和implement"><a href="#type不能对其他type-extend和implement" class="headerlink" title="type不能对其他type extend和implement"></a>type不能对其他type extend和implement</h2><p>第三处不同说<br><strong>“type aliases cannot extend/implement other types”</strong><br>这句话也不对，但不说完全不对，只能说部分正确</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  area(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Perimeter = &#123;</span><br><span class="line">  perimeter(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 &amp; 实现 extend</span></span><br><span class="line"><span class="keyword">type</span> RectangleShape = Shape &amp; Perimeter &amp; Point</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="title">implements</span> <span class="title">RectangleShape</span> <span class="title">Perimeter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    y = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    area () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.x * <span class="built_in">this</span>.y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">perimeter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">this</span>.x + <span class="built_in">this</span>.y)*<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现映射类型</span></span><br><span class="line"><span class="keyword">type</span> RectangleShape2 = Partial&lt;Shape &amp; Perimeter&gt; &amp; Point</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartialRectangle</span> <span class="title">implements</span> <span class="title">RectangleShape2</span> </span>&#123;</span><br><span class="line">  x = <span class="number">2</span></span><br><span class="line">  y = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二者区别-真"><a href="#二者区别-真" class="headerlink" title="二者区别 真"></a>二者区别 真</h1><p>叭叭了这么多，所以二者的区别到底在哪儿呢</p>
<ol>
<li><p><strong>you cannot use implements on an class with type alias if you use union operator within your type definition</strong><br>翻译就如果一个type是联合类型，那我就不能用类去实现他了<br><img src="/2021/09/11/interface%E5%92%8Ctype/1.gif" alt="gif"></p>
</li>
<li><p><strong>you cannot use extends on an interface with type alias if you use union operator within your type definition</strong><br>差不多意思，一个type是联合类型，接口就不能继承了</p>
</li>
</ol>
<p>这里那篇博客的解释是，类和接口都是一个 ***“blueprint” ***<br>所以他们不能实现和继承在 <em><strong>one or another shape</strong></em> 我英语太废物了完全不懂是什么意思啊赣了</p>
<ol start="3">
<li><strong>declaration merging doesn’t work with type alias</strong><br>type不能合并声明，这个很多博客都提到了，没啥多说的<br><img src="/2021/09/11/interface%E5%92%8Ctype/2.png" alt="png"><br>因为type是一个unique type entity，无论是在全局变量还是module scope中</li>
</ol>
<p>而在react中<br>always use interface for public API’s definition when authoring a library or 3rd party ambient type definitions<br>consider using type for your React Component Props and State</p>
<p>对于props和state还是用type吧， 然后interface用于公共的API和第三方库的实现<br>就是这样 具体区别可能要看看定义interface和type的源码来了解了</p>
<p><a href="https://medium.com/@martin_hotell/interface-vs-type-alias-in-typescript-2-7-2a8f1777af4c">参考链接</a></p>
<p><img src="/2021/09/11/interface%E5%92%8Ctype/3.png" alt="dif"></p>
<p>！在看深入react技术栈的时候看到一点:<br><strong>包括 C++ 等一些年龄较大的 OOP 语言， 它们都有一个强大但危险的多重继承特性。现代语言为了权衡利弊，大都舍弃了多重继承，只采用单继承，但单继承在实现抽象时有诸多不便之处。为了弥补缺失，Java 引入了接口(interface)， 其他一些语言则引入了像 mixin 的技巧，方法虽然不同，但都是为创造一种类似多重继承的效果， 事实上说它是组合更为贴切。</strong><br>结合Java来看，interface其实是更像抽象类的，所以用interface去规范类或许是更好的选择</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>react源码初探</title>
    <url>/2021/09/15/react%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>总算到这一步了 看react源码部分的笔记</p>
<span id="more"></span>

<h1 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h1><p>Virtual DOM 是 React 的核心与精髓所在,React就是靠着VDOM和高效的diff算法大量减少了渲染DOM的代价。<br>VDOM中转换成浏览器中真实的DOM树，即VDOM其实也存在于树这种数据结构中，那他就会有自己的节点，他的节点被称为 ReactNode， 分为3种类型 ReactElement、ReactFragment 和ReactText，其中，ReactElement 又分为 ReactComponentElement 和 ReactDOMElement。<br>先看看这些类型源码，涉及到Ts部分、</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReactNode = ReactElement | ReactFragment | ReactText;</span><br><span class="line"><span class="keyword">type</span> ReactElement = ReactComponentElement | ReactDOMElement;</span><br><span class="line"><span class="keyword">type</span> ReactDOMElement = &#123; <span class="attr">type</span> : <span class="built_in">string</span>,</span><br><span class="line"><span class="attr">props</span> : &#123;</span><br><span class="line"><span class="attr">children</span> : ReactNodeList, <span class="attr">className</span> : <span class="built_in">string</span>,</span><br><span class="line">etc.</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">key</span> : <span class="built_in">string</span> | <span class="built_in">boolean</span> | <span class="built_in">number</span> | <span class="literal">null</span>, <span class="attr">ref</span> : <span class="built_in">string</span> | <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> ReactComponentElement&lt;TProps&gt; = &#123; <span class="attr">type</span> : ReactClass&lt;TProps&gt;,</span><br><span class="line">props : TProps,</span><br><span class="line"><span class="attr">key</span> : <span class="built_in">string</span> | <span class="built_in">boolean</span> | <span class="built_in">number</span> | <span class="literal">null</span>, <span class="attr">ref</span> : <span class="built_in">string</span> | <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> ReactFragment = <span class="built_in">Array</span>&lt;ReactNode | ReactEmpty&gt;; <span class="keyword">type</span> ReactNodeList = ReactNode | ReactEmpty;</span><br><span class="line"><span class="keyword">type</span> ReactText = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> ReactEmpty = <span class="literal">null</span> | <span class="literal">undefined</span> | <span class="built_in">boolean</span>;</span><br></pre></td></tr></table></figure>
<p>然后我们写JSX的时候，react会帮我吗掉createElement方法构造虚拟节点，这是个蛮重要的部分，直接上代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// createElement 只是做了简单的参数修正，返回一个 ReactElement 实例对象， // 也就是虚拟元素的实例</span></span><br><span class="line">ReactElement.createElement = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">type</span>, config, children</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 初始化参数</span></span><br><span class="line"><span class="keyword">var</span> propName;</span><br><span class="line"><span class="keyword">var</span> props = &#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> key = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">var</span> ref = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">var</span> self = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">var</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在 config，则提取里面的内容 if (config != null) &#123;</span></span><br><span class="line"><span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">  ref = config.ref === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.ref;</span><br><span class="line">  key = config.key === <span class="literal">undefined</span> ? <span class="literal">null</span> : <span class="string">&#x27;&#x27;</span> + config.key;</span><br><span class="line">  self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self; </span><br><span class="line">  source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source; </span><br><span class="line"><span class="comment">// 复制 config 里的内容到 props(如 id 和 className 等)</span></span><br><span class="line">  <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.hasOwnProperty(propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class="line">      props[propName] = config[propName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 children，全部挂载到 props 的 children 属性上。如果只有一个参数，直接赋值给 children， // 否则做合并处理</span></span><br><span class="line"><span class="keyword">var</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">  props.children = children;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> childArray = <span class="built_in">Array</span>(childrenLength); </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">    childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>]; </span><br><span class="line">  &#125;</span><br><span class="line">  props.children = childArray; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果某个 prop 为空且存在默认的 prop，则将默认 prop 赋给当前的 prop </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">type</span> &amp;&amp; <span class="keyword">type</span>.defaultProps) &#123;</span><br><span class="line">  <span class="keyword">var</span> defaultProps = <span class="keyword">type</span>.defaultProps;</span><br><span class="line">  <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> props[propName] === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">       props[propName] = defaultProps[propName];</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回一个 ReactElement 实例对象</span></span><br><span class="line"><span class="keyword">return</span> ReactElement(<span class="keyword">type</span>, key, ref, self, source, ReactCurrentOwner.current, props); &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><p>Virtual DOM 模型通过 createElement 创建虚拟元素，那又是如何创建组件的呢?</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react2</title>
    <url>/2021/06/24/react2/</url>
    <content><![CDATA[<p>看 三天精通react/ React学习手册 / the-road-to-learn-react / 读后感</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个问题</span><br><span class="line">setstate的同步异步问题</span><br><span class="line">setstate的调用生命周期问题</span><br></pre></td></tr></table></figure>

<p>《三天精通react》</p>
<h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><p>先明白什么是组件<br>这里书上和木犀101都给出了一个类似的概念<br><strong>UI=f(x)</strong><br>即每一个组件就是一个纯函数，不过这个纯函数的返回值是UI结构，函数里面的x就是用于驱动UI更新的数据，这种通过数据驱动 UI 变化的方式，叫<strong>声明式编程</strong>，而直接对UI操作的叫命令行编程，比如原生DOM，声明式在思维上是更高级的编程范式。</p>
<p>无状态组件就是没state，所有的数据通过props接收，这里有个写法就是css当作变量而不是写在css文件里面</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  props: React.PropsWithChildren&lt;&#123; color?: string; onClick?: () =&gt; <span class="keyword">void</span> &#125;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; color, children, onClick &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> style = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>: color,</span><br><span class="line">    <span class="attr">border</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="attr">padding</span>: <span class="string">&quot;4px 6px&quot;</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;white&quot;</span>,</span><br><span class="line">    <span class="attr">cursor</span>: <span class="string">&quot;pointer&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;children&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有状态组件 就是带着state的组件，Hooks里面就用usestate(),具体用法也都知道，但切记不要写在生命周期函数里面，比如ComponentDidUpdate(),这样会导致无限重绘，页面假死。</p>
<p>即setstate()函数用于驱动页面更新，但UI更新总是有原因的</p>
<ul>
<li>⽤⼾触发的交互，如：键盘输⼊、⿏标点击、屏幕滑动等</li>
<li>定时器的触发，如： setTimeout 、 requestAnimationFrame 、 setInterval</li>
<li>IO 事件回调触发，如：AJAX 请求返回的回调</li>
</ul>
<p>总结就是， setCount 操作必须在某个回调中调⽤，不应该出现在生命周期函数的同步调⽤栈中执⾏。</p>
<p>useState()接收的参数是state的初始值，但在下列情况下需要接收函数作为参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始状态需要复杂计算</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> initialCount = props.data.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="function">() =&gt;</span> props.data.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始状态是复杂对象</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> [initialState, setState] = useState(&#123;</span><br><span class="line"><span class="attr">attr1</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line"><span class="attr">attr2</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="attr">attr50</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [initialState, setState] = useState(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line"><span class="attr">attr1</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line"><span class="attr">attr2</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="attr">attr50</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>传函数的好处是，当依赖 state ⾃⾝最新状态来更新状态时，不需要访问外部变量</p>
<h1 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h1><p>当需要存放⼀个数据，需要⽆论在哪⾥都取到最新状态时，需要使⽤ useRef。（实际开发少用，影响效率）</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/09/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>本篇博客简单介绍一下二分查找算法及其框架</p>
<span id="more"></span>

<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找的思路其实很简单，无非就是一堆数据过来，你就不断分分分分分，就能把一堆数据分成仅剩一个，但细节真的很多，一个不注意就会漏掉数据，这里我们利用二分查找的一个固定框架来简单的介绍一下这些细节问题。<br>先直接上代码框架</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> binarySearch = <span class="function">(<span class="params">nums,target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>); <span class="comment">// 防止left + right 太大导致计算溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ...; &#125;</span><br></pre></td></tr></table></figure>
<p>记住，写二分查找千万不能偷懒直接写else，要用else if 写明每一个情况。当然十分自信的话用else来简化代码也不是不可以,然后利用这个框架，我们写一个最简单的查找数组里面的元素。代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> binarySearch = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后注意几点， while 里面是 &lt;= ,因为这里初始化right是length -1，表示数组最后一个值的索引，所以可以取等号，直接就是二分查找需要考虑的一个重点问题 **边界问题**<br>这就看具体题型了，因为这题属于是闭区间【】，数组的头和尾都有可能是查找的值，取等号是没问题的，有些左闭右开区间 【 ）就要考虑是否该用&lt;来代替&lt;=了。这里我们再说一下终止条件和搜索区间的联系。<br>当while取 &lt;= 时，终止条件是 left &gt; right, 大概就是让你在[3,2]中找一个值，这根本不可能找到对吧，然后 &lt; 的终止条件是left == right情况就是在(2,2)中找，也找不到，因为是开区间取不到2。</p>
<p>再然后，为什么left和right要是mid + 1/ - 1。 还是从搜索区间来看吗，当我们发现mid不是我们要找的值，那mid是不是就不用找了？那搜索区间就理所应当的是[mid + 1,right],[left,mid - 1]。<br>至此二分查找应该可以有个基本的理解了，但这个框架有缺陷，比如给个有序数组 nums = [1,2,2,2,3]，想找2，确实能找到，但是只能找到最中间的2，左右两边2是不可能查的到的，哎，这就很烦。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>todolist-hooks</title>
    <url>/2021/05/09/todolist-hooks/</url>
    <content><![CDATA[<p>用hooks写了份todolist，刚好就借这份project写出一些hooks的使用方法</p>
<span id="more"></span>
<h1 id="hooks基本语法介绍"><a href="#hooks基本语法介绍" class="headerlink" title="hooks基本语法介绍"></a>hooks基本语法介绍</h1><h2 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作</span><br><span class="line">(2). 语法: const [xxx, setXxx] = React.useState(initValue)  </span><br><span class="line">(3). useState()说明:</span><br><span class="line">        参数: 第一次初始化指定的值在内部作缓存</span><br><span class="line">        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数</span><br><span class="line">(4). setXxx()2种写法:</span><br><span class="line">        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值</span><br><span class="line">        setXxx(value =&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</span><br></pre></td></tr></table></figure>



<h2 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h2><pre><code>    (1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)
    (2). React中的副作用操作:
            发ajax请求数据获取
            设置订阅 / 启动定时器
            手动更改真实DOM
    (3). 语法和说明: 
            useEffect(() =&gt; &#123; 
            // 在此可以执行任何带副作用操作
            return () =&gt; &#123; // 在组件卸载前执行
                // 在此做一些收尾工作, 比如清除定时器/取消订阅等
            &#125;
            &#125;, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行
            第二个参数限制了调用这个hooks的范围，则就会只有在statevalue发生改变时调用这个hook
        
    (4). 可以把 useEffect Hook 看做如下三个函数的组合
            componentDidMount()
            componentDidUpdate()
            componentWillUnmount() 
</code></pre>
<h2 id="Ref-Hook"><a href="#Ref-Hook" class="headerlink" title="Ref Hook"></a>Ref Hook</h2><pre><code>    (1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据
    (2). 语法: const refContainer = useRef()
    (3). 作用:保存标签对象,功能与React.createRef()一样
</code></pre>
<h2 id="自定义Hook与其他Hooks-API"><a href="#自定义Hook与其他Hooks-API" class="headerlink" title="自定义Hook与其他Hooks API"></a>自定义Hook与其他Hooks API</h2><p>这部分内容比较多，详情右边搜索关于hooks的详细博客，这里就先介绍最基础的三个。</p>
<h1 id="Todolist"><a href="#Todolist" class="headerlink" title="Todolist"></a>Todolist</h1><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>了解了hooks的基本语法，我们就正式开始写这份todolist的project吧。<br>先看项目的基本UI<br><img src="/2021/05/09/todolist-hooks/todolist.png" alt="td"><br>这算是比较基本的UI了，我们就从上往下拆分组件，可以拆解为<br>                1. 头部部分的输入框:Input 这可以包括标题的Todo，因为只是基本的样式没有交互效果，可以简单的与Input放在一起，叫他header组件也没什么问题<br>                2. 容器组件：List<br>                        3. List组件中的Item组件，这份todo就是个列表嘛，那必然就可以分类列表的容器组件和负责展示的Item组件<br>                4.尾部组件：Filter 其实叫他Footer组件也行，但他有三种不同的筛选状态，就叫他Filter吧</p>
<p>组件拆解完毕后，其中的html放在render（）/return（）里， css就作为文件放在对应的文件夹中，结构如图<br><img src="/2021/05/09/todolist-hooks/components.png" alt="cp">  </p>
<p><strong>这里的css样式文件我就没有拆了，因为是直接拿来的文件，不太分得清从哪开始拆，也没注释，实际自己写的时候一定要拆的</strong></p>
<h1 id="组件通信方式总结"><a href="#组件通信方式总结" class="headerlink" title="组件通信方式总结"></a>组件通信方式总结</h1><p>写完静态页面后就根据需求加交互效果呗，这里就会涉及到react组件之间如何传递数据，下面是一些总结</p>
<h2 id="组件间的关系："><a href="#组件间的关系：" class="headerlink" title="组件间的关系："></a>组件间的关系：</h2><ul>
<li>父子组件</li>
<li>兄弟组件（非嵌套组件）</li>
<li>祖孙组件（跨级组件）</li>
</ul>
<h2 id="几种通信方式："><a href="#几种通信方式：" class="headerlink" title="几种通信方式："></a>几种通信方式：</h2><pre><code>    1.props：
        (1).children props
        (2).render props
    2.消息订阅-发布：
        pubs-sub、event等等
    3.集中式管理：
        redux、dva等等
    4.conText:
        生产者-消费者模式
</code></pre>
<h2 id="比较好的搭配方式："><a href="#比较好的搭配方式：" class="headerlink" title="比较好的搭配方式："></a>比较好的搭配方式：</h2><pre><code>    父子组件：props
    兄弟组件：消息订阅-发布、集中式管理
    祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)
</code></pre>
<p>因为todolist算是比较简单的，我们就拿<strong>状态提升</strong>来写。</p>
<h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>就是把一些可以共享state的组件们的state提到他们共同的父组件中去，简单来说，这份数据你也要我也要他也要，但是我们一人写一份就很麻烦，不如把state交给一个老父亲，让他按需求发给我们就好了。<br>所以我们就在App组件中定义state,todos都知道是个列表嘛，我们就把todos看成一个对象数组，每个todo</p>
<pre><code>            const[todos,setTodos] = useState([])
</code></pre>
<p>初始化好后就用props把todos传下去呗，这样每个自组件都能共享这个state了</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>接下来开始写第一个功能，按照组件顺序自然就从Input开始。</p>
<h3 id="增加一个todo列表"><a href="#增加一个todo列表" class="headerlink" title="增加一个todo列表"></a>增加一个todo列表</h3><p>我们给这个事件函数命名为handleAdd(),组件内的函数一般都命名为handleXx<br>无非就是按下回车后给todo这个空数组添加一个元素todo对象呗<br>先给输入框绑定键盘事件</p>
<pre><code>            &lt;input onKeyUp=&#123;handleAdd&#125;&gt; //onKeyUp就是键盘按下后弹起就会触发
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleAdd</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; keyCode, target &#125; = e</span><br><span class="line">      <span class="keyword">if</span> (keyCode !== <span class="number">13</span>) <span class="keyword">return</span> <span class="comment">//判断是否为回车</span></span><br><span class="line">      <span class="keyword">const</span> todoObj = &#123; <span class="attr">id</span>: nanoid(), <span class="attr">content</span>: target.value, <span class="attr">completed</span>: <span class="literal">false</span>, <span class="attr">flag</span>: <span class="literal">true</span>, <span class="attr">editing</span>: <span class="literal">false</span> &#125; <span class="comment">//nanoid用于唯一生成唯一id，安装后引入就行，其他的属性是根据需求来添加的</span></span><br><span class="line">      props.addTodo(todoObj) <span class="comment">//因为state在App中，所以调用App中的方法来进行更新</span></span><br><span class="line">      target.value = <span class="string">&#x27;&#x27;</span>  <span class="comment">//清空输入框</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如上行所示，虽然你通过props接受到了state，可想要更新state，还得回App中，因为state在哪儿，操作state的方法就在哪儿 所以就得来个回调嘛<br>addTodo的具体函数如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">todoObj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> newTodos = [todoObj, ...todos]<span class="comment">// 注明一下为什么用扩展运算符而不用数组的push方法添加元素对象，因为push方法不是纯函数，他产生的新数组和原数组的指针指向不是同一个地址，可能回产生一些不必要的bug，所以就一般不用这些方法。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>关于纯函数以及函数的副作用等也可以右边搜索相关的详细解析博客啦</p>
<h3 id="完成所有todo"><a href="#完成所有todo" class="headerlink" title="完成所有todo"></a>完成所有todo</h3><p>这就是Input组件的第二个需求，也很简单，先handleCompleteAll调用App内相对应的方法，再用数组的map方法让每一个todo对象的completed属性变成true就可以了</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>这个组件没什么好说的，就是一个容器组件，把相应的state和方法用props传给Item就行<br>不过还是有一个需要注意的点，就是之前说过List其实可以看作是一个数组，Item是里面的元素，所以每一个Item都应该由map方法展示，代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &#123;todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Item</span>/&gt;</span></span>)&#125;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h2><p>这个需求就比较多啦<br>编辑 删除 完成<br>还有随着state的改变样式也跟着等等<br>不过具体思路还是和上面一样，也就不赘述啦</p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>对于需求方法也没什么好说的，还是同上<br>不过要注意一点，实现排他思想的tab栏切换<br>思路就是，把id放在state里面，每次点击一个tab栏的时候，就会传入自己的id变成state，这样只有自己的id和state吻合的时候才会实现单个tab选项卡高亮的效果</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>上面就是关于这个小项目的总结啦，好说这也是自己写的第一个react项目，也花了一些时间，写一篇博客记录下来，算是加强理解吧</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>初探动态规划/回溯</title>
    <url>/2021/09/15/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>数据结构上刷算法… 好说歹说算是入门了</p>
<span id="more"></span>

<h1 id="何为动态规划"><a href="#何为动态规划" class="headerlink" title="何为动态规划"></a>何为动态规划</h1><p>怎么说呢，动态规划就是是一种分治的思想，换句话说，就是把一个大问题，拆分成小问题，再把小问题接着拆分，拆到无可再分的时候，会得到最小的子问题，而子问题的答案很轻松就能得到，根据这个答案递推回去，就能得到原本问题的答案，是一种自底而上的做法。（当然也有自顶而下的方法）。动态规划核心套路是“穷举求最优解”，然后利用状态转移方程进行<strong>正确的穷举</strong>，也就是取消重叠子问题。<br>即，动态规划分治穷举后，两个重要特性就是 <strong>重叠子问题</strong>和<strong>最优子结构</strong></p>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p>刚刚提到一个核心的概念，就是状态转移方程，这是做动态规划类问题最重要的一个步骤，也是最抽象的一个步骤，我们能想到状态转移方程就代表这道题我们理解了大半了，我们由斐波那契数列入手来引出这个概念。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span> (<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单吧，直接暴力递归，但是贼低效，鲁迅说过“所有递归问题都可以看作是树问题”，那我们就看看这个递归调用时的树，假设i = 20;<br><img src="/2021/09/15/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/fib.png" alt="fib"><br>看看时间复杂度？O(2^n)，直接裂开来，而且你会发现有大量的重复计算，比如f(18)和f(17)都被计算了两次，更往下的子节点被重复计算的次数更多，这就是之前提到的<strong>重叠子问题</strong>，所以为了解决这个问题，我们引入一个备忘录。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span> (<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">  dp[<span class="number">1</span>] = dp [<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] +  dp[i - <span class="number">2</span>]</span><br><span class="line">  <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这我们可以得知，我们知道这是第n代的兔子，让我们去求第n代兔子的总数，也就是dp(n),并且dp(n) = dp(n-1) + dp(n-2)，哎，那求dp(n)的问题是不是就转移到求dp(n-1) + dp(n-2)了，这个就叫状态转移方程，当然不要忘了n = 1 和n = 2的情况。综上，我们得到斐波那契数列的状态转移方程</p>
<p>dp(n) = { 1,  n = 1,2<br>{dp(n-1) + dp(n-2), n &gt; 2</p>
<p>这里解决了<strong>重叠子问题</strong>，那动态规划另一个重要特性<strong>最优子结构</strong>呢？<br>因为斐波那契不算真正的动态规划问题，写这个主要是为了引入如何抽象出状态转移方程，对于最优子结构，让我们往下看。</p>
<h2 id="典中典的凑硬币"><a href="#典中典的凑硬币" class="headerlink" title="典中典的凑硬币"></a>典中典的凑硬币</h2><p>说起动态规划就不得不提凑硬币的问题，太经典了属于是。再说凑硬币问题前我们简单聊一聊贪心算法，贪心算法其实是动态规划的一个特例，动态规划是一只分分分分分到最后找出最优解，而贪心是先分解若干个子问题，找出最优，再从这个最优子问题中接着分解，也就是说<strong>贪心算法是每一都要求出最优解的动态规划问题</strong>。<br>这里说回来凑硬币问题，比如我们有面值为1，5，11元的硬币，要求凑出15元所用的最少硬币数。用贪心的话就是，第一步的最优解肯定是面值最大的11元，然后还差四元就需要用四枚一元硬币，一共五枚。而这道题真正的最优解其实是三枚五元硬币，这样就能看出贪心和动态规划的区别了。<br>那么这道题我们该如何思考呢？又或者是说怎么列出状态转移方程？仔细思考一下，我们之前有提到过动态分解到最小子问题后往上递归，也就是“自低而上”的思维，那这个问题的最底部显然就是0个硬币凑0元，再往上也就是一个硬币， 也就是凑了1，5，11元还剩14，10，4元，分别需要 dp[14]+1,dp[10]+1,dp[4]+1个，（这里dp[n]是凑n元需要的硬币数，这里因为要求最少硬币数，所以需要在dp[14],dp[10],dp[1]中找出最优的情况，所以底层往上的第一步，就是<br>dp[15] = min(dp[15-1],dp[15-5],dp[15-10])+1,这里15由未知数代替，考虑边界情况，也就是n&lt;=0的情况，那我们不就能得到状态转移方程了？<br>dp[n] = { 0 ,n&lt;=0<br>{min(dp[15 - coin]), n&gt;0<br>得到状态转移方程，再用自底而上的思维，得出代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> changeCoin = <span class="function">(<span class="params">coins,amount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化备忘录,用Infinity填满备忘录，Infinity说明该值不可以用硬币凑出来</span></span><br><span class="line">  <span class="keyword">let</span> dp = newArray(amount + <span class="number">1</span>).fill(<span class="literal">Infinity</span>)</span><br><span class="line">  dp[<span class="number">0</span>] = [<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> coin <span class="keyword">of</span> coins)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coin &lt;= i)</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - coin] + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[amount] === <span class="literal">Infinity</span> ? -<span class="number">1</span> : dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就结束啦！<br>那么最后，怎样判断一个问题是不是动态规划问题呢？<br>一般有</p>
<ul>
<li>求最大值，最小值</li>
<li>判断方案是否可行</li>
<li>统计方案个数</li>
<li>子问题是否满足最优子结构，即每个子问题都不影响其他子问题</li>
</ul>
<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>看完动态规划，我们就简单说一下回溯，回溯重点就是这个“回”字，他从本质上来说就是遍历决策树的过程，我们需要抓住这三点：</p>
<ul>
<li>路径 也就是做过的选择</li>
<li>选择列表 当前可以选择的部分</li>
<li>结束条件 到达决策树底部，没有新的选择</li>
</ul>
<p>回溯是有框架的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表): <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">result.add(路径) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表: 做选择</span><br><span class="line">backtrack(路径, 选择列表) 撤销选择</span><br></pre></td></tr></table></figure>
<p>可以看到 这串代码的核心是，递归调用 backtrack，并且在递归之前做选择，递归之后撤销选择就行。</p>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>最基本的回溯问题就是全排列问题了，就比如给我们【1，2，3】三个数字，求出他们不重复情况的全排列，可以得到以下决策树<br><img src="/2021/09/15/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/jueceshu.png" alt="jcs"><br>我们站在决策树的顶端，此时我们的选择列表是【1，2，3】，没有路径，因为我们还没做过选择，假设我们选择2后到达第二个节点，那么我们的选择列表是【1，3】，2就变成了我们的路径，然后 backtrack函数，就像是个指针，在这个树上游走，要维护每个节点的选择列表和路径，当它走到树的底层后，就触发了结束条件。<br>再然后，如何遍历一个树？ 要记住，所有搜索问题其实都是树的遍历问题，而多叉树的遍历，有两个重要框架，前序遍历和后序遍历，前序遍历在递归进入下一个节点前进行，后续遍历在进入一个节点后执行，前序遍历让多叉树得以向某一子节点递归，后序遍历可以让多叉树依次对多个子节点递归遍历，依照这个思路以及前面的框架，我们得出全排列代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> allSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  backTrack = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 判断是否满足结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(nums.length === path.length)&#123;</span><br><span class="line">      res.push([...path])  </span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决重复路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(path.indexOf(nums[i]) !== -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/** 前序遍历 */</span></span><br><span class="line">      path.push(nums[i])</span><br><span class="line"></span><br><span class="line">      backTrack(path)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 后序遍历</span></span><br><span class="line">      path.pop()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backTrack([])</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p>这个也是回溯经典啊，单比全排列稍微复杂一丢丢，题目的意思就是给我们一个N x N的棋盘，在上面摆N个皇后，让这些皇后不能互相攻击，问我们有几种摆法。<br>然后写回溯问题，我们一定要想明白它的决策树，和写动态规划要想明白df方程是一样的。<br>对于N皇后的决策树，我们可以想决策树的每一层，就是棋盘上的每一行，然后那一层的每一个节点，对应的就是棋盘上那一行的每个列。<br>直接套用上面框架</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Queen = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> board = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="string">&#x27;.&#x27;</span>.repeat(n))</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  isValid = <span class="function">(<span class="params">board, row, col</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = board.length</span><br><span class="line">    <span class="comment">//检查列皇后是否冲突</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(board[i][col] === <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左对角线冲突</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>,j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(board[i][j] === <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右对角线冲突，</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>,j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(board[i][j] === <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  repalceAt = <span class="function">(<span class="params">str,index,target</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> strAry = str.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    strAry[index] = target</span><br><span class="line">    <span class="keyword">return</span> strAry.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  backTrack = <span class="function">(<span class="params">board, row</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(row === board.length)&#123;</span><br><span class="line">      res.push([...board])</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> len = board.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; len; col++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!isValid(board,row,col))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//前序</span></span><br><span class="line">      board[row] = repalceAt(board[row],col,<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      backTrack(board, row + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//后序</span></span><br><span class="line">      board[row] =repalceAt(board[row],col,<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  backTrack(board,<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="回溯和动态规划"><a href="#回溯和动态规划" class="headerlink" title="回溯和动态规划"></a>回溯和动态规划</h2><p>至此回溯就简单的说到这了啊<br>这里我们看到回溯和动态规划的联系和区别，联系就是，二者都需要通过穷举来解题，但动态规划需要通过备忘录解决重叠子问题来优化并找出最佳答案，而回溯就算真正的暴力求解了。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动画与Canvas图形</title>
    <url>/2021/09/26/%E5%8A%A8%E7%94%BB%E4%B8%8ECanvas%E5%9B%BE%E5%BD%A2/</url>
    <content><![CDATA[<p>这篇博客记录下红宝书上的canvas和动画</p>
<span id="more"></span>

<h1 id="Js动画"><a href="#Js动画" class="headerlink" title="Js动画"></a>Js动画</h1><p>早起的Js动画只能用定时器写，结合css的animation和transition来完成，但定时器在浏览器的时间精度是个问题，就会造成动画不流畅，延时等问题，所以这里就有新的API来解决这个问题</p>
<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><p>requesetAnimationFrame()，该接口的参数是一个函数(就是用于执行动画的函数)，该接口的作用就是通知浏览器“我要放一个动画你麻溜的准备好”，然后调用参数函数来精确的完成动画。然后参数函数是一个要在重绘屏幕前调用的函数，这个函数就是修改DOM样式以及反映下一次重绘有什么变化的地方。为了实现动画循环，可以再该函数内部再次调用requesetAnimationFrame()。<br>至此，该API解决了浏览器不知道Js何时开始动画的问题，然后在调用requesetAnimationFrame()时还给执行动画的函数传递一个DOMHighResTimeStamp函数，就是一个时间戳，表示下次重绘的时间，这一点非常重要，requesetAnimationFrame()把重绘任务安排再了未来一个已知的时间点上，而且通过这个参数告诉了开发者。</p>
<p>然后requesetAnimationFrame()的返回值和setTimeout()类似，返回一个请求ID，通过cancelAnimationFrame()来取消重绘任务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> updateProgress = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;status&quot;</span>);</span><br><span class="line">  div.style.width = (<span class="built_in">parseInt</span>(div.style.width, <span class="number">10</span>) + <span class="number">5</span>) + <span class="string">&#x27;%&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (div.style.left != <span class="string">&quot;100%&quot;</span>) &#123;</span><br><span class="line">    requesetAnimationFrame(updateProgress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">requesetAnimationFrame(updateProgress) </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> id = requesetAnimationFrame(updateProgress) </span><br><span class="line"></span><br><span class="line">cancelAnimationFrame(id)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>在使用requesetAnimationFrame()要注意节流的使用</strong></p>
<h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><p>canvas是html的标签元素，写它的时候要声明id,width和height</p>
<h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><ul>
<li>getContext() 获取绘图上下文，比如传参’2d’，就表示要获取2D上下文对象</li>
<li>toDataURL() 导出canvas元素上的图像</li>
</ul>
<h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p>对于2d上下文对象，会建一个坐标系，然后根据坐标来绘图<br>坐标原点在canvas元素的左上角，然后width和height就限定了坐标的最大值，2d绘图有两个基本操作，填充和描边</p>
<ul>
<li>strokeStyle() 用于描边</li>
<li>fillStyle() 用于填充<br>绘制矩形的API，都接受四个参数，分别是起始x,y坐标和宽度高度</li>
<li>fillRect() 填充矩形</li>
<li>strokeRect() 绘制矩形边框</li>
<li>clearRect() 擦除指定区域</li>
</ul>
<h3 id="绘制路径的API"><a href="#绘制路径的API" class="headerlink" title="绘制路径的API"></a>绘制路径的API</h3><ul>
<li>beginPath() 表示开始绘制路径</li>
<li>closePath() 表示关闭绘制路径 图形绘制命令又重新指向到上下文中</li>
<li>stroke() 通过线条来绘制图形轮廓</li>
<li>fill() 通过填充路径的内容区域生成实心的图形<br>意思就是 创建路径之后，可以用closePath()方法绘制一条返回起点的线，如果路径已经完成，就可以用fill()或者stroke()方法来描画路径，还可以调用clip()方法基于已有路径创建一个新剪切区域。</li>
<li>arc() 绘制弧线，参数啥的去MDN查吧，</li>
<li>arcTo() </li>
<li>bezierCurveTo() 三次贝塞尔曲线</li>
<li>quadraticCurveTo() 二次贝塞尔曲线</li>
<li>rect() 绘制矩形 与前面的矩形相关API的区别是绘制路径和绘制图形</li>
<li><strong>lineTo(x,y)</strong> 绘制一条从上一点到(x,y)的直线</li>
<li><strong>moveTo(x,y)</strong> 不绘制线条，只把绘制光标移动到(x,y)<br>还有个isPointInPath(x,y)方法帮我们判断目前路径是否在某点(x,y)上</li>
</ul>
<h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><p>绘制文本的方法，都接受四个参数,要绘制的字符串，x坐标，y坐标，和可选的最大像素宽度。</p>
<ul>
<li>fillText()</li>
<li>strokeText()</li>
</ul>
<p>这两个方法最终绘制都取决于以下属性</p>
<ul>
<li>font: css语法指定的字体样式</li>
<li>textAlign: 指定文本对齐方式</li>
<li>textBaseLine: 指定文本的基线</li>
</ul>
<p>用measureText()获得文本的宽度</p>
<h3 id="变换、"><a href="#变换、" class="headerlink" title="变换、"></a>变换、</h3><p>。。。<br>写不下去了<br>太多API了赣</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>map()中的key</title>
    <url>/2021/06/09/map-%E4%B8%AD%E7%9A%84key/</url>
    <content><![CDATA[<p> 经典面试题:<br>      1). react/vue中的key有什么作用？（key的内部原理是什么？）<br>      2). 为什么遍历列表时，key最好不要用index?</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 虚拟DOM中key的作用：</span><br><span class="line">1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</span><br><span class="line">2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】,随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：</span><br><span class="line">a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：</span><br><span class="line">(1).若虚拟DOM中内容没变, 直接使用之前的真实DOM</span><br><span class="line">(2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</span><br><span class="line">b. 旧虚拟DOM中未找到与新虚拟DOM相同的key，根据数据创建新的真实DOM，随后渲染到到页面</span><br><span class="line">2. 用index作为key可能会引发的问题：</span><br><span class="line">   1.) 若对数据进行：逆序添加、逆序删除等破坏顺序操作,会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</span><br><span class="line">2.) 如果结构中还包含输入类的DOM：会产生错误DOM更新 ==&gt; 界面有问题。</span><br><span class="line">3.) 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作,仅用于渲染列表用于展示，使用index作为key是没有问题的。</span><br><span class="line">3. 开发中如何选择key?:</span><br><span class="line">1.)最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</span><br><span class="line">2.)如果确定只是简单的展示数据，用index也是可以的。</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"> 慢动作回放----使用index索引值作为key</span><br><span class="line"></span><br><span class="line">     初始数据：</span><br><span class="line">         &#123;id:1,name:&#x27;小张&#x27;,age:18&#125;,</span><br><span class="line">         &#123;id:2,name:&#x27;小李&#x27;,age:19&#125;,</span><br><span class="line">     初始的虚拟DOM：</span><br><span class="line">         &lt;li key=0&gt;小张---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li key=1&gt;小李---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">     更新后的数据：</span><br><span class="line">         &#123;id:3,name:&#x27;小王&#x27;,age:20&#125;,</span><br><span class="line">         &#123;id:1,name:&#x27;小张&#x27;,age:18&#125;,</span><br><span class="line">         &#123;id:2,name:&#x27;小李&#x27;,age:19&#125;,</span><br><span class="line">         更新数据后的虚拟DOM：</span><br><span class="line">         &lt;li key=0&gt;小王---20&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li key=1&gt;小张---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li key=2&gt;小李---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">慢动作回放----使用id唯一标识作为key</span><br><span class="line"></span><br><span class="line">初始数据：</span><br><span class="line">&#123;id:1,name:&#x27;小张&#x27;,age:18&#125;,</span><br><span class="line">&#123;id:2,name:&#x27;小李&#x27;,age:19&#125;,</span><br><span class="line">初始的虚拟DOM：</span><br><span class="line">&lt;li key=1&gt;小张---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line">&lt;li key=2&gt;小李---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">更新后的数据：</span><br><span class="line">&#123;id:3,name:&#x27;小王&#x27;,age:20&#125;,</span><br><span class="line">&#123;id:1,name:&#x27;小张&#x27;,age:18&#125;,</span><br><span class="line">&#123;id:2,name:&#x27;小李&#x27;,age:19&#125;,</span><br><span class="line">更新数据后的虚拟DOM：</span><br><span class="line">&lt;li key=3&gt;小王---20&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line">&lt;li key=1&gt;小张---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line">&lt;li key=2&gt;小李---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>小幸运项目总结</title>
    <url>/2021/10/18/%E5%B0%8F%E5%B9%B8%E8%BF%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>同时打三份工的日子终于放缓了一会儿，可以静下心来学点和写点总结博客了，这篇就是关于小幸运的总结博客</p>
<span id="more"></span>

<h1 id="项目概览"><a href="#项目概览" class="headerlink" title="项目概览"></a>项目概览</h1><p>大家应该也都玩过小幸运，具体的功能需求我就不多说了，当时暑假开工的时候，Uni那边是分了一个同级的女生一起，由于两个人都没有什么开发经验，所以一开始抽组件就没怎么抽，能复用的逻辑也大部分没有思考到(就比如弹窗)，一开始就是各自写各自的页面，所以也没有什么能过多交流的部分，再之后就是Uni那边换了一个大三的学长带我写，无论是代码的规范性还是一些逻辑写法都让我学到很多，(就比如css多按两个tab健就能让代码第一眼看上去无比美观)</p>
<p>接下来的介绍顺序应该是我先说一些我自己写的并值得拿出来的东西，然后就说一下通过这个项目学到了哪些。</p>
<p>我写的部分就是Home -&gt; Wishes -&gt; Send三个界面 和Service的封装</p>
<h1 id="Fetch的封装"><a href="#Fetch的封装" class="headerlink" title="Fetch的封装"></a>Fetch的封装</h1><p>进去后学长就让我先负责Service对象的封装，因为之前写的组件啊和路由跳转啊啥的都太自主化了（就是没怎么沟通我自己一个人在写根本不知道对方负责的部分到哪儿了的那种），很乱，所以学长就去重构部分静态代码和重写组件了，测接口的任务就我自己开始写了。</p>
<p>而之前并没有什么和后端有交互的项目经历，唯一的hackathon还是用Taro写的，没什么参考性，所以一开始就蛮懵的。就去找了些团队项目的代码直接放上去了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我不懂为啥不直接lucky.itoken呢...</span></span><br><span class="line"><span class="keyword">const</span> BASEURL = <span class="built_in">window</span>.location.href.slice(<span class="number">0</span>, <span class="built_in">window</span>.location.href.indexOf(<span class="string">&#x27;/&#x27;</span>, <span class="number">10</span>)) + <span class="string">&quot;/api&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fetch</span>(<span class="params">url, opt = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>) <span class="comment">//现在一般取名叫Authorization</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    opt.method = opt.method || <span class="string">&#x27;GET&#x27;</span>;</span><br><span class="line">    opt.headers = &#123;</span><br><span class="line">        <span class="attr">Accept</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    opt.headers.token = token</span><br><span class="line">  	<span class="comment">// 这句好像多余?</span></span><br><span class="line">    <span class="keyword">if</span> (opt.body) &#123;</span><br><span class="line">        opt.body = <span class="built_in">JSON</span>.stringify(opt.body)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    opt.body = <span class="built_in">JSON</span>.stringify(opt.data) || <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (opt.formdata) &#123;</span><br><span class="line">        opt.body = opt.formdata;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetch(url, opt)</span><br><span class="line">        .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">                <span class="keyword">return</span> response.json().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> response.json().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_, reject</span>) =&gt;</span> &#123; <span class="comment">//可以直接写成Promise.reject()</span></span><br><span class="line">                        reject(res);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.status === -<span class="number">2</span>) &#123;</span><br><span class="line">                alert(res.msg)</span><br><span class="line">                <span class="built_in">localStorage</span>.removeItem(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重定向到根目录，重新登录</span></span><br><span class="line">                <span class="keyword">let</span> redirectpos = <span class="built_in">window</span>.location.href</span><br><span class="line">                redirectpos = redirectpos.slice(<span class="number">0</span>, redirectpos.indexOf(<span class="string">&#x27;/&#x27;</span>, <span class="number">10</span>) + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">window</span>.location.href(redirectpos)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (res.status !== <span class="number">0</span>) &#123;</span><br><span class="line">                    alert(res.msg)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            alert(<span class="string">`服务端错误：<span class="subst">$&#123;e.message&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这算是最简单的一种封装形式了，然后我看了下菁程和老版工作台的代码，他们的token都存在了cookie里面，然后就有关于cookie操作的文件，目前我也没有遇到过要用cookie的情况，就没去仔细看了，然后他们还在Fetch的基础上再封装，也就是直接把GET,POST,DELETE这些请求方式当作方法暴露出来，就可以直接以get(url)方式来写了(菁程是这样的)。然后这里在测试的时候有一个bug，就是用户去查看自己的愿望时看到的愿望不是自己的，我当时是以为是后端问题，因为这是返回的response错了，但后端明确说了自己没问题，然后武理那边说这是缓存的问题，就是GET请求会有缓存而POST请求没有，所以要么给GET请求加上时间戳，要么把换成POST请求，换成POST的话后端那边就要改，于是就选择了前者，然后前者就需要再每一个GET里面加上一句生成当前时间戳的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getLightManInfo</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="keyword">new</span> URL(BASEURL + <span class="string">&#x27;/user/info/lightman&#x27;</span>)</span><br><span class="line">    url.searchParams.append(<span class="string">&quot;wish_id&quot;</span>, id)</span><br><span class="line">    url.searchParams.append(<span class="string">&quot;time&quot;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().getTime())</span><br><span class="line">    <span class="keyword">return</span> Fetch(url)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>所以这里如果我们之前封装好了GET,把这段逻辑放进去，就不需要重复写了，可惜时间上来不及了唉。。。</p>
<p>然后菁程对于我刚刚说的GET啊POST啊的再封装是这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">url, data?</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> opts: OptsProps = data;   <span class="comment">//高阶函数？ 函数柯里化？</span></span><br><span class="line">    <span class="keyword">return</span> fn(url, opts);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> encapsulationMethod = <span class="function">(<span class="params">method</span>) =&gt;</span> &#123; <span class="comment">// 把时间戳加在这里就行</span></span><br><span class="line">  <span class="keyword">let</span> optsObj;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">url, opts</span>) =&gt;</span> &#123;</span><br><span class="line">    optsObj = opts || &#123;&#125;;</span><br><span class="line">    optsObj.method = method;</span><br><span class="line">    <span class="keyword">return</span> FetchData(url, optsObj);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> get = proxy(encapsulationMethod(<span class="string">&#x27;GET&#x27;</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> post = proxy(encapsulationMethod(<span class="string">&#x27;POST&#x27;</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> put = proxy(encapsulationMethod(<span class="string">&#x27;PUT&#x27;</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Delete = proxy(encapsulationMethod(<span class="string">&#x27;DELETE&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> putCompanyInfoLogo = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> put(<span class="string">&#x27;/company/info/logo&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">token</span>: <span class="literal">true</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后呢，现在写新的Ts项目，比如工作台2.0和木犀云，都用了Pont, 在Pont里只需要最简单的处理一下fetch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Request = <span class="function">(<span class="params">url, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (options === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">        options = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    url = <span class="string">`/api/v1<span class="subst">$&#123;url&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">    options.headers = &#123;</span><br><span class="line">        <span class="attr">Accept</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    options.headers.Authorization = <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.body) &#123;</span><br><span class="line">        options.body = <span class="built_in">JSON</span>.stringify(options.body)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fetch(url, options).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> res.json()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Request</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在最外层</span></span><br><span class="line">	pontCore.useFetch(Request)</span><br></pre></td></tr></table></figure>

<p>至于Pont的具体原理还没有细究，但是很牛逼，其他的什么url都不用写，参数会自动提示，只需要调用接口就行！</p>
<h1 id="滑动愿望的动画"><a href="#滑动愿望的动画" class="headerlink" title="滑动愿望的动画"></a>滑动愿望的动画</h1><p>这个动画没啥好讲的，我用的就是最原始的写法，没有用任何库，原理和暑假直播讲的景深特效差不多，首先三个树叶绝对定位，然后写上不同的z-index凸显层级，再然后左边的就left: -10vw 右边的就left:10vw。然后这里要处理三个事件，onTouchStart, onTouchMove, onTouchEnd，分别对应手指接触屏幕，手指在屏幕上滑动，手指离开屏幕。然后根据手指在屏幕上滑动的距离找出一个比例关系去改变left就行。 思路和实现都很简单，但这种写法我觉得还是蛮烂的，所以就简单的放一下相对应的事件处理函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Start/Move/End 都是控制愿望刷新动画的相关函数</span></span><br><span class="line"><span class="keyword">const</span> onTouchStart = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> touch = e.targetTouches[<span class="number">0</span>]</span><br><span class="line">    setStartX(&#123; <span class="attr">start</span>: touch.pageX, <span class="attr">move</span>: <span class="string">&#x27;&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> onTouchMove = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> touch = e.targetTouches[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> move_X = ((touch.pageX - startX.start) / <span class="number">5</span>)</span><br><span class="line">    setStartX(startX)</span><br><span class="line">    setMove(&#123; <span class="attr">img1</span>: move_X, <span class="attr">img2</span>: <span class="number">10</span>, <span class="attr">img3</span>: <span class="number">20</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> onTouchEnd = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setUpDate(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> (move.img1 &lt; -<span class="number">25</span>) &#123;</span><br><span class="line">        setMove(&#123; <span class="attr">img1</span>: -<span class="number">90</span>, <span class="attr">img2</span>: <span class="number">0</span>, <span class="attr">img3</span>: <span class="number">10</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (move.img1 &gt; <span class="number">20</span>) &#123;</span><br><span class="line">        setMove(&#123; <span class="attr">img1</span>: <span class="number">90</span>, <span class="attr">img2</span>: <span class="number">0</span>, <span class="attr">img3</span>: <span class="number">10</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        setMove(&#123; <span class="attr">img1</span>: <span class="number">0</span>, <span class="attr">img2</span>: <span class="number">10</span>, <span class="attr">img3</span>: <span class="number">20</span> &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷新愿望</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setUpDate(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">let</span> newWishSource = wishes</span><br><span class="line">        newWishSource.push(newWishSource[<span class="number">0</span>])</span><br><span class="line">        newWishSource.splice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        setWishes(newWishSource)</span><br><span class="line">        <span class="comment">// 刷新动画</span></span><br><span class="line">        setMove(moveState)</span><br><span class="line">    &#125;, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就事后看了一些动画库 没准儿以后能用上</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000018861018">React-transition-group 路由页面跳转动画库</a></li>
</ul>
<p>​        <a href="https://juejin.cn/post/6887471865720209415">优化方案</a></p>
<p><a href="http://reactcommunity.org/react-transition-group/transition-group">官网</a></p>
<ul>
<li><a href="https://react-spring.io/">react-spring</a> 这个好像可以用来写树叶滑动的动画，但没实践</li>
</ul>
<p>还有一些其他的，但也没必要，这种库会一个就行，大不了自己写，虽然可能会烂的一批….</p>
<h1 id="武理的第三方登录"><a href="#武理的第三方登录" class="headerlink" title="武理的第三方登录"></a>武理的第三方登录</h1><p>然后这里就是关于武理的一个第三方登录机制，就是说武理那边不直接暴露接口给Uni用嘛，就需要跳转到智慧理工大那个页面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> goWHUT = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> position = <span class="built_in">window</span>.location.href</span><br><span class="line">    <span class="keyword">let</span> continueurl = position.slice(<span class="number">0</span>, position.indexOf(<span class="string">&#x27;/&#x27;</span>, <span class="number">10</span>))</span><br><span class="line">    <span class="keyword">let</span> posturl = continueurl + <span class="string">&quot;/api/login/whut/callback&quot;</span></span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">`https://ias.sso.itoken.team/portal.php?posturl=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(posturl)&#125;</span>&amp;continueurl=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(continueurl)&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后登录成功后智慧理工大会自动带着cookie重定向回来，我们就在cookie里拿到token就行了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = cookie.load(<span class="string">&#x27;jwt_token&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;token&#x27;</span>, token)</span><br><span class="line">        props.history.push(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;token&quot;</span>)) &#123;</span><br><span class="line">        props.history.push(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [props.history])</span><br></pre></td></tr></table></figure>

<p>学长告诉我是调用了一个ias接口，这我查半天没查到这个接口到底是个啥，总体的登录逻辑应该和通行证差不多吧，带着一个landing过去并存入cookie防止landing丢失，然后登录成功后依据landing并带着code重定向回来，嗯，大概是这样</p>
<h1 id="文本下划线的自动生成"><a href="#文本下划线的自动生成" class="headerlink" title="文本下划线的自动生成"></a>文本下划线的自动生成</h1><p>这个！ 破需求！ 折磨了我好久 ！ 查了n多方法！终于让我看到大佬的实现方式 直接上代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// wishes页面的下划线生成(处理超长文本)</span><br><span class="line"><span class="selector-class">.wishes</span> &#123;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, <span class="built_in">rgba</span>(<span class="number">241</span>, <span class="number">197</span>, <span class="number">126</span>, <span class="number">0</span>) <span class="number">10px</span>, transparent <span class="number">10px</span>),</span><br><span class="line"><span class="built_in">linear-gradient</span>(to left, <span class="built_in">rgba</span>(<span class="number">241</span>, <span class="number">197</span>, <span class="number">126</span>, <span class="number">0</span>) <span class="number">10px</span>, transparent <span class="number">10px</span>),</span><br><span class="line"><span class="built_in">linear-gradient</span>(<span class="built_in">rgba</span>(<span class="number">241</span>, <span class="number">197</span>, <span class="number">126</span>, <span class="number">0</span>) <span class="number">30px</span>, black <span class="number">30px</span>, black <span class="number">31px</span>, white <span class="number">31px</span>);</span><br><span class="line">&#125;</span><br><span class="line">// send页面的下划线生成</span><br><span class="line"><span class="selector-class">.send</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, <span class="built_in">rgb</span>(<span class="number">241</span>, <span class="number">197</span>, <span class="number">126</span>) <span class="number">10px</span>, transparent <span class="number">10px</span>),</span><br><span class="line">                <span class="built_in">linear-gradient</span>(to left, <span class="built_in">rgb</span>(<span class="number">241</span>, <span class="number">197</span>, <span class="number">126</span>) <span class="number">10px</span>, transparent <span class="number">10px</span>),</span><br><span class="line">                <span class="built_in">linear-gradient</span>(<span class="built_in">rgb</span>(<span class="number">241</span>, <span class="number">197</span>, <span class="number">126</span>) <span class="number">30px</span>, black <span class="number">30px</span>, black <span class="number">31px</span>, white <span class="number">31px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就当你在textarea里面写下超长文本后，由于background- image的默认repeat，咱就能看见自动出现的下划线咯！ 不过好像有点bug，就是在send页面，下划线不会跟着滑动，而wishes可以，这个没太懂，可能是textarea的原因？</p>
<h1 id="总体逻辑"><a href="#总体逻辑" class="headerlink" title="总体逻辑"></a>总体逻辑</h1><p>最后在大概梳理一下小幸运的逻辑吧，(没准有遗忘的地方？)</p>
<ol>
<li>进入选择学校,武理还是华师，两个Link，无交互，如果选择武理就是到智慧理工大进行第三方登录，华师的话跳转到login界面</li>
<li>在login界面输入账号密码，调后端给的接口，登陆成功后token存入localstorage中，并调用checkemail接口查询是否绑定邮箱，未绑定就到bindemail页面去调接口绑定一下再去home，绑定的就直接去home (这里前端没有写正则规范邮箱格式，不知道后端有没有写)</li>
<li>home页面就是九个分类嘛，一个tags数组map生成就行，修一下样式，然后根据分类可以进入愿望池，或者直接投递我的愿望</li>
<li>投递我的愿望也就是一个from嘛，愿望内容分类姓名联系方式啥的，不是很难，就是要写太多受控组件比较麻烦，不过应该会有一种自定义hooks的写法统一处理的，不过相关写法我自己没想出来也没查到，不然太多useState()也太麻烦了（又比如可以用antd的那种组件封装的形式？）</li>
<li>愿望池页面的难点就是动画和对树叶上超长文本愿望的处理咯，这里上面也已经说过了，(overflow:scroll和下划线解决)，然后一个是点亮愿望的按钮一个是去往我的愿望列表</li>
<li>点亮愿望的按钮按下去就会弹出一个表单，和Send页面几乎一致，也就是多写几个useState()的事。。。</li>
<li>然后到愿望列表页，分两个区域调两个接口，一个是MyPost一个是MyWish，根据投递时间排序，然后左下角有愿望状态显示</li>
<li>再之后就是到愿望详情页，对单个愿望进行实现/删除等操作，这里都是学长的部分了也没细究</li>
<li>还有一个分享页面，其实也就是针对一个愿望，页面几乎一致只不过有一个单独的点亮按钮</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>嗯….好像就没了？因为其实小幸运的页面逻辑不太难，静态方面用好flex就行(因为太多图片啦),然后有一个需要仔细考虑的地方就是，愿望状态分为未点亮/点亮未实现/已实现，然后愿望自身又分为自己投递的/点亮别人的，这些愿望都会出现在wishList这个页面，然后跳转到愿望详情detail那里，就要写很多判断来决定在detail页面到底是渲染哪种愿望状态的组件上去(因为不同状态的愿望按钮不一样，比如点亮的button是确认实现，然后已实现的button就会变成灰色等)，这个页面是学长负责的，我只是提供了点思路和想法，学长一个文件写了快五百行，因为当时快到上线期了，所以估计也没怎么拆组件复用逻辑了，总之小幸运还是如期上线了，第一个上线的项目能引起很多人去参与还是蛮有成就感的嘿。</p>
<p>最后贴一个项目链接<a href="https://dev.azure.com/949257748/Token/_git/LuckyFrontend">lucky</a></p>
]]></content>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>高阶组件</title>
    <url>/2021/09/13/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>呜呜呜介绍一下高阶组件</p>
<span id="more"></span>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>这里直接看官方文档: <strong>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。</strong><br>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p>
<p>官方文档用了一个demo解释了一下，这里我就说个大概，就是当我们需要两个组件，一个是CommentList用于获取用户评论，一个是BlogPost用于订阅单篇博客，他们都共享<strong>订阅数据————渲染————取消订阅</strong>这么一个逻辑，这样我们就可以把这个公共逻辑抽象成一个函数，这个函数就是一个<strong>高阶组件</strong>，因为这个函数接受了一个普通组件作为参数返回了一个有着订阅逻辑后的新组件，直接上代码: (这里我随便写写，跟官方不一样了)</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本组件逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CommentList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState()</span><br><span class="line">  useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    DataSource.getComment(handleChange())<span class="comment">//获取订阅</span></span><br><span class="line">    <span class="keyword">return</span> DataSource.removeComment(handleChange())<span class="comment">//清除订阅</span></span><br><span class="line">  &#125;)</span><br><span class="line">  handleChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setData(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handleChange&#125;</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlogPost</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState()</span><br><span class="line">  useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    DataSource.getBlog(handleChange())<span class="comment">//获取订阅</span></span><br><span class="line">    <span class="keyword">return</span> DataSource.removeBlog(handleChange())<span class="comment">//清除订阅</span></span><br><span class="line">  &#125;)</span><br><span class="line">  handleChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setData(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handleChange&#125;</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶组件函数</span></span><br><span class="line"></span><br><span class="line">getDataComp = <span class="function">(<span class="params">Comp, getDataType,removeDataType</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      DataSource.getDataType()</span><br><span class="line">      <span class="keyword">return</span> DataSource.removeDateType()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setData(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">data</span>=<span class="string">&#123;state.data&#125;</span> <span class="attr">props</span>=<span class="string">&#123;...props&#125;/</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的订阅数据就会作为props传递了，可能这里我写的没有很明白，那就还是可以去官方文档看看。<br>然后高阶组件是纯函数，绝不要在高阶组件中修改原组件模型，并且要将不向关的props传给被包裹的组件，大多数 HOC 都应该包含一个类似于下面的 render 方法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 过滤掉非此 HOC 额外的 props，且不要进行透传</span></span><br><span class="line">  <span class="keyword">const</span> &#123; extraProp, ...passThroughProps &#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 props 注入到被包装的组件中。</span></span><br><span class="line">  <span class="comment">// 通常为 state 的值或者实例方法。</span></span><br><span class="line">  <span class="keyword">const</span> injectedProp = someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 props 传递给被包装组件</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">injectedProp</span>=<span class="string">&#123;injectedProp&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      &#123;<span class="attr">...passThroughProps</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mad 写着写着突然发现，自定义hook是不是可以代替高阶组件和 render props？？？哇日！？我麻了我麻了我麻了<br>这东西可以深挖，先放一放</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>UmiJs</title>
    <url>/2021/10/04/dvaJs/</url>
    <content><![CDATA[<p>一篇关于Umijs的学习笔记</p>
<span id="more"></span>
<p>啥是UmiJs呢！？ 甭管他 我们先滚去了解 redux / redux-saga / dvajs</p>
<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><p>这个网上教程一堆 自己也有博客 就不多说了 反正知道他是react中最火的一个状态管理的方案就行</p>
<h1 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h1><p>然后嘞 我们就看看啥是redux-saga,我们先想想redux是怎么写异步action的，哎，同步action是啥，dispatch一个对象，异步呢，就是dispatch一个函数嘛，然后在applyMiddleWare里面加上thunk，具体的实现原理大概就是tunk会帮你在函数action里面再调dispatch返回出原生的action对象，所以就可以在这个函数里面执行异步操作，因为最后返回的都是action对象，不影响reducer对action的处理，然后applyMiddleWare的作用原理是store=&gt;next=&gt;action=&gt;{}这种形式把所有的middleware串联起来再在最后调dispatch，就是enhancer，create Store()的第三个参数（前两个参数分别是reducer和initalState,这里enhancer可以理解为一种HOF，高阶函数，类似react的高阶组件，起到一个包装修饰的作用），这里就不多说了，这篇博客的重点也不是这个。</p>
<p>然后就有大佬觉得，哎呀thunk太麻烦啦，我不同的异步操作要分散在不同的action里面啊，我action形式也不统一一会儿object一会儿function的太丑了啊，你这轮子不行我要自己造。 这就是大佬的思考方式，别人的轮子不好用就自己造，我等凡人要么是硬着头皮用轮子要么是硬着头皮去找自己不喜欢的轮子。</p>
<p>于是，redux-saga出来了，官方一点的介绍是<br><strong>redux-saga 是一个用于管理 Redux 应用异步操作的中间件（又称异步 action）。 redux-saga 通过创建 Sagas 将所有的异步操作逻辑收集在一个地方集中处理，可以用来代替 redux-thunk 中间件。</strong>。<br>好，有了saga之后，redux的项目逻辑就被分成了两部分</p>
<ul>
<li>Reducers 处理由action带过来的state</li>
<li>Sagas 协调异步操作 (主要是网络请求)</li>
</ul>
<p>然后saga跟thunk的作用原理也不一样<br><img src="/2021/10/04/dvaJs/1.jpg" alt="saga"><br>看这张图，thunk作用在Middleware那里，用来帮你给action函数调disapatch，是在action创建后才起作用的。<br>然后saga，是在你应用启动后就被调用了，他的层级和reducer，store，view是一样的，就可以把他理解为一个被创建的进程，reducer处理action，store管理action，view渲染action带来的state，saga就负责在后台监听action，判断你是同步还是异步，然后帮你调其他API，比如发起异步请求啦，发起同步action啦，甚至是调用其他的saga。</p>
<p>大概了解了saga的原理后，我们就来看一下相关的API</p>
<h2 id="相应API"><a href="#相应API" class="headerlink" title="相应API"></a>相应API</h2><p>先看两个辅助函数 </p>
<ul>
<li>takeEvery</li>
<li>takeLatest</li>
</ul>
<p><strong>takeEvery()</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先创建一个发送网络请求的异步action</span></span><br><span class="line"><span class="keyword">import</span> &#123; call, put &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">fetchUser</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">yield</span> call(Api.fetchUser, action.payload.url);</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;<span class="attr">type</span>: <span class="string">&quot;FETCH_SUCCEEDED&quot;</span>, data&#125;);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;<span class="attr">type</span>: <span class="string">&quot;FETCH_FAILED&quot;</span>, error&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后用takeEvery()触发他</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchFetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;USER_REQUESTED&#x27;</span>, fetchUser)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这怎么理解？ 就假设有一个按钮，点一次可以加载列表，然后有人手欠就一直点点点点点点， 所以’USER_REQUESTED’就不断被分发(算是允许并发，处理多个相同的action)，也就是会一直调用fetchUser()这个saga。列表就会不断加载更新。So,如何解决有人喜欢显摆自己手速的问题呢？</p>
<p>takeLatest()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeLatest &#125; <span class="keyword">from</span> <span class="string">`redux-saga/effects`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetchUser</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchLastFetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeLatest(<span class="string">&#x27;USER_REQUESTED&#x27;</span>, fetchUser)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>这个辅助函数的意思就是说，当一个<code>USER_REQUESTED</code> action 被发起时，使用 <code>takeLatest</code> 来启动一个新的 <code>fetchUser</code> 任务。 由于 <code>takeLatest</code> 取消了所有之前启动且未完成的任务，这样便可以保证：即使用户以极快的速度连续多次触发 <code>USER_REQUESTED</code> action，我们都只会以最后的一个结束。</p>
<p>辅助函数介绍完了，我们来看看saga里面比较重要一个部分 Effect</p>
<h3 id="Effect函数"><a href="#Effect函数" class="headerlink" title="Effect函数"></a>Effect函数</h3><p>saga里面有很多执行Effect的函数，而这些是saga实现作用的关键，看一下常用的吧，为什么叫Effect呢，就是和纯函数对应吗，你异步操作肯定会有副作用产生，所以管你叫Effect没啥问题对吧</p>
<ul>
<li><strong>take(pattern)</strong></li>
</ul>
<p>take函数可以理解为监听未来的action，它创建了一个命令对象，告诉middleware等待一个特定的action， Generator会暂停，直到一个与pattern匹配的action被发起，才会继续执行下面的语句，也就是说，take是一个阻塞的 effect</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchFetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   	 <span class="comment">// 监听一个type为 &#x27;FETCH_REQUESTED&#x27; 的action的执行，直到等到这个Action被触发，才会接着执行下面的 yield fork(fetchData)  语句</span></span><br><span class="line">     <span class="keyword">yield</span> take(<span class="string">&#x27;FETCH_REQUESTED&#x27;</span>);</span><br><span class="line">     <span class="keyword">yield</span> fork(fetchData);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>put(action)</strong></li>
</ul>
<p>put函数是用来发送action的 effect，你可以简单的把它理解成为redux框架中的dispatch函数，当put一个action后，reducer中就会计算新的state并返回，<strong>注意：</strong> put 也是阻塞 effect</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">toggleItemFlow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> list = []</span><br><span class="line">	<span class="comment">// 发送一个type为 &#x27;UPDATE_DATA&#x27; 的Action，用来更新数据，参数为 `data：list`</span></span><br><span class="line">	<span class="keyword">yield</span> put(&#123;</span><br><span class="line">      <span class="attr">type</span>: actionTypes.UPDATE_DATA,</span><br><span class="line">      <span class="attr">data</span>: list</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>call(fn, …args)</strong></li>
</ul>
<p>call函数你可以把它简单的理解为就是可以调用其他函数的函数，它命令 middleware 来调用fn 函数， args为函数的参数，<strong>注意：</strong>  fn 函数可以是一个 Generator 函数，也可以是一个返回 Promise 的普通函数，call 函数也是阻塞 effect</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> delay = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">removeItem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  	<span class="comment">// 这里call 函数就调用了 delay 函数，delay 函数为一个返回promise 的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> call(delay, <span class="number">500</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;<span class="attr">type</span>: actionTypes.ERROR&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>fork(fn, …args)</strong></li>
</ul>
<p>fork 函数和 call 函数很像，都是用来调用其他函数的，但是fork函数是非阻塞函数，也就是说，程序执行完 <code>yield fork(fn， args)</code> 这一行代码后，会立即接着执行下一行代码语句，而不会等待fn函数返回结果后，在执行下面的语句 (takeEvery就是利用take和fork实现的高级API)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fork &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 下面的四个 Generator 函数会一次执行，不会阻塞执行</span></span><br><span class="line">  <span class="keyword">yield</span> fork(addItemFlow)</span><br><span class="line">  <span class="keyword">yield</span> fork(removeItemFlow)</span><br><span class="line">  <span class="keyword">yield</span> fork(toggleItemFlow)</span><br><span class="line">  <span class="keyword">yield</span> fork(modifyItem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>select(selector, …args)</strong></li>
</ul>
<p>select 函数是用来指示 middleware调用提供的选择器获取Store上的state数据，你也可以简单的把它理解为redux框架中获取store上的 state数据一样的功能 ：<code>store.getState()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">toggleItemFlow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 通过 select effect 来获取 全局 state上的 `getTodoList` 中的 list</span></span><br><span class="line">	 <span class="keyword">let</span> tempList = <span class="keyword">yield</span> select(<span class="function"><span class="params">state</span> =&gt;</span> state.getTodoList.list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>createSagaMiddleware()</strong></li>
</ul>
<p>createSagaMiddleware 函数是用来创建一个 Redux 中间件，将 Sagas 与 Redux Store 链接起来</p>
<p>sagas 中的每个函数都必须返回一个 Generator 对象，middleware 会迭代这个 Generator 并执行所有 yield 后的 Effect（Effect 可以看作是 redux-saga 的任务单元）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore, applyMiddleware&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-saga&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">import</span> rootSaga <span class="keyword">from</span> <span class="string">&#x27;./rootSaga&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个saga中间件</span></span><br><span class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducers,</span><br><span class="line">  将sagaMiddleware 中间件传入到 applyMiddleware 函数中</span><br><span class="line">  applyMiddleware(sagaMiddleware)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态执行saga，注意：run函数只能在store创建好之后调用</span></span><br><span class="line">sagaMiddleware.run(rootSaga)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果有多个中间件需要使用的话</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">const sagaMiddleware = createSagaMiddleware()</span></span><br><span class="line"><span class="comment">let middlewares = []</span></span><br><span class="line"><span class="comment">middlewares.push(sagaMiddleware)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">const createStoreWithMiddleware = applyMiddleware(...middlewares)(createStore)</span></span><br><span class="line"><span class="comment">const store = createStoreWithMiddleware(rootReducer)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sagaMiddleware.run(rootSaga)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">const action = type =&gt; store.dispatch(&#123; type &#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>大致就是这些吧，我们目前停留用轮子的阶段也别想着深入探讨原理了，react都还没玩明白呢TnT，会常用 API开发就行，等成为开发大佬后再去走源码看底层比较好吧。</p>
<h1 id="dvaJs"><a href="#dvaJs" class="headerlink" title="dvaJs"></a>dvaJs</h1><p>好嘞，了解了saga后，我们接下来就来看dvaJs，dva 首先是一个基于 <a href="https://github.com/reduxjs/redux">redux</a> 和 <a href="https://github.com/redux-saga/redux-saga">redux-saga</a> 的数据流方案，然后为了简化开发体验，dva 还额外内置了 <a href="https://github.com/ReactTraining/react-router">react-router</a> 和 <a href="https://github.com/github/fetch">fetch</a>，所以也可以理解为一个轻量级的应用框架。</p>
<ul>
<li><strong>易学易用</strong>，仅有 6 个 api，对 redux 用户尤其友好，<a href="https://umijs.org/guide/with-dva.html">配合 umi 使用</a>后更是降低为 0 API</li>
<li><strong>elm 概念</strong>，通过 reducers, effects 和 subscriptions 组织 model</li>
<li><strong>插件机制</strong>，比如 <a href="https://github.com/dvajs/dva/tree/master/packages/dva-loading">dva-loading</a> 可以自动处理 loading 状态，不用一遍遍地写 showLoading 和 hideLoading</li>
<li><strong>支持 HMR</strong>，基于 <a href="https://github.com/dvajs/babel-plugin-dva-hmr">babel-plugin-dva-hmr</a> 实现 components、routes 和 models 的 HMR</li>
</ul>
<p>翻了官网文档，好像dvaJS的思想其实就是多了一个model，把state/reducer/saga统一到了model中，然后用connect把model和page连接起来，而不是和react- redux一样直接连接store了。直接看代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">app.model(&#123;</span><br><span class="line">  <span class="attr">namespace</span>: <span class="string">&#x27;todos&#x27;</span>,  <span class="comment">// 表示全局state上的key</span></span><br><span class="line">  <span class="attr">state</span>: [], <span class="comment">//如果state是一个对象一定要注意state的扁平化 不要深层嵌套</span></span><br><span class="line">  <span class="attr">effects</span>: &#123; <span class="comment">// saga副作用执行异步操作</span></span><br><span class="line">    *<span class="function"><span class="title">addRemote</span>(<span class="params">&#123; payload: todo &#125;, &#123; put, call &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> call(addTodo, todo);</span><br><span class="line">      <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;add&#x27;</span>, <span class="attr">payload</span>: todo &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">reducers</span>: &#123; <span class="comment">// 就是redux里面的reducers</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">state, &#123; payload: todo &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.concat(todo);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">remove</span>(<span class="params">state, &#123; payload: id &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id !== id);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">update</span>(<span class="params">state, &#123; payload: updatedTodo &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (todo.id === updatedTodo.id) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; ...todo, ...updatedTodo &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> todo;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="attr">subscriptions</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">setup</span>(<span class="params">&#123; dispatch, history &#125;</span>)</span> &#123;</span><br><span class="line">        history.listen(<span class="function">(<span class="params">&#123; pathname &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (pathname === <span class="string">&#x27;/users&#x27;</span>) &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">              <span class="attr">type</span>: <span class="string">&#x27;users/fetch&#x27;</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>subscriptions</code> 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。格式为 <code>(&#123; dispatch, history &#125;) =&gt; unsubscribe</code> 。</p>
<p><img src="/2021/10/04/dvaJs/2.png" alt="w"></p>
<p>然后翻到一个贼清晰的博客介绍，就四张图，这里我就不放了，放链接<a href="https://yuque.com/flying.ni/the-tower/tvzasn">https://yuque.com/flying.ni/the-tower/tvzasn</a></p>
<p>基于此，应该对dvaJs有了个大概的了解吧，就是用了一个model(重装机甲嘛)把redux+saga同一联合，直接在一个model里面就能完成action的dispatch和reducer加工，不需要一个个什么./src/redux/action/todo.js啥的。</p>
<p>好嘞，接下来我们就看这篇博客的真正的主角——umiJs！！</p>
<p>。。为什么到现在才开始真正的主角，我觉得是不是有点长有点久了。。。</p>
<h1 id="UmiJs"><a href="#UmiJs" class="headerlink" title="UmiJs"></a>UmiJs</h1><p>那么那么那么，什么是umiJs呢</p>
<p>官方介绍Umi，中文可发音为乌米<strong>，是可扩展的企业级前端应用框架。Umi 以路由为基础的，同时支持配置式路由和约定式路由，保证路由的功能完备，并以此进行功能扩展。然后配以生命周期完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求。</strong></p>
<p>说白了就是大佬写的脚手架。</p>
<p>比如我们写react项目的时候，要干嘛？</p>
<p><code>yarn caeate-react-app</code></p>
<p>是吧，这就是官方提供给我们的一个基于react的脚手架，但这是官方提供哈，一般用于基本需求，那就有大佬不乐意咯，官方不行，官方一般，我自己写一个脚手架</p>
<p><code>yarn create @umijs/umi-app</code></p>
<p>所以，umiJs其实就是一个基于react的脚手架，官方文档也说了为什么不用前者</p>
<ul>
<li>create-react-app 是基于 webpack 的打包层方案，包含 build、dev、lint 等，他在打包层把体验做到了极致，但是不包含路由，不是框架，也不支持配置。所以，如果大家想基于他修改部分配置，或者希望在打包层之外也做技术收敛时，就会遇到困难。</li>
<li>然后我们看看umiJs收敛了哪些依赖</li>
</ul>
<p><img src="/2021/10/04/dvaJs/3.png" alt="umi"></p>
<p>！！离谱不离谱！！他连antd都直接装好了。</p>
<p>仔细一想umi作者好像是阿里的，antd也是阿里的，啊，那没事了。</p>
<p>然后嘞，咱们就看看这个新脚手架的项目结构吧</p>
<p><img src="/2021/10/04/dvaJs/4.png" alt="pj"></p>
<h2 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h2><ul>
<li>package.json</li>
</ul>
<p>包含插件和插件集，以 <code>@umijs/preset-</code>、<code>@umijs/plugin-</code>、<code>umi-preset-</code> 和 <code>umi-plugin-</code> 开头的依赖会被自动注册为插件或插件集。</p>
<ul>
<li>.umirc.ts</li>
</ul>
<p>配置文件，包含 umi 内置功能和插件的配置。如果项目的配置不复杂，推荐在 <code>.umirc.ts</code> 中写配置； 如果项目的配置比较复杂，可以将配置写在 <code>config/config.ts</code> 中，并把配置的一部分拆分出去，比如路由配置可以拆分成单独的 <code>routes.ts</code>：</p>
<ul>
<li>.env</li>
</ul>
<p>环境变量。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PORT=8888</span><br><span class="line">COMPRESS=none</span><br></pre></td></tr></table></figure>

<ul>
<li>dist 目录</li>
</ul>
<p>执行 <code>umi build</code> 后，产物默认会存放在这里。</p>
<ul>
<li>mock 目录</li>
</ul>
<p>存储 mock 文件，此目录下所有 js 和 ts 文件会被解析为 mock 文件。</p>
<ul>
<li>public 目录</li>
</ul>
<p>此目录下所有文件会被 copy 到输出路径。</p>
<ul>
<li><p><code>/src</code> 目录</p>
</li>
<li><p>.umi 目录</p>
</li>
</ul>
<p>临时文件目录，比如入口文件、路由等，都会被临时生成到这里。<strong>不要提交 .umi 目录到 git 仓库，他们会在 umi dev 和 umi build 时被删除并重新生成。</strong></p>
<ul>
<li>layouts/index.tsx</li>
</ul>
<p>约定式路由时的全局布局文件。</p>
<ul>
<li>pages 目录</li>
</ul>
<p>所有路由组件存放在这里。</p>
<ul>
<li>app.ts</li>
</ul>
<p>运行时配置文件，可以在这里扩展运行时的能力，比如修改路由、修改 render 方法等。</p>
<p>然后umi主要就靠插件和配置来完成你的各种依赖需求，状态管理的主要方式就还是dvaJS</p>
<h2 id="约定式路由"><a href="#约定式路由" class="headerlink" title="约定式路由"></a>约定式路由</h2><p>这里就是看看umiJs有哪些比较牛逼的点值得记一下，第一个就是约定式路由。不同于传统的配置式路由，都需要注册，umiJs要在.umirc.ts里写，react要通过route注册，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// umi中的配置路由</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">       <span class="attr">component</span>: <span class="string">&#x27;@/layouts/index&#x27;</span>,</span><br><span class="line">       <span class="attr">routes</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>: <span class="string">&#x27;@/pages/hero&#x27;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">path</span>: <span class="string">&#x27;/hero&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>: <span class="string">&#x27;@/pages/hero&#x27;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">path</span>: <span class="string">&#x27;/item&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>: <span class="string">&#x27;@/pages/item&#x27;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">path</span>: <span class="string">&#x27;/summoner&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>: <span class="string">&#x27;@/pages/summoner&#x27;</span></span><br><span class="line">         &#125;,</span><br><span class="line">       ]</span><br><span class="line">     &#125;,</span><br><span class="line">   ],</span><br><span class="line"><span class="comment">// 小幸运里面的配置路由</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/login&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Login&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/home&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/send&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Send&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/detail&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/wish/:tag&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Wishes&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/mywish&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;MyWish&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&#x27;/login&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">Redirect</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>哎，那什么是约定路由呢<a href="https://umijs.org/zh-CN/docs/convention-routing">https://umijs.org/zh-CN/docs/convention-routing</a></p>
<p>官方介绍是：约定式路由也叫文件路由，就是不需要手写配置，文件系统即路由，通过目录和文件及其命名分析出路由配置。</p>
<p>这个很牛逼，不需要手写配置给你自动生成，但感觉不太好管理和debug</p>
<p>然后还有一些很牛的地方就是umiJs的插件集，之前也说了umiJs是靠插件集来对应解决相应组件，这部分有点杂，配置文件是最难看也是最难理解的，等以后牛逼了再说吧，明日复明日了哎。</p>
<p>所以我们就先拿umi框架搭写一个简单的王者荣耀官网！</p>
<h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>就命令行就完事了呗 这里不贴了。真想写官网去看配置！（暴躁 卧槽我写了好几天了我受不了了卧槽我在干什么！！！）</p>
<p>然后初始化好了后基本的目录结构就是上面的图嘛，这咱就不管了，完整项目的umiJs框架大家可以去看菁程的代码哈，我这里就是简单介绍一下。</p>
<p>基本结构出来后，我们想一想我们要干嘛，懂不懂前端架构的含金量？</p>
<p>状态管理要用dva,组件模式用antd</p>
<p>于是乎我们来到.umirc.ts下，写上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">dva</span>: &#123; <span class="attr">immer</span>: <span class="literal">true</span>, <span class="attr">hmr</span>: <span class="literal">false</span>, &#125;,</span><br><span class="line">  <span class="attr">antd</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">nodeModulesTransform</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>哎，这样就可以用dva和antd了！</p>
<p>好，继续，就假设我们是很牛逼的前端架构师，我们制定了要用的技术栈和布局规范，手底下的开发人员要干嘛？先把大致的布局写出来是吧。</p>
<p>哎这就有了src/layouts/index.tsx</p>
<p>注意 我们采用的是约定式路由 这就会让我们的路由变成 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Layouts&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Route</span>/&gt;</span></span> <span class="comment">// 这部分都是 src/pages下的文件</span></span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">Route</span>/&gt;</span></span></span><br><span class="line">&lt;/Layouts&gt;</span><br><span class="line"><span class="comment">// path=&#x27;/&#x27; 对应的是src/idnex.tsx文件页面</span></span><br></pre></td></tr></table></figure>

<p>也就是在外面包了一层</p>
<p>然后直接利用antd给的Layouts开始布局页面嘛 代码如下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Layout, Menu &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./index.less&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Header, Content, Footer &#125; = Layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> menuData = [</span><br><span class="line">  &#123; <span class="attr">route</span>: <span class="string">&#x27;/hero&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;英雄&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">route</span>: <span class="string">&#x27;/item&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;局内道具&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">route</span>: <span class="string">&#x27;/summoner&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;召唤师技能&#x27;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BasicLayout</span>(<span class="params">props: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">location</span>: &#123; pathname &#125;,</span><br><span class="line">    children,</span><br><span class="line">  &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Layout</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.logo&#125;</span>&gt;</span>王者荣耀资料库 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Menu</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">theme</span>=<span class="string">&quot;dark&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">mode</span>=<span class="string">&quot;horizontal&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">defaultSelectedKeys</span>=<span class="string">&#123;[pathname]&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">lineHeight:</span> &#x27;<span class="attr">64px</span>&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">          &gt;</span></span></span><br><span class="line"><span class="xml">            &#123;menuData.map(menu =&gt; (</span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>= <span class="string">&#123;</span>`/$&#123;<span class="attr">menu.route</span>&#125;`&#125;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;menu.route&#125;</span>&gt;</span>&#123;menu.name&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line"><span class="xml">            ))&#125;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Content</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">padding:</span> &#x27;<span class="attr">0</span> <span class="attr">50px</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">background:</span> &#x27;#<span class="attr">fff</span>&#x27;, <span class="attr">padding:</span> <span class="attr">24</span>, <span class="attr">minHeight:</span> <span class="attr">280</span> &#125;&#125;&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Footer</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textAlign:</span> &#x27;<span class="attr">center</span>&#x27; &#125;&#125;&gt;</span>今天是乐爷开始学umi的第一天<span class="tag">&lt;/<span class="name">Footer</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BasicLayout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*props默认传的是 </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  match?: match&lt;P&gt;;</span></span><br><span class="line"><span class="comment">  location: Location&lt;S&gt;;</span></span><br><span class="line"><span class="comment">  history: History;</span></span><br><span class="line"><span class="comment">  route: IRoute;</span></span><br><span class="line"><span class="comment">&#125; 以及React封装好的泛型Props 比如children 这里我懒得定义Interface了，还有记住最好用箭头函数写哈，function太丑*/</span></span><br></pre></td></tr></table></figure>

<p>然后基本的布局页面我们就弄好咯，静态结束后要干嘛，哎，搞数据，搞活的</p>
<p>dva这是就来咯，记住什么是dva，重机甲，放到代码里面呢？model对象，So，我们就搞一个models文件夹，里面就放这些model对象就好了。(菁程里面好像是把model和需要这个model的页面放在了一个文件夹里面，我也不知道哪种方式牛逼一点)</p>
<p>因为我们就看一个hero页面嘛，就直接上src/models/hero.tsx的代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Effect, Reducer, Subscription, request &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HeroProps &#123;</span><br><span class="line">  <span class="attr">ename</span>: <span class="built_in">number</span>;</span><br><span class="line">  cname: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  new_type: <span class="built_in">number</span>;</span><br><span class="line">  hero_type: <span class="built_in">number</span>;</span><br><span class="line">  skin_name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HeroModelState &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  heros: HeroProps[];</span><br><span class="line">  freeheros: HeroProps[];</span><br><span class="line">  filterKey: <span class="built_in">number</span>;</span><br><span class="line">  itemHover: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HeroModelType &#123;</span><br><span class="line">  <span class="attr">namespace</span>: <span class="string">&#x27;hero&#x27;</span>;</span><br><span class="line">  state: HeroModelState;</span><br><span class="line">  effects: &#123;</span><br><span class="line">    <span class="attr">query</span>: Effect;</span><br><span class="line">    fetch: Effect;</span><br><span class="line">  &#125;;</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="attr">save</span>: Reducer&lt;HeroModelState&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">  subscriptions: &#123; <span class="attr">setup</span>: Subscription &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HeroModel: HeroModelType = &#123;</span><br><span class="line">  <span class="attr">namespace</span>: <span class="string">&#x27;hero&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;hero&#x27;</span>,</span><br><span class="line">    <span class="attr">heros</span>: [],</span><br><span class="line">    <span class="attr">freeheros</span>: [],</span><br><span class="line">    <span class="attr">filterKey</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">itemHover</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">effects</span>: &#123;</span><br><span class="line">    *<span class="function"><span class="title">fetch</span>(<span class="params">&#123; <span class="keyword">type</span>, payload &#125;, &#123; put, call, select &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">yield</span> request(<span class="string">&#x27;/web201605/js/herolist.json&#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> freeheros = <span class="keyword">yield</span> request(<span class="string">&#x27;mock/freeheros.json&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">          <span class="attr">Accept</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json; charset=utf-8&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">          <span class="attr">number</span>: <span class="number">10</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> localData = [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">ename</span>: <span class="number">105</span>,</span><br><span class="line">          <span class="attr">cname</span>: <span class="string">&#x27;廉颇&#x27;</span>,</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;正义爆轰&#x27;</span>,</span><br><span class="line">          <span class="attr">new_type</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">hero_type</span>: <span class="number">3</span>,</span><br><span class="line">          <span class="attr">skin_name</span>: <span class="string">&#x27;正义爆轰|地狱岩魂&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">ename</span>: <span class="number">106</span>,</span><br><span class="line">          <span class="attr">cname</span>: <span class="string">&#x27;小乔&#x27;</span>,</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;恋之微风&#x27;</span>,</span><br><span class="line">          <span class="attr">new_type</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">hero_type</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">skin_name</span>: <span class="string">&#x27;恋之微风|万圣前夜|天鹅之梦|纯白花嫁|缤纷独角兽&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ];</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;save&#x27;</span>,</span><br><span class="line">        <span class="attr">payload</span>: &#123;</span><br><span class="line">          <span class="attr">heros</span>: data || localData,</span><br><span class="line">          freeheros</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    *<span class="function"><span class="title">query</span>(<span class="params">&#123; payload &#125;, &#123; call, put &#125;</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">save</span>(<span class="params">state, action</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        ...action.payload,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">subscriptions</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params">&#123; dispatch, history &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> history.listen(<span class="function">(<span class="params">&#123; pathname &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pathname === <span class="string">&#x27;/hero&#x27;</span>) &#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;fetch&#x27;</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HeroModel;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这应该都可以看懂吧大家 不懂我现场讲 我写不动了 真的写不动了 知识产出太累了 更何况我还没有知识</p>
<p>这里我们插一嘴，可以看到网络请求直接调用了request这个方法，哎，想想看他是手写的封装fetch还是很pont一样牛逼直接根据后端给的json直接生成？哈哈哈我也不知道 我只知道要在app.ts那里配置一句话就好了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ResponseError &#125; <span class="keyword">from</span> <span class="string">&#x27;umi-request&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> request = &#123;</span><br><span class="line">  <span class="attr">prefix</span>: <span class="string">&#x27;/api&#x27;</span>,</span><br><span class="line">  <span class="attr">errorHandler</span>: <span class="function">(<span class="params">error: ResponseError</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 集中处理错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>🤔 这也就是给所有的请求加了一个前缀和错误处理吗，request的底层。。。再说吧再说吧</p>
<p>接下来还要注意一点，就是在没有mock本地测试数据的话，一般都会产生跨域问题<a href="https://juejin.cn/post/6844903882083024910%E8%AF%A6%E7%BB%86%E7%9A%84%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%93%88">https://juejin.cn/post/6844903882083024910详细的看这个哈</a> 我反正没看完</p>
<p>然后react里有两种解决的跨域方案，简单点的就是写个在packag.json写proxy属性，缺点就是只能访问单一地址，复杂点的就是自己在src下写setupProxy中间件(用node的语法，什么moudle.export），然后umi自然也是有方法解决跨域的啦</p>
<p><img src="/2021/10/04/dvaJs/proxy.jpg" alt="proxy"></p>
<p>还是去我们的./.umirc.js</p>
<p>然后</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;proxy&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;/api/&quot;</span>: &#123; <span class="comment">//设置代理请求头，当访问到/api时就会触发代理</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;https://pvp.qq.com/&quot;</span>, <span class="comment">//代理访问的真实服务器地址</span></span><br><span class="line">    <span class="attr">&quot;changeOrigin&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否跨域请求地址</span></span><br><span class="line">    <span class="attr">&quot;pathRewrite&quot;</span>: &#123; <span class="attr">&quot;^/api&quot;</span>: <span class="string">&quot;&quot;</span> &#125; <span class="comment">// 是否重写请求地址，比如这里就是吧/api替换成空字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便一提 <strong>代理只是请求服务代理，不是请求地址</strong></p>
<p>我们打开控制台，可以看到我们的请求地址是 <code>http://localhost:8000/api/web201605/js/herolist.json</code> ,响应200，并返回了真实数据。</p>
<p>你不会在浏览器的控制台中查看到我们真实代理的地址，这里需要注意，代理只是将请求服务做了中转，设置proxy不会修改请求地址。</p>
<p>弄了请求 弄了布局 就开始英雄列表页嗷</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect, HeroModelState, ConnectProps &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Row, Col, Radio, Card &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RadioChangeEvent &#125; <span class="keyword">from</span> <span class="string">&#x27;antd/es/radio/interface&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> FreeHeroItem <span class="keyword">from</span> <span class="string">&#x27;@/components/FreeHeroItem&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./hero.less&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RadioGroup = Radio.Group;</span><br><span class="line"></span><br><span class="line">interface PageProps <span class="keyword">extends</span> ConnectProps &#123;</span><br><span class="line">  <span class="attr">hero</span>: HeroModelState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heroType = [</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">0</span>, <span class="attr">value</span>: <span class="string">&#x27;全部&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="string">&#x27;战士&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">2</span>, <span class="attr">value</span>: <span class="string">&#x27;法师&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">3</span>, <span class="attr">value</span>: <span class="string">&#x27;坦克&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">4</span>, <span class="attr">value</span>: <span class="string">&#x27;刺客&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">5</span>, <span class="attr">value</span>: <span class="string">&#x27;射手&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">6</span>, <span class="attr">value</span>: <span class="string">&#x27;辅助&#x27;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Hero: FC&lt;PageProps&gt; = <span class="function">(<span class="params">&#123; hero, dispatch &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; heros = [], filterKey = <span class="number">0</span>, freeheros = [], itemHover = <span class="number">0</span> &#125; = hero;</span><br><span class="line">  <span class="built_in">console</span>.log(freeheros)</span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e: RadioChangeEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch!(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;hero/save&quot;</span>, <span class="attr">payload</span>: &#123;</span><br><span class="line">        <span class="attr">filterKey</span>: e.target.value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onItemHover = <span class="function">(<span class="params">index: number</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch!(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;hero/save&#x27;</span>,</span><br><span class="line">      <span class="attr">payload</span>: &#123;</span><br><span class="line">        <span class="attr">itemHover</span>: index</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.normal&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.info&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Row</span> <span class="attr">className</span>=<span class="string">&#123;styles.freehero&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Col</span> <span class="attr">span</span>=<span class="string">&#123;24&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>周免英雄<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">              &#123;</span></span><br><span class="line"><span class="xml">                freeheros.map((data, index) =&gt; (</span></span><br><span class="line"><span class="xml">                  <span class="tag">&lt;<span class="name">FreeHeroItem</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">data</span>=<span class="string">&#123;data&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">itemHover</span>=<span class="string">&#123;itemHover&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">onItemHover</span>=<span class="string">&#123;onItemHover&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">thisIndex</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">key</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                  /&gt;</span></span></span><br><span class="line"><span class="xml">                ))</span></span><br><span class="line"><span class="xml">              &#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Col</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Card</span> <span class="attr">className</span>=<span class="string">&#123;styles.radioPanel&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">RadioGroup</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;filterKey&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;heroType.map(data =&gt; (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Radio</span> <span class="attr">value</span>=<span class="string">&#123;data.key&#125;</span> <span class="attr">key</span>=<span class="string">&#123;</span>`<span class="attr">hero-rodio-</span>$&#123;<span class="attr">data.key</span>&#125;`&#125;&gt;</span></span></span><br><span class="line"><span class="xml">              &#123;data.value&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Radio</span>&gt;</span></span></span><br><span class="line"><span class="xml">          ))&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;heros.filter(item =&gt; filterKey === 0 || item.hero_type === filterKey).reverse().map(item =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Col</span> <span class="attr">key</span>=<span class="string">&#123;item.ename&#125;</span> <span class="attr">span</span>=<span class="string">&#123;3&#125;</span> <span class="attr">className</span>=<span class="string">&#123;styles.heroitem&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;</span>`<span class="attr">https:</span>//<span class="attr">game.gtimg.cn</span>/<span class="attr">images</span>/<span class="attr">yxzj</span>/<span class="attr">img201606</span>/<span class="attr">heroimg</span>/$&#123;<span class="attr">item.ename</span>&#125;/$&#123;<span class="attr">item.ename</span>&#125;<span class="attr">.jpg</span>`&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;item.cname&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Col</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="function">(<span class="params">&#123; hero &#125;: &#123; hero: HeroModelState &#125;</span>) =&gt;</span> (&#123; hero &#125;))(Hero);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好嘞 效果就这样 </p>
<p>我还是彩笔写了这么多都没讲明白自己也没学明白呜呜呜</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react</title>
    <url>/2021/06/09/react/</url>
    <content><![CDATA[<p><strong>写在前面</strong></p>
<p><strong>终于可以重新在新电脑(mbp)上写博客啦 话说为什么我的笔记是直接从react开始的…因为是刚好在学react 所以就先写点总结啦，后面会陆续补上html，css,Js的相关笔记博客的。感觉mos系统也要写点笔记，iterm2的命令行写点总结啥的 有点好用的嗦</strong><br>正式开始react相关笔记啦</p>
<span id="more"></span>
<h1 id="对React的理解"><a href="#对React的理解" class="headerlink" title="对React的理解"></a>对React的理解</h1><h2 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h2><ol>
<li>具体的理解有点说不上来，可能还是自己学太浅来。等后续理解深了用的多了再回来补。按照教程官网学长等各方面说法，react就是通过数据驱动虚拟DOM更新，不需要实际去操作DOM，大部分情况下state有更改那么UI就会出现变化，而state的更改又基于用户的操作，总之很方便。 </li>
<li>运用diff算法最小化重绘页面，加上操作虚拟DOM，就是react高效的两个原因</li>
<li>虚拟DOM其实就是一种特殊的JS一般对象，后续会被react渲染成真实DOM</li>
<li>一般运用JSX语法</li>
</ol>
<h1 id="React基本概念"><a href="#React基本概念" class="headerlink" title="React基本概念"></a>React基本概念</h1><p>概念好像和理解差不多…Emmmmm，那就写点详细的东西</p>
<h2 id="关于JSX"><a href="#关于JSX" class="headerlink" title="关于JSX"></a>关于JSX</h2><ol>
<li><p>全称:  JavaScript XML</p>
</li>
<li><p>react定义的一种类似于XML的JS扩展语法: JS + XML本质是React.createElement(component, props, …children)方法的语法糖</p>
</li>
<li><p>作用: 用来简化创建虚拟DOM </p>
<pre><code> 1)写法：var ele = &lt;h1&gt;; Hello JSX! &lt;/h1&gt;
 2)注意1：它不是字符串, 也不是HTML/XML标签
 3)注意2：它最终产生的就是一个JS对象
</code></pre>
</li>
<li><p>语法规则</p>
</li>
<li><p>jsx语法规则：</p>
<pre><code> 1).定义虚拟DOM时，不要写引号。
 2).标签中混入JS表达式时要用&#123;&#125;。
 3).样式的类名指定不要用class，要用className。
 4).内联样式，要用style=&#123;&#123;key:value&#125;&#125;的形式去写。
 5).只有一个根标签
 6).标签必须闭合
 7).标签首字母
 (1).若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错。
 (2).若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。
</code></pre>
</li>
<li><p>ReactDOM.render(VDOM,RDOM)</p>
</li>
<li><p>语法:  ReactDOM.render(virtualDOM, containerDOM)</p>
</li>
<li><p>作用: 将虚拟DOM元素渲染到页面中的真实容器DOM中显示</p>
</li>
<li><p>参数说明</p>
</li>
</ol>
<p>1)参数一: 纯js或jsx创建的虚拟dom对象<br>2)参数二: 用来包含虚拟DOM元素的真实dom元素对象(一般是一个div)</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h2><p> {里面放的是表达式}，表达式代表着一个值，而for循环啥的叫语句，不会产生值</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件:"></a>组件:</h2><p> <strong>比模块还牛的东西，就对一个页面来说拆就完了，拆到你想不出来这个组件到底能叫什么名字的时候就代表这个组件你已经成功的拆到底了</strong><br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 类式组件</span><br><span class="line">  (1)出hooks之前是主流，基本都用这个，hooks出来后也能用，但最好还是hooks嘛</span><br><span class="line">  (2)一些类的相关知识就详见于JS总结啦</span><br><span class="line">  (3)执行了ReactDOM.render(&amp;lt;MyComponent/&gt;.......之后，发生了什么？</span><br><span class="line">	1.React解析组件标签，找到了MyComponent组件。</span><br><span class="line">	2.发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。</span><br><span class="line">	3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。</span><br><span class="line">   (4)组件里面的render()方法是挂在类的原型对象上的，供组件使用，组件实例对象调用这个方法，那么就是render中的this就指向这个组件实例</span><br><span class="line">2. 函数式组件</span><br><span class="line">  (1)用hooks 贼香 hooks后面有笔记介绍的</span><br><span class="line">  (2)执行了ReactDOM.render(&amp;lt; MyComponent/&gt;.......之后，发生了什么？</span><br><span class="line">	1.React解析组件标签，找到了MyComponent组件。</span><br><span class="line">	2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中</span><br></pre></td></tr></table></figure></p>
<h2 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h2><p>1.表单非受控组件，提交的数据现用现取<br>就是用ref操作实际DOM，比如在表单中输入结束后，给button添加一个函数提交数据</p>
<p>2.表单受控组件，提交的数据存放在state中<br>在HTML的表单元素中，它们通常自己维护一套state，并随着用户的输入自己进行UI上的更新，这种行为是不被我们程序所管控的。而如果将React里的state属性和表单元素的值建立依赖关系，再通过onChange事件与setState()结合更新state属性，就能达到控制用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素就叫做受控组件。</p>
<h2 id="高阶函数和函数的柯里化"><a href="#高阶函数和函数的柯里化" class="headerlink" title="高阶函数和函数的柯里化"></a>高阶函数和函数的柯里化</h2><ol>
<li>当一个函数接受的参数是函数或者返回值是函数，那么这个函数就是高阶函数</li>
<li>柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式（给注册事件的回调函数传参）</li>
<li>不用柯里化的形式：在内莲函数中写一个回调 （）=&gt; func ,这个回调func就作为事件发生时的回调</li>
</ol>
<h1 id="React三大核心属性"><a href="#React三大核心属性" class="headerlink" title="React三大核心属性"></a>React三大核心属性</h1><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><ol>
<li>state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合)</li>
<li>组件被称为”状态机”, 通过更新组件的state来更新对应的页面显示(重新渲染组件)</li>
<li>总之就是 UI里面所有所有的可视改变，背后都代表着一种state某个值的改变，也就是说state中的数据驱动UI视图更新<br>state中的数据不可直接更改，必须利用setState() 方法重新渲染页面，是一个合并的动作而不是替换</li>
</ol>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p><em><strong>概念：</strong></em></p>
<ol>
<li>每个组件对象都会有props(properties的简写)属性</li>
<li>组件标签的所有属性都保存在props中(props也是个对象)</li>
</ol>
<p><em><strong>作用：</strong></em></p>
<ol>
<li>通过标签属性从组件外向组件内传递变化的数据</li>
<li>注意，组件内部不要修改react，广泛用于父子组件传递数据</li>
</ol>
<h2 id="refs与事件处理"><a href="#refs与事件处理" class="headerlink" title="refs与事件处理"></a>refs与事件处理</h2><ol>
<li><p>理解： 一组kv对象,key是refs，value是当前使用ref的一个节点，用于标识节点（可代替id)<br>就是获取当前用ref标识的节点 有点类似于操作真实的DOM了，所以实际开发中最好不要使用，不然容易引起效率问题。</p>
</li>
<li><p>使用</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). 字符串形式 //已经废弃了</span><br><span class="line">&lt;input ref=&quot;input1&quot;/&gt;</span><br><span class="line">(2). 回调形式</span><br><span class="line">&lt;input ref=&#123;(c)=&gt;&#123;this.input1 = c&#125;&#125;/&gt;</span><br><span class="line">(3). createRef</span><br><span class="line">myRef = React.createRef()  &lt;input ref=&#123;this.myRef&#125;/&gt;</span><br><span class="line"></span><br><span class="line">事件处理</span><br><span class="line">三种形式，和原生一样，但最好还是用内联的方式，因为其他两种在操作真实的DOM</span><br><span class="line">a. React使用的是自定义(合成)事件, 而不是使用的原生DOM事件 —————— 为了更好的兼容性</span><br><span class="line">b. React中的事件是通过事件委托方式处理的(委托给组件最外层的元素) ————————为了的高效</span><br></pre></td></tr></table></figure>

<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>新钩子<br><img src="/2021/06/09/react/1.png" alt="1"><br>旧钩子<br><img src="/2021/06/09/react/2.png" alt="2"><br>区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1).废弃了三个钩子</span><br><span class="line">1.componentWillMount</span><br><span class="line">2.componentWillReceiveProps</span><br><span class="line">3.componentWillUpdate</span><br><span class="line">2).重要的钩子</span><br><span class="line">1.render：初始化渲染或更新渲染调用</span><br><span class="line">2.componentDidMount：开启监听, 发送ajax请求，订阅与发布，开启定时器等等</span><br><span class="line">3.componentWillUnmount：做一些收尾工作, 如: 清理定时器</span><br></pre></td></tr></table></figure>



<h1 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h1><p><code>npx create-react-app xx</code><br>即用于快速创建一个基于react模版的项目</p>
<h2 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1.项目结构"></a>1.项目结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ---- 静态资源文件夹</span><br><span class="line">		favicon.icon ------ 网站页签图标</span><br><span class="line">		index.html -------- 主页面</span><br><span class="line">		logo192.png ------- logo图</span><br><span class="line">		logo512.png ------- logo图</span><br><span class="line">		manifest.json ----- 应用加壳的配置文件</span><br><span class="line">		robots.txt -------- 爬虫协议文件</span><br><span class="line">src ---- 源码文件夹</span><br><span class="line">		App.css -------- App组件的样式</span><br><span class="line">		App.js --------- App组件</span><br><span class="line">		App.test.js ---- 用于给App做测试</span><br><span class="line">		index.css ------ 样式</span><br><span class="line">		index.js ------- 入口文件</span><br><span class="line">		logo.svg ------- logo图</span><br><span class="line">		reportWebVitals.js</span><br><span class="line">			--- 页面性能分析文件(需要web-vitals库的支持)</span><br><span class="line">		setupTests.js</span><br><span class="line">			---- 组件单元测试的文件(需要jest-dom库的支持)</span><br></pre></td></tr></table></figure>
<h2 id="2-编码流程"><a href="#2-编码流程" class="headerlink" title="2.编码流程"></a>2.编码流程</h2><ol>
<li>拆分组件: 拆分界面,抽取组件</li>
<li>实现静态组件: 使用组件实现静态页面效果</li>
<li>实现动态组件 3.1 动态显示初始化数据<pre><code> 3.1.1 数据类型
 3.1.2 数据名称
 3.1.2 保存在哪个组件?
</code></pre>
 3.2 交互(从绑定事件监听开始)</li>
</ol>
<h2 id="3-具体项目-详情可见todolist分享"><a href="#3-具体项目-详情可见todolist分享" class="headerlink" title="3.具体项目: 详情可见todolist分享"></a>3.具体项目: 详情可见todolist分享</h2><h1 id="React-AJAX"><a href="#React-AJAX" class="headerlink" title="React AJAX"></a>React AJAX</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>1.React本身只关注于界面, 并不包含发送ajax请求的代码<br>2.前端应用需要通过ajax请求与后台进行交互(json数据)<br>3.react应用中需要集成第三方ajax库(或自己封装)</p>
<h2 id="常用AJAX库"><a href="#常用AJAX库" class="headerlink" title="常用AJAX库"></a>常用AJAX库</h2><p>1.jQuery: 比较重, 如果需要另外引入不建议使用<br>2.axios: 轻量级, 建议使用<br>1)封装XmlHttpRequest对象的ajax<br>2) promise风格<br>3)可以用在浏览器端和node服务器端</p>
<p><strong>关于AJAX/axios和fetch的区别与运用，有一篇专门的博客 去&lt;——搜一下就好啦（可能还放在了GitHub搜索用户里面</strong></p>
<h1 id="React-路由"><a href="#React-路由" class="headerlink" title="React 路由"></a>React 路由</h1><h2 id="1-SPA的理解"><a href="#1-SPA的理解" class="headerlink" title="1.SPA的理解"></a>1.SPA的理解</h2><p>1.单页Web应用（single page web application，SPA）。<br>2.整个应用只有一个完整的页面。<br>3.点击页面中的链接不会刷新页面，只会做页面的局部更新。<br>4.数据都需要通过ajax请求获取, 并在前端异步展现。</p>
<h2 id="2-路由的理解"><a href="#2-路由的理解" class="headerlink" title="2.路由的理解"></a>2.路由的理解</h2><p>1.什么是路由?<br>1.一个路由就是一个映射关系(key:value)<br>2.key为路径, value可能是function或component<br>2.路由分类<br>1.后端路由：<br>1)理解： value是function, 用来处理客户端提交的请求。<br>2)注册路由： router.get(path, function(req, res))<br>3)工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据<br>2.前端路由：<br>1)浏览器端路由，value是component，用于展示页面内容。<br>2)注册路由: <code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code><br>3)工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</p>
<h2 id="3-react-router-dom的理解"><a href="#3-react-router-dom的理解" class="headerlink" title="3.react-router-dom的理解"></a>3.react-router-dom的理解</h2><p>1.react的一个插件库。<br>2.专门用来实现一个SPA应用。<br>基于react的项目基本都会用到此库。</p>
<h2 id="4-内置组件"><a href="#4-内置组件" class="headerlink" title="4.内置组件"></a>4.内置组件</h2><pre><code>    1.&lt;BrowserRouter&gt;
    2.&lt;HashRouter&gt;
    3.&lt;Route&gt;
    4.&lt;Redirect&gt;
    5.&lt;Link&gt;
    6.&lt;NavLink&gt;
    7.&lt;Switch&gt;

    // 其它
    1.history对象
    2.match对象
    3.withRouter函数
</code></pre>
<h1 id="流行的开源React-UI组件库"><a href="#流行的开源React-UI组件库" class="headerlink" title="流行的开源React UI组件库"></a>流行的开源React UI组件库</h1><p>I. material-ui(国外)<br>1.官网: <a href="http://www.material-ui.com/#/">http://www.material-ui.com/#/</a><br>2.github: <a href="https://github.com/callemall/material-ui">https://github.com/callemall/material-ui</a><br>II. ant-design(国内蚂蚁金服)<br>1.官网: <a href="https://ant.design/index-cn">https://ant.design/index-cn</a><br>Github: <a href="https://github.com/ant-design/ant-design/">https://github.com/ant-design/ant-design/</a></p>
<p><code>关于蚂蚁金服的使用请左栏搜索啦</code></p>
<h1 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h1><h2 id="setState更新状态的2种写法"><a href="#setState更新状态的2种写法" class="headerlink" title="setState更新状态的2种写法"></a>setState更新状态的2种写法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). setState(stateChange, [callback])------对象式的setState</span><br><span class="line">    1.stateChange为状态改变对象(该对象可以体现出状态的更改)</span><br><span class="line">    2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用</span><br><span class="line">					</span><br><span class="line">(2). setState(updater, [callback])------函数式的setState</span><br><span class="line">    1.updater为返回stateChange对象的函数。</span><br><span class="line">    2.updater可以接收到state和props。</span><br><span class="line">    4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</span><br><span class="line">总结:</span><br><span class="line">	1.对象式的setState是函数式的setState的简写方式(语法糖)</span><br><span class="line">	2.使用原则：</span><br><span class="line">		(1).如果新状态不依赖于原状态 ===&gt; 使用对象方式</span><br><span class="line">		(2).如果新状态依赖于原状态 ===&gt; 使用函数方式</span><br><span class="line">		(3).如果需要在setState()执行后获取最新的状态数据, </span><br><span class="line">		要在第二个callback函数中读取</span><br></pre></td></tr></table></figure>



<h1 id="lazyLoad"><a href="#lazyLoad" class="headerlink" title="lazyLoad"></a>lazyLoad</h1><h2 id="路由组件的lazyLoad"><a href="#路由组件的lazyLoad" class="headerlink" title="路由组件的lazyLoad"></a>路由组件的lazyLoad</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包</span></span><br><span class="line"><span class="keyword">const</span> Login = lazy(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;@/pages/Login&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面</span></span><br><span class="line">&lt;Suspense fallback=&#123;<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>loading.....<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">       <span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/xxx&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Xxxx&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line">   &lt;/Suspense&gt;</span><br></pre></td></tr></table></figure>


<h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>&lt;Fragment&gt;&lt;Fragment&gt;
&lt;&gt;&lt;/&gt;
</code></pre>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>可以不用必须有一个真实的DOM根标签了</p>
<hr>


<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p> 一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1) 创建Context容器对象：</span></span><br><span class="line">	<span class="keyword">const</span> XxxContext = React.createContext()  </span><br><span class="line">	<span class="keyword">const</span> &#123;Provider,Consumer&#125; = XxxContext</span><br><span class="line">	</span><br><span class="line"><span class="comment">//2) 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：</span></span><br><span class="line">	&lt;xxxContext.Provider value=&#123;数据&#125;&gt;</span><br><span class="line">		子组件</span><br><span class="line">    &lt;/xxxContext.Provider&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3) 后代组件读取数据：</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式:仅适用于类组件 </span></span><br><span class="line">	  <span class="keyword">static</span> contextType = xxxContext  <span class="comment">// 声明接收context</span></span><br><span class="line">	  <span class="keyword">const</span> &#123;value&#125; = <span class="built_in">this</span>.context <span class="comment">// 读取context中的value数据</span></span><br><span class="line">	  </span><br><span class="line">	<span class="comment">//第二种方式: 函数组件与类组件都可以</span></span><br><span class="line">	  &lt;xxxContext.Consumer&gt;</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="function"><span class="params">value</span> =&gt;</span> ( <span class="comment">// value就是context中的value数据</span></span><br><span class="line">	        要显示的内容</span><br><span class="line">	      )</span><br><span class="line">	    &#125;</span><br><span class="line">	  &lt;/xxxContext.Consumer&gt;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><pre><code>在应用开发中一般不用context, 一般都它的封装react插件
</code></pre>
<hr>


<h1 id="组件优化"><a href="#组件优化" class="headerlink" title="组件优化"></a>组件优化</h1><h2 id="Component的2个问题"><a href="#Component的2个问题" class="headerlink" title="Component的2个问题"></a>Component的2个问题</h2><ol>
<li><p>只要执行setState(),即使不改变状态数据, 组件也会重新render()</p>
</li>
<li><p>只当前组件重新render(), 就会自动重新render子组件 ==&gt; 效率低</p>
</li>
</ol>
<h2 id="效率高的做法"><a href="#效率高的做法" class="headerlink" title="效率高的做法"></a>效率高的做法</h2><p> 只有当组件的state或props数据发生改变时才重新render()</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p> Component中的shouldComponentUpdate()总是返回true</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><pre><code>办法1: 
    重写shouldComponentUpdate()方法
    比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false
办法2:  
    使用PureComponent 从&#39;react&#39;中引进
    PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true
    注意: 
        只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  
        不要直接修改state数据, 而是要产生新数据
项目中一般使用PureComponent来优化
</code></pre>
<hr>


<h1 id="render-props-类似于Vue的插槽技术"><a href="#render-props-类似于Vue的插槽技术" class="headerlink" title="render props (类似于Vue的插槽技术 )"></a>render props (类似于Vue的插槽技术 )</h1><h2 id="如何向组件内部动态传入带内容的结构-标签"><a href="#如何向组件内部动态传入带内容的结构-标签" class="headerlink" title="如何向组件内部动态传入带内容的结构(标签)?"></a>如何向组件内部动态传入带内容的结构(标签)?</h2><pre><code>Vue中: 
    使用slot技术, 也就是通过组件标签体传入结构  &lt;AA&gt;&lt;BB/&gt;&lt;/AA&gt;
React中:
    使用children props: 通过组件标签体传入结构
    使用render props: 通过组件标签属性传入结构, 一般用render函数属性
</code></pre>
<h2 id="children-props"><a href="#children-props" class="headerlink" title="children props"></a>children props</h2><pre><code>&lt;A&gt;
  &lt;B&gt;xxxx&lt;/B&gt;
&lt;/A&gt;
xxx会在B组件中用 this.props.children接收
问题: 如果B组件需要A组件内的数据, ==&gt; 做不到 
</code></pre>
<h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><pre><code>&lt;A render=&#123;(data) =&gt; &lt;C data=&#123;data&#125;&gt;&lt;/C&gt;&#125;&gt;&lt;/A&gt;
A组件: &#123;this.props.render(内部state数据)&#125;
C组件: 读取A组件传入的数据显示 &#123;this.props.data&#125; 
</code></pre>
<hr>

<h1 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h1><h2 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h2><p>错误边界：用来捕获后代组件错误，渲染出备用页面</p>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p>
<h2 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h2><p>getDerivedStateFromError配合componentDidCatch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生命周期函数，一旦后台组件报错，就会触发</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">getDerivedStateFromError</span>(<span class="params">error</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    <span class="comment">// 在render之前触发</span></span><br><span class="line">    <span class="comment">// 返回新的state</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">hasError</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentDidCatch</span>(<span class="params">error, info</span>)</span> &#123;  <span class="comment">//是后代组件渲染出错后调用的生命周期函数</span></span><br><span class="line">    <span class="comment">// 统计页面的错误。发送请求发送到后台去</span></span><br><span class="line">    <span class="built_in">console</span>.log(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组件通信方式总结"><a href="#组件通信方式总结" class="headerlink" title="组件通信方式总结"></a>组件通信方式总结</h1><h2 id="方式："><a href="#方式：" class="headerlink" title="方式："></a>方式：</h2><pre><code>    props：
        (1).children props
        (2).render props
    消息订阅-发布：
        pubs-sub、event等等
    集中式管理：
        redux、dva等等
    conText:
        生产者-消费者模式
</code></pre>
<h2 id="组件间的关系"><a href="#组件间的关系" class="headerlink" title="组件间的关系"></a>组件间的关系</h2><pre><code>    父子组件：props
    兄弟组件(非嵌套组件)：消息订阅-发布、集中式管理
    祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(用的少)
</code></pre>
<h1 id="消息订阅与发布机制"><a href="#消息订阅与发布机制" class="headerlink" title="消息订阅与发布机制"></a>消息订阅与发布机制</h1><p>1)import PubSub from ‘pubsub-js’ //引入<br>2)PubSub.subscribe(‘msg’, function(data){ }); //订阅<br>3)PubSub.publish(‘msg’, data) //发布消息</p>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 某个组件中订阅消息</span></span><br><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span> token = PubSub.subscribe(<span class="string">&#x27;msg&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*函数体*/</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卸载组件后取消订阅</span></span><br><span class="line"><span class="function"><span class="title">ComponentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		PubSub.unsubscribe(<span class="built_in">this</span>.token)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//某个组件发布消息</span></span><br><span class="line">PubSub.publish(<span class="string">&#x27;masg&#x27;</span>,data)</span><br><span class="line"><span class="comment">// 一般发过去的是state对象，然后在订阅消息消息的function里面写setstate()</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
</search>
