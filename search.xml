<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Unit14-过渡</title>
    <url>/2021/07/31/CssU14/</url>
    <content><![CDATA[<p>Css U14 学习笔记</p>
<span id="more"></span>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit4-理解浮动</title>
    <url>/2021/06/12/CssU4/</url>
    <content><![CDATA[<p>Css in depth 第四章笔记</p>
<span id="more"></span>


<h1 id="什么是浮动"><a href="#什么是浮动" class="headerlink" title="什么是浮动"></a>什么是浮动</h1><p>就飘起来浮上去呗，在普通文档流中一个块级元素就是占据一行的，添加浮动后下面的元素就都跑到一行来了，满了塞不下了就换行，这就是浮动(我这解释有点破哈)，<br>并且浮动的元素具有行内块元素的特征，并不会保留原先的位置。<br>块级元素的宽=宽度默认情况下和父元素一致，而添加浮动后它的尺寸就根据内容决定了。<br>而设计浮动的初衷其实是为了实现这种效果</p>
<p><img src="/2021/06/12/CssU4/1.png" alt="1"></p>
<p>实现文字包围图片，跟报纸那样的。虽然现在浮动用的不多，很多东西都能代替浮动，比如flex布局，但还是很有必要学习浮动的，因为想要实现把图片移动到浏览器的一侧，或者文字围绕图片，浮动仍然是唯一的选择</p>
<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><h2 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h2><p>父元素容器很多情况下不方便给定高度，子元素添加浮动后又释放了原本的位置，那么父容器就成了一个高度为0且没有内容的容器，会影响下面普通文档流的其他元素，所以就需要清除该浮动带来的副作用。</p>
<p>如果父元素本身有高度则不需要清除浮动，同样，清除浮动后父元素会根据子元素的内容来改变自身的高度，就不会影响后面的标准流(普通文档流)的元素来</p>
<h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><ol>
<li><p>额外标签法(w3c推荐做法)<br>在浮动的元素后面添加一个 <code>&lt;div class=&#39;clear&#39;&gt;</code>,并写上</p>
<pre><code> .clear&#123;
     clear:both;
 &#125;
</code></pre>
</li>
<li><p>给父元素容器添加overflow属性(不是默认值就行)</p>
</li>
<li><p>伪元素法 类似于额外标签法，不过是用伪元素实现，假设父元素容器class=’clearfix’</p>
<pre><code> .clearfix:after&#123;
     content: &#39;&#39;;
     display: block;
     height: 0;
     clear: both;
     visibility: hidden;
 &#125;
</code></pre>
</li>
</ol>
<p>或者用双伪元素法 //用于清除外边距折叠的时候用 因为有了BFC</p>
<pre><code>    .clearfix:before,clearfix:after&#123;
        content: &#39;&#39;;
        display: table;
    &#125;

    .clearfix:after&#123;
        clear: both;
    &#125;
</code></pre>
<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p>哎 上一章刚说的BFC，这一章就提到了，那就简单聊聊吧<br>BFC(块级格式化上下文 (Block Fromatting Context)) 书上的和网上搜的说的都有点怪，我的理解就是在网页中划分一个一个区域，或大或小，每个区域有着自己的内容，不会干涉到其他区域。以下方式会创建一个BFC</p>
<pre><code>     float: left or float: right—anything but none
     overflow: hidden, auto, or scroll—anything but visible
     display: inline-block, table-cell, table-caption, flex, inline-flex,grid, or inline-grid—these are called block containers.
     position: absolute or position: fixed
</code></pre>
<p><strong>Css也有框架，比如bootstrap啥的，也可以学学，</strong></p>
<h1 id="网格系统"><a href="#网格系统" class="headerlink" title="网格系统"></a>网格系统</h1><p><a href="https://www.w3school.com.cn/css/css_grid.asp">网格系统</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit11-背景、阴影、和混合模式</title>
    <url>/2021/06/12/CssU11/</url>
    <content><![CDATA[<p>Css in depth 第四部分高级话题 第十一章笔记</p>
<span id="more"></span>

<h1 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h1><p>首先对background 这个属性有了解</p>
<pre><code>    background-image  //指定一个文件或者生成颜色渐变作为背景图片
    background-position  //设置背景图片的初始位置
    background-size  //指定背景图片的渲染尺寸
    background-repeat  //决定在需要填充整个元素的时候是否平铺图片
    background-origin  //决定背景图片的相对区域(content-box，border-box，默认是padding-box)
    background-clip  //决定背景图片的绘制区域，值和上述一样
    background-attachment  //决定背景图片是否随着页面其余部分的滚动而滚动
    background-color  //指定背景颜色(渲染到背景图片下方)
</code></pre>
<h2 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h2><p>然后我们就知道了渐变其实就是一种背景图片，用background-image 来定义，那如何定义一个渐变？ 这里就要引入 liner-gradient()这个函数了，</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fade</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: liner-gradient (to right,white,blue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下<br><img src="/2021/06/12/CssU11/1.png" alt="01"></p>
<p>该函数有三个参数，第一个是角度，后面两个是起始颜色和终止颜色。<br>对于角度的设置可以为xdeg,比如0deg表示向上渐变，90deg表示向右渐变(顺时针旋转)，还有rad,turn,grad等单位，这里就不详细说了。<br>如果我们采用<br><code>background-image: liner-gradient (to right,red 0%,white 50%,blue 100%);</code><br>就可以实现多颜色渐变并确定它们渐变完成的位置。</p>
<p>如果在同一位置放多种颜色的话 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fade</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>,</span><br><span class="line"> red <span class="number">40%</span>, white <span class="number">40%</span>,</span><br><span class="line"> white <span class="number">60%</span>, blue <span class="number">60%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会出现下图的条纹效果<br><img src="/2021/06/12/CssU11/2.png"></p>
<p>线性渐变还有一种效果就是重复渐变，除了使用的函数repeating-linear-gradient()与线性渐变不同外，其接受参数参数和重复部分的效果都和线性渐变相同</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fade</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">repeating-linear-gradient</span>(-<span class="number">45deg</span>,</span><br><span class="line"> <span class="number">#57b</span>, <span class="number">#57b</span> <span class="number">10px</span>, <span class="number">#148</span> <span class="number">10px</span>, <span class="number">#148</span> <span class="number">20px</span>);</span><br><span class="line"> <span class="attribute">border-radius</span>: <span class="number">0.3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/12/CssU11/Snipaste_2021-06-03_18-49-51.png"></p>
<h2 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h2><p>和线性渐变的从一端沿直线到另一端不同，径向渐变是从一个点开始全方位向外扩展，如图<br><img src="/2021/06/12/CssU11/Snipaste_2021-06-03_18-56-45.png"></p>
<p>该渐变的函数是radial-gradient() ,通过类似于线性渐变函数的参数改变可以产生多种渐变效果，这里因为用的不多就不多说了。</p>
<h1 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h1><p>分为两种，box-shadow / text-shadow。<br>box-shadow的属性值为<br><code>box-shadow: 1em(水平位移) 1em(垂直位移) 2px(模糊半径) 1px(扩展半径) black</code><br>其中模糊半径设置阴影边缘模糊区域(更柔和)，扩展半径使阴影变大或变小</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line"> <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">0.8rem</span>;</span><br><span class="line"> <span class="attribute">color</span>: white;</span><br><span class="line"> <span class="attribute">border-radius</span>: <span class="number">0.5em</span>;</span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to bottom, <span class="number">#57b</span>, <span class="number">#148</span>);</span><br><span class="line"> <span class="attribute">box-shadow</span>: <span class="number">0.1em</span> <span class="number">0.1em</span> <span class="number">0.5em</span> <span class="number">#124</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line"> <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">0</span> <span class="number">0.5em</span> <span class="number">#124</span>,</span><br><span class="line"> inset <span class="number">0</span> <span class="number">0.5em</span> <span class="number">1em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码实现了如图效果<img src="/2021/06/12/CssU11/Snipaste_2021-06-03_19-09-31.png"><br>渐变阴影让元素更立体以及inset 让阴影在内部实现</p>
<h1 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h1><p><em><strong>background-blend-mode</strong></em> 具体不介绍，知道有这么个东西就行，要用到就现查现用</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit2-相对单位</title>
    <url>/2021/06/12/CssU2/</url>
    <content><![CDATA[<p>Css in depth 第二章学习笔记</p>
<span id="more"></span>

<p>接下来开始相对单位的学习啦，因为对于小幸运这种大量适配移动端的网页项目来说，是肯定不能用px这种单位的，直接盲目的学这些相对单位，包括@medium啥的卡了好久，这章节算是帮我捋清了很多东西。</p>
<h1 id="em和rem"><a href="#em和rem" class="headerlink" title="em和rem"></a>em和rem</h1><h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p>em是最常见的相对单位，适于基于特定字号进行排版，在CSS中，1em就等于当前元素的字号。<br>浏览器中默认的字体字号是16px,也就是说再不进行层叠的情况下，1em的值就是16px。其实就是</p>
<pre><code>    body&#123;
        font-size: 16px;
    &#125;
</code></pre>
<p>其余后代元素的font-size会继承这一字号大小(再不加上声明的情况下，这些后代元素也可以用em来定义)，但em会有问题，比如嵌套列表，要不断的用1em覆盖继承来的font-size大小才能解决这一问题，所以我们有更好的选择 rem</p>
<h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>rem,字面上看就是root em,也就是说所有rem都是相对于祖元素的font-size来说的，就不用担心继承的问题了。在DOM树中，html元素是顶级(根)节点，它下面是子节点head和body，再后面就是逐层嵌套的后代节点。根节点是所有其他元素的祖先节点，它有一个伪类选择器(:root)，可以用来选中自己。:root{} === html{}。<br>rem虽然好用，但不是万能的，书里说，CSS关于所有问题的答案只有一种: 看情况。 (真的麻了)<br>所以书里也帮我们总结了一条规律呀:</p>
<p><strong>rem设置字号，px设置边框，em设置其他大部分属性</strong></p>
<h2 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h2><p>这为什么叫反模式我也不清楚，总之就是把默认字号设置成10px(0.625en)，这样就方便计算了，比如什么14px就是1.4em啊啥的，书里不推荐这种方法，因为这其实还是像素思维，脑子里想的一直是大概要多少像素然后写出em，这样其实就根本没有用em的必要，我们用相对单位就是为了在响应式开发中引入一个模糊的概念，也就是到底多少像素不重要，只要在适配屏幕的过程中字体大小等看着舒服就行。书上就说是在跟设计师先规定好根元素的字号后(通常是类似于标题或者页脚的字号)，然后在相对于的地方进行计算。<br>这里就推荐Vscode里面的一个插件！ <strong>px to rem &amp; rpx</strong> 这样编译器会自动帮我们计算哈，偷懒第一人(dog)</p>
<h2 id="构造响应式面板"><a href="#构造响应式面板" class="headerlink" title="构造响应式面板"></a>构造响应式面板</h2><p>顾名思义，就是根据屏幕尺寸的大小来改变网页的字号大小，用媒体查询@media来实现，书上说后面的章节会详细介绍，这里就先不写那么多了。</p>
<h1 id="视口相对单位"><a href="#视口相对单位" class="headerlink" title="视口相对单位"></a>视口相对单位</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>先明白视口的概念:就是浏览器的可视窗口，不包括什么地址栏啊工具栏啊什么的。<br>视口单位有四种:</p>
<pre><code>    vh: 视口高度的1/100
    vw: 视口宽度的1/100
    vmin: 视口宽/高较小的1/100
    vmax: 视口宽/高较大的1/100
    vmin/vmax 用于手机竖屏和横屏变化的情况
</code></pre>
<h2 id="calc-函数"><a href="#calc-函数" class="headerlink" title="calc()函数"></a>calc()函数</h2><p>视口单位一般用于定义div啥的，定义字号会很麻烦，比如屏幕贼大的时候字贼大，屏幕贼小的时候字又贼小，所以为了避免这些极端情况，我们就可以用上calc()函数，该函数内可以对两个极其以上的值进行基本运算，也能结合不同单位。<br>比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">0.5em</span> + <span class="number">1vw</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以保证字体有0.5em的下限不会过小，又有1vw可以随着屏幕增长平滑过渡</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="无单位的值"><a href="#无单位的值" class="headerlink" title="无单位的值"></a>无单位的值</h2><p>有些属性允许无单位，比如line-height,z-index,font-weight(700为bold，400为normal)，而line-height的无单位数值也是相当于字号的相对值，而加上单位可能会出现文字重叠的问题，所以最好不好给行高添加单位</p>
<h2 id="自定义属性-即CSS变量"><a href="#自定义属性-即CSS变量" class="headerlink" title="自定义属性(即CSS变量)"></a>自定义属性(即CSS变量)</h2><p>所谓自定义属性，又叫CSS变量，我们可以声明一个自定义属性，就可以在样式表中的其他地方引用这个值。<br>我们可以这么定义和引用自定义属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    --mian-<span class="attribute">font</span>: Arial,Helvetica;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="built_in">var</span>(--main-font);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义属性的真正意义在于它能够层叠和继承，可以在多个选择器中定义相同的变量，这个变量在不同地方有不同的值。<br>(感觉把这个东西放在react里面用会很高级)</p>
<p>第二章的笔记就到这了，也只是笼统的概述了一下，具体要看后续的学习和实操响应式开发吧，继续加油</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit3-盒模型</title>
    <url>/2021/06/12/CssU3/</url>
    <content><![CDATA[<p>Css in depth 第三章学习笔记</p>
<span id="more"></span>

<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>先了解一下什么是盒模型:<br>就我目前所学的，所谓盒子就是一个一个小区域，用来装内容的，所有可视内容都要放在盒子里，无论是行内，块级还是行内块元素，都可以是盒子模型。<br><img src="/2021/06/12/CssU3/1.png" alt="1"></p>
<p>这是默认的盒子模型，其中盒子的宽高并不影响padding等值，就是可以填充内容区域的高度。<br>而在我们给元素设置为box-sizing: border-box后会改变盒模型<br><img src="/2021/06/12/CssU3/2.png" alt="2"><br>这会让我们能更好的掌控盒模型，因为我们此时设置的宽高就是该盒子整体的宽高，包括padding和border等值。</p>
<p>所以在写CSS的时候还是选择border-box吧，省事嘛。<br>可以全局设置修改盒模型所以在写CSS的时候还是选择border-box吧，省事嘛。<br>可以全局设置修改盒模型</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"><span class="selector-pseudo">::before</span></span><br><span class="line"><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用盒子模型后，对于添加一丢丢内外边距的时候，我们可以不用这么写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    width: 29%;</span><br><span class="line">    magrin-left: 1%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别问，问就是拉，书上给出了一种极为高级的写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    width: calc(30% - 1.5em);</span><br><span class="line">    magrin-left: 1.5em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样不仅能使代码更简单易懂(第一种乍一看看到个29%会感觉莫名其妙)，还能实现不同单位的搭配，% + em ，这谁敢想！？ 总之就是好用就得了，好用且高级。</p>
<h1 id="元素高度问题"><a href="#元素高度问题" class="headerlink" title="元素高度问题"></a>元素高度问题</h1><p>在写项目的时候我们一般不会给盒子限定高度，因为普通的文档流(浏览器默认的布局模型)是为有限的宽度和无限的高度设计的，所以容器的高度应该由其中的内容决定而不能写定。</p>
<h2 id="内容溢出的问题"><a href="#内容溢出的问题" class="headerlink" title="内容溢出的问题"></a>内容溢出的问题</h2><p>如果盒子的高度写死了，里面的内容又太多就会出现内容溢出，对此可以为其添加overflow属性，该属性有四个值</p>
<pre><code>    visible: 默认值，会看见溢出
    hidden: 隐藏溢出内容
    scroll: 容器出现滚动条 不管有没有溢出
    auto: 只有溢出才会出现滚动条
    一般都用auto而不是scroll
</code></pre>
<p>也存在水平溢出的问题，比如一个贼长的url地址，如果让他溢出换行的话会很难看，贼难看，我们就可以用overflow-x单独控制水平溢出(-y单独控制垂直溢出)</p>
<h2 id="百分比高度备选方案"><a href="#百分比高度备选方案" class="headerlink" title="百分比高度备选方案"></a>百分比高度备选方案</h2><p>之前我们知道width和heigh这些可以设置百分比数值，是相对于他们的父元素解析的，所以想在某一个容器上用百分比数值必须确定该容器的父元素对应的属性有明确的值，不然会造成死循环，最好的选择就是用vh啦，当然也有其他的方法，比如<strong>等高列</strong></p>
<p>所谓等高列，就是一行内所有的容器都是等高的，无论增加哪个容器的高度，其余容器都会相应变高，有种苟富贵勿相忘的感觉。实现等高列的方法就是让那些容器自己根据自己的内容决定高度，然后拔高较矮的列就行。 有CSS表格和Flexbox两种方法实现。</p>
<h3 id="CSS表格布局"><a href="#CSS表格布局" class="headerlink" title="CSS表格布局"></a>CSS表格布局</h3><p>表格布局自然就是把父容器的display属性的值设置成table，然后把想要实现等高列的容器的display属性设置为table-cell就行。此时有两个注意点:</p>
<ol>
<li>显示为table的元素宽度不会扩展到100%，所以要写定width: 100%</li>
<li>此时margin值就会失效，等高列之间互相贴合，这时就要用上表格元素的属性 border-spacing来定义单元格之间的间距，该属性接收两个值，分别设置水平间距和垂直间距，但此时直接写的话，由于是水平间距的原因，这就会导致等高列无法跟头部左右两边对齐了，这时就需要在表格容器外面在包一个元素，给他添上一个负的外边距值就可以了，说起来有点复杂，直接看代码</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: -<span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.table</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">border-spacing</span>: <span class="number">1em</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.table-cell</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Felxbox"><a href="#Felxbox" class="headerlink" title="Felxbox"></a>Felxbox</h3><p>还可以用flex布局实现等高列<strong>不考虑兼容性就用 遇事不决flex！！！</strong> ，因为flex布局默认产生等高的元素，只要一句display:flex;就能解决，后续会有更详细的介绍，左侧栏搜索即可啦。</p>
<p>最后 <em><strong>一定不要轻易明确元素的高度！！！</strong></em></p>
<h2 id="min-height和max-height"><a href="#min-height和max-height" class="headerlink" title="min-height和max-height"></a>min-height和max-height</h2><p>我们可以用这两个属性限定元素的高度在一个范围内，类似的是min-width 和 max-width</p>
<h1 id="垂直居中和水平居中"><a href="#垂直居中和水平居中" class="headerlink" title="垂直居中和水平居中"></a>垂直居中和水平居中</h1><p>这部分是个大头，因为能实现的方法太多了，要根据不同的情况给出不同的方法，这里说一些可能会用到的方法，我们先看水平居中，这部分相对于而言比较简单 <strong>因为一般情况下容器的宽度是给定的而高度是未给定的</strong></p>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><p>那么有哪些方法可以实现水平居中呢？</p>
<h3 id="行内元素水平居中"><a href="#行内元素水平居中" class="headerlink" title="行内元素水平居中"></a>行内元素水平居中</h3><p>这个简单，行内元素就是p啊，button啊啥的这写文本内容，就一句text-align: center;就可以了</p>
<h3 id="块级元素水平居中"><a href="#块级元素水平居中" class="headerlink" title="块级元素水平居中"></a>块级元素水平居中</h3><p>定宽的水平居中: 该元素宽度给定的话，就 margin: 0 auto;**</p>
<p>不定宽的水平居: </p>
<ol>
<li>该元素宽度不固定，就给要居中的元素设置display:table; margin: 0 auto; </li>
<li>该元素设置display: inline-block,父元素设置text-align:center;</li>
<li>flex布局: 只需把要处理的块状元素的父元素设置display:flex,justify-content:center;</li>
<li>position + 负margin；</li>
<li>position + margin：auto</li>
<li>position + transform；</li>
</ol>
<p>这里方法4、5、6同下面垂直居中一样的道理，只不过需要把top/bottom改为left/right，在垂直居中部分会详细讲述</p>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="文本-行内元素-垂直居中"><a href="#文本-行内元素-垂直居中" class="headerlink" title="文本(行内元素)垂直居中"></a>文本(行内元素)垂直居中</h3><p>单行:设置paddingtop=paddingbottom；或 设置line-height=height(容器高度)；</p>
<p>多行:通过设置父元素table，子元素table-cell和vertical-align;vertical-align:middle的意思是把元素放在父元素的中部</p>
<h3 id="块级元素垂直居中"><a href="#块级元素垂直居中" class="headerlink" title="块级元素垂直居中"></a>块级元素垂直居中</h3><ol>
<li>flex布局:在需要垂直居中的父元素上，设置display:flex和align-items：center <strong>父元素的height值必须设置</strong></li>
<li>定位子绝父相后，需要居中元素设置top: 50%; margin-top: -(自身高度的一半); 所以这个要设置该垂直居中元素的高度</li>
<li><strong>定位子绝父相后，需要居中元素设置top: 50%; transform: translate(0,-50%) 这个不需要知道该元素自身尺寸</strong>，所以用这个比较好，可能会有兼容性问题</li>
</ol>
<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>其实水平居中垂直居中都是为了这个服务的，因为这样最好，中国人嘛，讲究规整嘿嘿，然后有以下几种方法</p>
<ol>
<li>绝对定位后加 margin: auto, (top/bottom/rigth/left都为0)</li>
<li>绝对定位后 利用上述水平居中/垂直居中的方法4和方法2 </li>
<li>绝对定位后 top: 50%; left: 50%;transform: translate(-50%,-50%),<strong>在未定义尺寸的情况下</strong></li>
<li>flex布局 就是用上述中flex用的水平/垂直居中方法结合就行</li>
<li>table-cell 不喜欢用 就不写了</li>
</ol>
<p>综上 其实还是推荐用flex布局和transform的，但好像都是C3的写法要考虑兼容性，不太清楚，总之看情况来吧。</p>
<p><em><strong>这里明确一下负margin，如果给margin的left或者top设置负值，则元素会相应的向左或者上方移动，若是设置right和bottom为负值，则会将相应位置的后续元素拉过来与自身重叠，在有些地方会有妙有，比如上面说的实现居中的时候，但还是减少使用</strong></em></p>
<h1 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 在CSS中，两个或多个毗邻的普通流中的盒子（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，这种形成的外边距称之为外边距折叠。<br>  关键字：毗邻、两个或多个、垂直方向和普通流</p>
<h2 id="什么时候会发生外边距折叠呢"><a href="#什么时候会发生外边距折叠呢" class="headerlink" title="什么时候会发生外边距折叠呢"></a>什么时候会发生外边距折叠呢</h2><p>普通流中的块级元素的margin-bottom永远和它相邻的下一个块级元素的margin-top叠加，除非相邻的兄弟元素clear<br>普通流中的块级元素（没有border-top、没有padding-top）的margin-top和它的第一个普通流中的子元素（没有clear）发生margin-top叠加<br>普通流中的块级元素（height为auto、min-height为0、没有border-bottom、没有padding-bottom）和它的最后一个普通流中的子元素（没有自身发生margin叠加或clear）发生margin-bottom叠加<br>如果一个元素的min-height为0、没有border、没有padding、高度为0或者auto、不包含子元素，那么它自身的外边距会发生叠加</p>
<h2 id="外边距折叠的大小"><a href="#外边距折叠的大小" class="headerlink" title="外边距折叠的大小"></a>外边距折叠的大小</h2><pre><code> 1.两个相同大小的正数：取某个外边距的值。即30px与30px发生折叠，折叠后的值为30px。
 2.两个不同大小的正数：取较大的外边距的值。即30px与20px发生折叠，折叠后的值为30px。
 3.一正一负：取正数与负数的和。即30px与-20px发生折叠，折叠后的值为10px。
 4.相同大小的负数：同相同大小正数。-30px与-30px折叠，折叠后为-30px。
 5.不同大小负数： 取绝对值较大的负数。-30px与-20px折叠，折叠后为-30px。
</code></pre>
<h2 id="避免外边距的方法"><a href="#避免外边距的方法" class="headerlink" title="避免外边距的方法"></a>避免外边距的方法</h2><ol>
<li>对容器添加overflow: auto , 防止内部元素的外边距与容器外部外边距折叠，这种方法副作用最小</li>
<li>在发生折叠的外边距之间加上边框或者内边距</li>
<li>如果容器为浮动元素，行内块元素，绝对定位或者固定定位时</li>
<li>使用Flexbox布局或者网格布局</li>
<li>元素显示为, table-cells, table-row等</li>
</ol>
<p>即，创建了BFC的元素不会发生外边距折叠的问题，关于BFC请<a href="https://www.cnblogs.com/libin-1/p/7098468.html">点击这里</a></p>
<h1 id="猫头鹰选择器"><a href="#猫头鹰选择器" class="headerlink" title="猫头鹰选择器 * + *"></a>猫头鹰选择器 * + *</h1><p>叫这个名字的原因无它 就是因为长的像猫头鹰而已，其中 +： 相邻兄弟选择器（Adjacent sibling selector）可选择紧接在另一元素后的元素，且二者有相同父元素。<br>猫头鹰选择器会选中<strong>页面上有着相同父元素的非第一个子元素</strong>(比如ul里面会选择第二个往后的所有li)<br>一般用于给他们添加一个统一的margin-top解决边距问题</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* + * &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最后，有:</p>
<ol>
<li><em><strong>tag + tag 会选择除第一个tag之外的所有tag</strong></em></li>
<li><em><strong>因为’margin-left’ + ‘border-left-width’ + ‘padding-left’ + ‘width’ + ‘padding-right’ +’border-right-width’ + ‘margin-right’ = width of containing block ，在我们只设置了margin-left: auto 后为满足上式 ，就有margin-left =  width,故元素会直接到容器的最右边</strong></em></li>
</ol>
<p> ok 第三章的笔记就到这，书上的基础部分也结束了，接下来就到了关键的布局咯</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit7-定位和层叠上下文</title>
    <url>/2021/06/12/CssU7/</url>
    <content><![CDATA[<p>Css in depth 第七章笔记</p>
<span id="more"></span>


<p>前面介绍的几种布局方式都是按照display属性来的，这次介绍的定位是由 position 决定，position属性的初始值是static，一旦这个值被改变来我们就说这个元素被定位了，接下来就了解一下定位的具体方式吧</p>
<h1 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h1><p>因为固定定位用的较少，就先从它开始了。<br>固定定位的属性值就是 position:fixed;<br>还需要搭配 top/bottom/left/right 四个属性，这些属性决定了定位元素和浏览器视口的距离，这四个值还隐式的定义了元素的宽高，比如指定left:2em;right:2em;则元素的宽度就是浏览器视口减去4em。<br>被固定定位后的元素会固定在浏览器视口的某个位置，并脱离原本的位置。(广告啊弹窗啥的)</p>
<h1 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h1><p>首先绝对定位不像固定定位的元素那样相对于浏览器视口实现边偏移(top/bottom/right/left)，它是相对于自身的被定位的祖先元素(有爹找爹没爹找爷)来说的，如果没有祖先元素才会找到浏览器，添加了绝对定位的元素也会释放原来的位置。绝对定位经常和Js配合实现下拉菜单，消息盒子，工具提示等功能，在这之前，我们先看看它必须得有的搭档，相对定位</p>
<h1 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h1><p>被相对定位的元素是相对于自身原本占有的位置进行移动的，会保留原本拥有的位置。但添加了相对定位的元素我们不会移动它，我们会把它当作绝对定位元素的祖先容器，这就是所谓的<strong>子绝父相</strong><br>因为添加绝对定位的子元素可以放在父容器的任何地方，同时释放自身原有位置也不会影响其他兄弟元素的位置，而容器盒子需要添加一个定位限制住子盒子定位在自身内部，最后容器盒子布局需要在标准流中占一个位置，因此就有了子绝父相这句话的由来。</p>
<h1 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h1><p>定位多了都脱离原来位置了，就容易发生层叠，用z-index属性就好，可以理解为一个z轴嘛，值越大z坐标越高元素位置越高，就不会被其他元素覆盖层叠了。</p>
<h1 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h1><p>粘性定位是固定定位和相对定位的结合，把被粘性定位定位后的某元素固定在浏览器某个位置，一开始会随着浏览器视口的滚动而滚动，到达特定位置后就不会再变了，占有原先位置。</p>
<p>定位到这也就结束啦x</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit1-层叠，优先级，继承</title>
    <url>/2021/06/12/CssU1/</url>
    <content><![CDATA[<p>从现在开始系统学习Css啦，也就是把css in depth 好好看一遍，这是第一单元的笔记</p>
<span id="more"></span>

<h1 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>先理解CSS中的C(Cascading)，层叠:<br>CSS样式在针对同一元素配置同一属性时，依据层叠规则（权重）来处理冲突，选择应用权重高的CSS选择器所指定的属性，一般也被描述为权重高的覆盖权重低的，因此也称作层叠。</p>
<p>而CSS的本质就是声明规则，即在各种条件下产生我们所希望的特定效果。在一份庞大的工作项目中,CSS代码就会变得很复杂，因为在CSS里实现同一种效果会有好几种不同的方式，而当HTML的结构发生改变后，这些不同的CSS实现方式又会产生不同的结果，浏览器在解释这部分样式规则的时候，可能会出现一个元素应用多个规则，这时就会产生<strong>冲突</strong>。</p>
<p>所以层叠大体上就上应对这种冲突情况产生的一种解决规则，层叠有三个条件:</p>
<pre><code>    1.样式表的来源：样式来源，包括自己的CSS文件和浏览器默认(用户代理)样式
    2.选择器优先级：哪些选择器的权重
    3.源码顺序：CSS代码块里面的声明顺序 
    // !important声明权重最高，内联style样式其次
</code></pre>
<p>浏览器就会根据以上三条规则按顺序解析CSS从而解决冲突问题。</p>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><h2 id="选择器的权重"><a href="#选择器的权重" class="headerlink" title="选择器的权重"></a>选择器的权重</h2><pre><code>    #id -- 100
    .class -- 10
    tag -- 1
    // 伪类选择器和属性选择器的权重和类选择器一致，通配符*和组合器(&gt;/+/~)对优先级权重没有影响
</code></pre>
<h2 id="关于解决冲突的一些方法"><a href="#关于解决冲突的一些方法" class="headerlink" title="关于解决冲突的一些方法"></a>关于解决冲突的一些方法</h2><p>有以下代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#main</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;featured&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>想要让最后一个li变成蓝色，有几种方法可以实现呢？</p>
<p>最简单的当然就是用!important 或者 内联的style样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#main</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.featured</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: blue <span class="meta">!important</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;featured&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;background-color: blue&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但最简单同样也是最不推荐的，应为这样写的话在一些需求大量的CSS中可能会引起很多未知的Bug(比如太多的important让一切冲突回到原点)</p>
<p>所以我们选择提升最后一个li选择器的优先级。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#main</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span></span><br><span class="line"><span class="css">    <span class="selector-id">#main</span> <span class="selector-class">.featured</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>到这一步了，我们来个逆向思维，降低其他li的选择器优先级也是一个方法,我们给ul添加一个class，用class选择器代替id选择器<br><strong>这第三种方法也是 Css in depth 最推荐的一种方法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.class</span> <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.class</span> <span class="selector-class">.featured</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;featured&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后一个方法就是按照层叠条件的第三点来了，也就是源码顺序，把两个声明的优先级放到一致，后声明的样式会覆盖前面的样式，这里也不太推荐使用，因为只会覆盖同名的属性，也会造成很多不一致的样式Bug，就不放代码细述了。</p>
<h2 id="a的伪类选择器"><a href="#a的伪类选择器" class="headerlink" title="a的伪类选择器"></a>a的伪类选择器</h2><p>除开几种基础选择器外，还有一些复合选择器，像什么后代选择啊，子选择，并集选择，伪类选择。这里我们就说一下关于a标签伪类选择器的优先级问题。<br>a标签的伪类选择有四种</p>
<pre><code>    a:link   选择未被访问的
    a:visited 选择已被访问的
    a:hover 选择鼠标悬停的
    a:active 选择鼠标按下未弹起的
</code></pre>
<p>关于这四种伪类选择器的优先级，记住 LVHA的顺序 (LV包Hao)即可</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这里先明白一个概念，层叠值:<br><strong>层叠值就是作为层叠结果，应用到一个元素上的特定属性的值</strong><br>大白话说就是几个规则都被用于渲染一个元素啊，比武招亲，这叫冲突，然后打架嘛，最后只有一个人获胜，也就是只有一条CSS声明的属性能赢，一夫一妻嘛，这个赢了的声明属性就叫层叠值。<br>还要注意不要过度的使用id选择器和!important规则。这点之前也提到过，因为这些权重很高，很难覆盖，除了可能会引起一些麻烦外，对于后续的修改优化工作也有很大的阻挠。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>除了内联，引入Css文件，用户代理等外，这里还有最后一种给HTML元素添加样式的方法，就是<strong>继承</strong>。<br>首先我们都知道，HTML就是个DOM树。<br>![01](./CssU1/1 .png)<br>当我们给body元素添加font-family时，body以下所有的子节点都会继承这个字体，但不是所有属性都能被继承，一般情况下，能被继承的属性有: 文本相关:<strong>color, font, font-family, font-size, font-weight, font-variant,font-style, line-height, letter-spacing, text-align, text-indent, text-transform,white-space, and word-spacing.</strong>  再比如列表属性:<strong>list-style, list-style-type, list-style-position, and list-style-image.</strong> 以及表格的边框属性:<strong>border-collapse and border-spacing,</strong> (这是控制的边框行为)。</p>
<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><p>有inherit(继承)和initial(初始)两个特殊值可以赋给任意属性，比如一般情况下我们会给一个网页里面所有的a添加一个字体颜色，但放在页脚的颜色却不能那么显眼，我们就可以</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哎，这里就会问，为什么不直接把页脚的a设置成灰色呢，嗯我也在想，书上说这样继承的话可以直接通过修改.footer里面的值来改变页脚链接的文本颜色，唉可能是我还没有接触到太复杂的页面所以没啥感觉吧呜呜呜。但要注意，<strong>继承的优先级连标签选择器都比不上</strong><br>接下来就是initial，也很好理解，就是把属性的值设置为初始值，一般用于重置一个属性，但有以下几点需要注意以下:</p>
<ol>
<li>不要习惯用auto重置，有些属性的默认值是auto，比如width，但auto对很多属性来说是不合法对值，比如padding等、</li>
<li>display的初始值是inline，无论哪种元素的display初始值都是inline，所以小心对display用initial</li>
</ol>
<h2 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h2><p>这里提一下简写属性，就是把很多属性放到同一个属性名下，比如用font来写font-style,font-weight等<br><code>font: italic bold 18px/1.2 &quot;Helvetica&quot;, &quot;Arial&quot;, sans-serif;</code><br>但这种我不喜欢用，主要是记不住顺序，Emmmm，还是写的少了….估计写多点就能记得住了。(尽管它会包容你的顺序错误TnT)</p>
<p>唯一能记得住的简写方式就是一些表大小或位置的属性，比如border-width,这种后面可以跟四个值，分别代表上右下左(顺时针方向),三个值就是上 左右 下，两个就是上下 左右，一个则设置上下左右。</p>
<p>但要注意，有部分的属性后面的值和上右下左的方向刚好相反，比如background-position, box-shadow,和text-shadow，比如他们后面跟两个值的话，就是先指定左右，再指定上下。书上说相反的原因很简单，按照笛卡尔网格来，按照x,y测量啥的，我就理解为阴影嘛，就跟光影差不多，初中物理就知道呈的是倒立的虚像，所以就反着来呗.</p>
<p>至此第一章就结束来…写的还满多的….</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Unit5-Flexbox</title>
    <url>/2021/06/12/CssU5/</url>
    <content><![CDATA[<p>Css in depth 第五章 flexbox 的学习笔记</p>
<span id="more"></span>


<h1 id="Flexbox-原则"><a href="#Flexbox-原则" class="headerlink" title="Flexbox 原则"></a>Flexbox 原则</h1><p>从display属性开始，当我们给一个元素添加display:flex后，该容器就会变成一个弹性容器，它的直接子元素就变成了弹性子元素，弹性子元素默认是在同一行按照从左到右的顺序并排排列。 弹性容器和块级容器一样自动填满可用的宽度，但弹性子元素不一定会填满容器的宽度弹性子元素高度相等，该高度由他们的内容决定。</p>
<p>然后弹性容器里面有两个坐标轴，主轴为水平x(默认，从左到右)和副轴y(从上到下)，子元素就会默认沿主轴排列，并成等高列形式。</p>
<h1 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h1><p>接下来就要看看flex布局的属性了，这部分是核心，了解他们才能熟练掌握flex布局，接下来先看看容器属性，也就是通过在弹性容器中设置属性来操纵弹性子元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. flex-direction: 设置主轴方向</span><br><span class="line">&#123;</span><br><span class="line">    row  //默认</span><br><span class="line">    row-reverse  //从右到左</span><br><span class="line">    column  //从上到下</span><br><span class="line">    column-reverse //从下到上</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. justify-content: 设置主轴上子元素排列方式</span><br><span class="line">&#123;</span><br><span class="line">    flex-start  //默认</span><br><span class="line">    flex-end  //从尾部开始</span><br><span class="line">    center  //居中对齐</span><br><span class="line">    space-around //平分剩余空间</span><br><span class="line">    space-between //先两边贴合 再平分剩余空间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3. flex-warp: 设置子元素是否换行</span><br><span class="line">&#123;</span><br><span class="line">    nowarp  //默认不换行</span><br><span class="line">    wrap  //换行</span><br><span class="line">    wrap-reverse  //换行，第一行往下</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. align-items: 设置侧轴子元素排列方式 (单行)</span><br><span class="line">&#123;</span><br><span class="line">    flex //侧轴默认方向</span><br><span class="line">    flex-end  //默认反向</span><br><span class="line">    center  //居中</span><br><span class="line">    stretch  //拉伸(默认)</span><br><span class="line">    baseline  //取内容第一行文字基线对齐</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5. align-content: 设置侧轴子元素排列方式(多行)</span><br><span class="line">&#123;</span><br><span class="line">    其他属性和单行相同，多了space-around 和 space-bettwen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6. flex-flow 同时设置 flex-direction 和 flex-warp </span><br></pre></td></tr></table></figure>

<h1 id="item-属性"><a href="#item-属性" class="headerlink" title="item 属性"></a>item 属性</h1><p>接下来再看看子相属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order 定义项目排列顺序 数值越小 排列越靠前</span><br><span class="line">flex-basis 定义了该item(弹性子元素)尺寸的基准值，默认是auto，即项目由本身内容决定的尺寸，该值可以是任意width单位值，</span><br><span class="line">flex-grow  每个item的增长比例，即用于平分剩余空间时所占的比例</span><br><span class="line">flex-shrink  每个item的缩小比例 即内容溢出后所占的缩小比例</span><br><span class="line">flex： flex-gorw，flex-shrink，flex-basis 的合写</span><br><span class="line">align-self 用于设置单个item的对齐方式，可以覆盖align-items 值与其相等</span><br></pre></td></tr></table></figure>

<p>Okey Flex到此为止咯</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>HOC | render props | hook</title>
    <url>/2021/09/14/HOC-render-props-hook/</url>
    <content><![CDATA[<p>react的中 对于一些复用的节点，我们可以抽成一个组件，而对于一些复用的逻辑，我们也可以抽象化这个逻辑来优化代码，主要有三种方法，HOC，render props，和自定义hook</p>
<span id="more"></span>

<h1 id="HOC"><a href="#HOC" class="headerlink" title="HOC"></a>HOC</h1><p>HOC 就是高阶组件吗，之前有博客介绍了的，虽然写的有点烂但我这里就不赘述了，这里用一个计数器的demo，直接上高阶组件实现计数器的代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;View, Text,Button&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Count</span>(<span class="params">&#123;count,add,minus&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flex:1,alignItems:</span>&#x27;<span class="attr">center</span>&#x27;,<span class="attr">justifyContent:</span>&#x27;<span class="attr">center</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Text</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;add&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">add</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;minus&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">minus</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;changeTheme&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">ChangeTheme</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> countNumber=<span class="function">(<span class="params">initNumber</span>)=&gt;</span> <span class="function">(<span class="params">WrappedComponent</span>)=&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CountNumber</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        state = &#123;<span class="attr">count</span>: initNumber&#125;;</span><br><span class="line">        add = <span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span>&#125;);</span><br><span class="line">        minus = <span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>: <span class="built_in">this</span>.state.count - <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                &#123;<span class="attr">...this.props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">count</span>=<span class="string">&#123;this.state.count&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">add</span>=<span class="string">&#123;this.add.bind(this)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">minus</span>=<span class="string">&#123;this.minus.bind(this)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            /&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> countNumber(<span class="number">0</span>)(Count);</span><br></pre></td></tr></table></figure>
<p>优点:<br>可以看到，高阶组件是把逻辑和UI分开了，Count组件指负责渲染UI，被传入HOC中才有了计数的逻辑，这很好的维护了内层组件的状态，降低了耦合度<br>缺点:</p>
<ol>
<li>注意一下HOC的state是写死的，也就是说传入给Count组件的prop是写死的，这就有可能产生命名冲突，覆盖掉Count组件原有的props</li>
<li>HOC是链式调用，会导致错误难以定位</li>
</ol>
<h1 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h1><p>先直接上代码</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;View, Text,Button&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">RenderProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flex:1,alignItems:</span>&#x27;<span class="attr">center</span>&#x27;,<span class="attr">justifyContent:</span>&#x27;<span class="attr">center</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">CountNumber</span> <span class="attr">initNumber</span>=<span class="string">&#123;0&#125;</span> <span class="attr">render</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    (&#123;<span class="attr">count</span>,<span class="attr">add</span>,<span class="attr">minus</span>&#125;)=&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Text</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;add&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">add</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;minus&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">minus</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;changeTheme&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">ChangeTheme</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">                &#125;&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">CountNumber</span>&gt;</span></span></span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountNumber</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    state=&#123;<span class="attr">count</span>:<span class="built_in">this</span>.props.initNumber&#125;;</span><br><span class="line">    add=<span class="function">()=&gt;</span><span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span>&#125;);</span><br><span class="line">    minus=<span class="function">()=&gt;</span><span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count-<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.props.render(&#123;</span><br><span class="line">            <span class="attr">count</span>: <span class="built_in">this</span>.state.count,</span><br><span class="line">            <span class="attr">add</span>: <span class="built_in">this</span>.add,</span><br><span class="line">            <span class="attr">minus</span>:<span class="built_in">this</span>.minus</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样也实现了逻辑复用，还留下了一个“插槽”，也就是预留位置，缺点就是不能在return语句外访问数据，同时用的过多的话会跟HOC差不多，HOC是过长的链式调用形成异常栈，而render props则会形成潜逃地狱</p>
<h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><p>最后看一看最新的自定义hook</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;View, Text,Button&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,addCount,minusCount] = useCountNumber(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;backgroundColor:theme,flex:1,alignItems:</span>&#x27;<span class="attr">center</span>&#x27;,<span class="attr">justifyContent:</span>&#x27;<span class="attr">center</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Text</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;addCount&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">add</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;minusCount&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">minus</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;changeTheme&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">ChangeTheme</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCountNumber</span>(<span class="params">initNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(initNumber);</span><br><span class="line">    <span class="keyword">const</span> addCount=<span class="function">()=&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> minusCount=<span class="function">()=&gt;</span>setCount(count -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        count,</span><br><span class="line">        addCount,</span><br><span class="line">        minusCount</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>反正 hook作为最新的语法，最好还是多用他，但也不能完全代替</p>
<ul>
<li>Hooks：<ul>
<li>替代 Class 的大部分用例，除了 getSnapshotBeforeUpdate 和 componentDidCatch 还不支持。</li>
<li>提取复用逻辑。除了有明确父子关系的，其他场景都可以使用 Hooks。</li>
</ul>
</li>
<li>Render Props：在组件渲染上拥有更高的自由度，可以根据父组件提供的数据进行动态渲染。适合有明确父子关系的场景。</li>
<li>高阶组件：适合用来做注入，并且生成一个新的可复用组件。适合用来写插件。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Router base</title>
    <url>/2021/06/12/Router-base/</url>
    <content><![CDATA[<p>一篇关于使用路由的Blog</p>
<span id="more"></span>
<h1 id="路由简介"><a href="#路由简介" class="headerlink" title="路由简介"></a>路由简介</h1><p>在之前的react笔记中，我们已经简单的了解过路由</p>
<h2 id="1-SPA的理解"><a href="#1-SPA的理解" class="headerlink" title="1.SPA的理解"></a>1.SPA的理解</h2><p>1.单页Web应用（single page web application，SPA）。<br>2.整个应用只有一个完整的页面。<br>3.点击页面中的链接不会刷新页面，只会做页面的局部更新。<br>4.数据都需要通过ajax请求获取, 并在前端异步展现。</p>
<h2 id="2-路由的理解"><a href="#2-路由的理解" class="headerlink" title="2.路由的理解"></a>2.路由的理解</h2><ol>
<li>什么是路由?<br>一个路由就是一个映射关系(key:value)<br>key为路径, value可能是function或component</li>
<li>路由分类<br>后端路由：</li>
</ol>
<p>1)理解： value是function, 用来处理客户端提交的请求。<br>2)注册路由： router.get(path, function(req, res))<br>3)工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据<br>前端路由：<br>1)浏览器端路由，value是component，用于展示页面内容。<br>2)注册路由:<br><code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code><br>3)工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</p>
<h2 id="3-react-router-dom的理解"><a href="#3-react-router-dom的理解" class="headerlink" title="3.react-router-dom的理解"></a>3.react-router-dom的理解</h2><ol>
<li>react的一个插件库。</li>
<li>专门用来实现一个SPA应用。<br>基于react的项目基本都会用到此库。</li>
</ol>
<h2 id="4-内置组件"><a href="#4-内置组件" class="headerlink" title="4.内置组件"></a>4.内置组件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.&lt;BrowserRouter&gt; //支持H5history，用于包裹顶层组件，监听该组件中URL的变化，管理路由</span><br><span class="line">2.&lt;HashRouter&gt; //作用与前者相同，但使用URL的hash部分，不支持location.key或location.state</span><br><span class="line">3.&lt;Route&gt; //负责把一般组件注册为路由组件</span><br><span class="line">4.&lt;Redirect&gt; //类似与default，所有路径都不被匹配时就用它指定的路由组件</span><br><span class="line">5.&lt;Link&gt; // 前往路由组件，代替&lt;a&gt;标签</span><br><span class="line">6.&lt;NavLink&gt; // 与&lt;Link&gt;相同，不过会给点击后的链接默认添加一个active类名，与bootstrap联用实现</span><br><span class="line">高亮效果，具体样式可以自己封装</span><br><span class="line">7.&lt;Switch&gt; // 实现单一匹配，</span><br><span class="line"></span><br><span class="line">// 其它</span><br><span class="line">1.history对象</span><br><span class="line">2.match对象</span><br><span class="line">3.withRouter函数</span><br><span class="line">4.Route组件中exact属性的作用：路径进行精确匹配，不会存在包含关系</span><br></pre></td></tr></table></figure>

<p>这里我们可以简略的说一下路由的发展哈<br><strong>最早的最早，用户加载网页，是要等整个页面全部加载完才行，很麻烦很耗时间，后来呢，微软就搞了AJAX的基本概念，也就是XMLHttpRequest的前身，有了AJAX后，用户就不需要每次载完了，比如图片GIF什么的加载慢，就先往后靠靠，我看会儿文字，而不是等你图片加载好我才能看到文字。再后来，Google Map展现了AJAX的真正魅力，让其不仅仅局限于简单的数据和页面交互，为后来异步交互体验方式的繁荣发展带来了根基。</strong></p>
<p><strong>而异步交互体验的更高级版本就是 SPA—— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。</strong></p>
<h1 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h1><p>先要从’react-router-dom’中引入所需要的。</p>
<h2 id="用-lt-Link-gt-代替-lt-a-gt"><a href="#用-lt-Link-gt-代替-lt-a-gt" class="headerlink" title="用&lt;Link &gt; 代替&lt;a &gt;"></a>用&lt;Link &gt; 代替&lt;a &gt;</h2><p>原生Html中，用a标签实现不同页面的跳转：</p>
<p><code>&lt;a herf=&#39;/path&#39;&gt;tab&lt;/a&gt;</code></p>
<p>而在路由中就该用Link实现单页面跳转：</p>
<p><code>&lt;Link to=&#39;/&#39;&gt;tab&lt;/Link&gt;</code></p>
<p>to的值应和路由组件的path一致达成匹配</p>
<p><strong>&lt;NavLink&gt;中有个属性是activeClassName,默认是active，修改它的值就可以做到给点击的链接添加一个修改内容的类名</strong></p>
<h2 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h2><p>确定好要跳转的组件后，用Route把一般组件注册成路由组件，路由组件因为类似一个单页面，就要把他们放在一个名为pages的文件夹中和一般组件区分开。<br>然后再用Switch包裹这些路由组件，实现单一匹配。(防止一个路径匹配多个组件出现bug)<br>最后可以加上Redirect，表示默认</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span></span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;/</span>&gt;</span></span> <span class="comment">//这个就不会被显示</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Redireact</span> <span class="attr">to</span>=<span class="string">&#x27;/about&#x27;</span>/&gt;</span></span></span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<p>别忘了添加路由器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span></span><br><span class="line">&lt;/BrowserRouter&gt;,</span><br></pre></td></tr></table></figure>

<h2 id="路由组件接收到到参数"><a href="#路由组件接收到到参数" class="headerlink" title="路由组件接收到到参数"></a>路由组件接收到到参数</h2><p>路由组件会默认接到三个props</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     history:</span><br><span class="line">         go: f go(n); // n就是跳转到第几个浏览页面，可以是负数</span><br><span class="line">         goBack: f gouBack();</span><br><span class="line">         goForward: f goForWard();</span><br><span class="line">         push: f push(path,state); //state就是指下文的state参数</span><br><span class="line">         repalce: f replace)(path,state);</span><br><span class="line"></span><br><span class="line">     location:</span><br><span class="line">         pathname: &quot;/aboplut&quot;</span><br><span class="line">search: &quot;&quot;</span><br><span class="line">state: undefined</span><br><span class="line"></span><br><span class="line">     match:</span><br><span class="line">         params: &#123;&#125;</span><br><span class="line">         path: &quot;/about&quot;</span><br><span class="line">         url: &quot;/about&quot;</span><br></pre></td></tr></table></figure>

<h2 id="嵌套路由-多级路由"><a href="#嵌套路由-多级路由" class="headerlink" title="嵌套路由(多级路由)"></a>嵌套路由(多级路由)</h2><ol>
<li>注册子路由时要写上父路由的path值</li>
<li>路由的匹配是按照注册路由的顺序进行的</li>
</ol>
<h2 id="解决多级路径刷新页面样式丢失的问题"><a href="#解决多级路径刷新页面样式丢失的问题" class="headerlink" title="解决多级路径刷新页面样式丢失的问题"></a>解决多级路径刷新页面样式丢失的问题</h2><ol>
<li>public/index.html 中 引入样式时不写 ./ 写 / （常用）</li>
<li>public/index.html 中 引入样式时不写 ./ 写 %PUBLIC_URL% （常用）</li>
<li>使用HashRouter</li>
</ol>
<h2 id="路由的严格匹配与模糊匹配"><a href="#路由的严格匹配与模糊匹配" class="headerlink" title="路由的严格匹配与模糊匹配"></a>路由的严格匹配与模糊匹配</h2><ol>
<li>默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致）</li>
<li>开启严格匹配：&lt;Route exact={true} path=”/about” component={About}/ &gt;</li>
<li>严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由</li>
</ol>
<h2 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a>向路由组件传递参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.params参数</span><br><span class="line">路由链接(携带参数)：&lt;Link to=&#x27;/demo/test/tom/18&#x27;&#125;&gt;详情&lt;/Link&gt;</span><br><span class="line">注册路由(声明接收)：&lt;Route path=&quot;/demo/test/:name/:age&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">接收参数：this.props.match.params</span><br><span class="line"></span><br><span class="line">2.search参数/query参数</span><br><span class="line">路由链接(携带参数)：&lt;Link to=&#x27;/demo/test?name=tom&amp;age=18&#x27;&#125;&gt;详情&lt;/Link&gt;</span><br><span class="line">注册路由(无需声明，正常注册即可)：&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">接收参数：this.props.location.search</span><br><span class="line">备注：获取到的search是urlencoded编码字符串，需要借助querystring解析</span><br><span class="line">                </span><br><span class="line">3.state参数</span><br><span class="line">路由链接(携带参数)：&lt;Link to=&#123; &#123; pathname:&#x27;/demo/test&#x27;,state:&#123; name:&#x27;tom&#x27;,age:18 &#125; &#125; &#125;&gt;详情&lt;/Link&gt; 且不在地址栏上显示</span><br><span class="line">注册路由(无需声明，正常注册即可)：&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;/&gt;</span><br><span class="line">接收参数：this.props.location.state</span><br><span class="line">备注：刷新也可以保留住参数(和浏览器的history有关，如果历史记录被清空则刷新就会丢失参数)</span><br></pre></td></tr></table></figure>

<h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><p>就是把一个一般组件加工，让其可以使用一些路由组件的API，比如props.history<br>用法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;withRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom-router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某组件Demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Demo)</span><br></pre></td></tr></table></figure>
<p>这样Demo组件就变成了一个新组件，不同于一般组件和路由组件</p>
<h2 id="BrowserRouter与HashRouter的区别"><a href="#BrowserRouter与HashRouter的区别" class="headerlink" title="BrowserRouter与HashRouter的区别"></a>BrowserRouter与HashRouter的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.底层原理不一样：</span><br><span class="line"></span><br><span class="line">		BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。</span><br><span class="line">		HashRouter使用的是URL的哈希值。</span><br><span class="line"></span><br><span class="line">2.path表现形式不一样</span><br><span class="line"></span><br><span class="line">	    BrowserRouter的路径中没有#,例如：localhost:3000/demo/test</span><br><span class="line">		HashRouter的路径包含#,例如：localhost:3000/#/demo/test</span><br><span class="line"></span><br><span class="line">3.刷新后对路由state参数的影响</span><br><span class="line">		(1).BrowserRouter没有任何影响，因为state保存在history对象中。</span><br><span class="line">		(2).HashRouter刷新后会导致路由state参数的丢失！！！</span><br><span class="line">			</span><br><span class="line">4.备注：HashRouter可以用于解决一些路径错误相关的问题。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>Regexp</title>
    <url>/2021/06/09/Regexp/</url>
    <content><![CDATA[<p>正则表达式就是用于定义某种规则，计算机可以通过该规则检测一个字符串是否符合该规则<br>或者将该字符串中符合正则表达式的内容提取出来</p>
<span id="more"></span>

<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Regexp构造函数</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;正则表达式&#x27;</span>,<span class="string">&#x27;匹配模式&#x27;</span>) <span class="comment">//是一个对象 更简单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/a/i</span>; <span class="comment">//更灵活</span></span><br></pre></td></tr></table></figure>
<p>每个正则表达式就是一个RegExp实例对象，有着自己的属性，包括source，lastIndex等，这些属性可以全面了解正则表达式等信息，但实际用得不多。</p>
<p>在正则表达式中，不属于特殊字符代码的(如\n)的反斜杠会被保留，不像在一般字符串中被忽略，并且问号和加号等特殊字符在正则表达式中具有特殊含义，若要表示该字符本身，前面也要加\说明，如/+/。<br>匹配模式有i g m等，主要用: i忽略大小写 g开启全局匹配。</p>
<p>有一个test方法可以检测某字符串是否符合正则表达式,只要含有正则表达式中的的字符串就回返回true。<br>而exec()方法可以返回一个包含匹配信息的数组对象，该数组对象中有index(字符串中匹配模式的其实位置)和input(查找的字符串)两个属性，如果没有匹配到就返回一个null，如果不开启g，则每次调用该方法就回返回第一个匹配项，开启后则回往后搜寻下一个匹配项，并改变lastIndex属性的值(默认一直为0)。当正则表达式含有括号分组的字表达后，调用该方法后的数组对象第一个元素还是整体匹配的部分，但接下来的元素是由那些括号组所匹配的部分</p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>｜表示或的意思 a|b  []里面也表示｜的关系  /[a-z]/表示任意的小写字母 /[A-z]/任意字母<br>/[^a]/表示不包含a 除了a。<br>字符集也有一些内置的快捷方式。</p>
<pre><code>    \d  任何数字字符
    \w  字母数字字符
    \s  任何空白符字符
    \D  非数字字符
    \W  非字母数字字符
    \S  非空白符字符
    \b  匹配单词边界 (所谓单词就是隶属于\w下的字串)
    \B  匹配非单词边界
    .  除换行符以外的所有字符
</code></pre>
<p>对于要匹配重复的部分 则有以下方法，如：</p>
<pre><code>    /+/ 匹配一个或多个字符
    /*/ 与加号类似，但允许匹配0次
    /?/ 令某一部分可选，即可能出现一次或者零次

    //若要表示精确次数，就用&#123;&#125;，如

    &#123;2&#125; 表示出现两次
    &#123;2,4&#125; 表示出现2-4次
    &#123;2,&#125; 表示出现两次即以上
</code></pre>
<p><strong>记得若要重复多个元素时，要用括号，例如 <code>/(abc)+/</code></strong></p>
<pre><code>    /^a/ 表示必须以a开头
    /a$/ 表示必须以a结尾
</code></pre>
<p>所以/^a$/表示所匹配的字符串中有且只有a</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`Lis, Bar</span></span><br><span class="line"><span class="string">Mc, John</span></span><br><span class="line"><span class="string">Wad, Phio`</span>.replace(<span class="regexp">/(\w+), (\w+)/g</span>, <span class="string">&#x27;$2 $1&#x27;</span>));</span><br><span class="line"><span class="comment">// $1 和 $2 是模式中带括号的组。 整个匹配可以用 $&amp;来表示。</span></span><br><span class="line"><span class="comment">// 上述代码是 $1 指向 Lis / Mc / Wad ，$2 指向 Bar / John / phio ,然后$2 指向的匹配代替了$1匹配原有的位置</span></span><br></pre></td></tr></table></figure>

<p>字符串加正则<br>search 检索与正则表达式匹配的值 类似于indexof()方法 返回索引，搜不到就返回-1，接收正则表达式为参数<br>match   找到一个或多个正则的匹配  默认情况下之检索一个，开启全局匹配后则可以匹配多个， 把匹配到的内容封装成一个数组返回<br>replace 替换与正则表达式匹配的字串 两个参数，第一个是正则表达式，第二个是替换内容<br>split   把字符串拆分成数组</p>
<h2 id="匹配机制"><a href="#匹配机制" class="headerlink" title="匹配机制"></a>匹配机制</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> animalCount = <span class="regexp">/\b\d+ (pig|cow|chicken)s?\b/</span></span><br><span class="line"><span class="built_in">console</span>.log(animalCount.tesr(<span class="string">&quot;15 pigs&quot;</span>)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/09/Regexp/9-1.svg" alt="01"></p>
<p>回溯:<br>正则表达式/\b([01]+b|\d+|[\da-f]h)\b/可以匹配三种字符串：以b结尾的二进制数字，以h结尾的十六进制数字（即以 16 为进制，字母a到f表示数字 10 到 15），或者没有后缀字符的常规十进制数字。这是对应的图表。<br><img src="/2021/06/09/Regexp/9-2.svg" alt="02"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>antd的基本使用</title>
    <url>/2021/05/12/antd%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="引入组件"><a href="#引入组件" class="headerlink" title="引入组件"></a>引入组件</h1><p>先引入antd库嘛<br><code>yarn add antd</code></p>
<p>然后想用什么组件就去官网找相应代码，比如有一个Button按钮想引入，就直接import导入<br><code>import &#123;Button&#125; from &#39;antd&#39;</code><br>在你想要的合适的位置直接放进去就行<br><code>&lt;Button type=&quot;primary&quot;&gt;Primary Button&lt;/Button&gt;</code></p>
<span id="more"></span>
<p>用的比较多的是图标哈，就需要有另一个库<br><code>yarn add @ant-design/icons</code><br>想要啥就import导入然后写下来就行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; WechatOutlined, WeiboOutlined&#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/icons&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;WechatOutlined /&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">WeiboOutlined</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>还有轮播图啥的巴拉巴拉，自己去看官方文档就好了。</p>
<h1 id="按需引入和自定义内容"><a href="#按需引入和自定义内容" class="headerlink" title="按需引入和自定义内容"></a>按需引入和自定义内容</h1><p>这个好好看官方文档吧，3版本和4版本的不一样，暂时还没弄懂。。。。</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>fetch详解</title>
    <url>/2021/06/12/fetch%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>今天详细学一下fetch的用法</p>
<span id="more"></span>

<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="分派请求和读取响应"><a href="#分派请求和读取响应" class="headerlink" title="分派请求和读取响应"></a>分派请求和读取响应</h2><p>对于fetch的用法在上一篇Blog中有了基本的了解，现在我们在深入的看一下fetch的用法。<br>都知道，fetch是异步的，是关注分离的，fetch有一个必须的参数，就是URL，利用fetch获取URL资源后会返回一个pending状态的Promise。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = fetch(<span class="string">`url`</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// Promise(pending)</span></span><br></pre></td></tr></table></figure>

<p>请求URL完成且资源可用后，Promise会生成一个Response对象。这个对象是API的封装，可以通过使用这个对象的属性和方法取得相应资源。<br>用text方法可以读取response对象的纯文本格式内容。</p>
<p><code>response.text()</code></p>
<h2 id="处理状态码和请求失败"><a href="#处理状态码和请求失败" class="headerlink" title="处理状态码和请求失败"></a>处理状态码和请求失败</h2><p>我们首先要知道一点，就是fetch在接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject， 即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</p>
<p>也就是说，只有你断网了或请求错了，fetch啥东西也得不到，才会返回一个reject状态的Promise。从我自己的理解来看，fetch的意思就是取嘛，404，500 都是你访问到了，虽然取不到ok状态的response，但你好歹取到了404 500状态码和一个不知道什么鬼且ok是false的response，是吧，只要能取到东西fetch返回到Promise可以是成功的，就不会被报错。</p>
<p>所以想判断fetch请求后的具体响应状态，就要用下面这些方法了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">response.status() <span class="comment">//返回http状态码</span></span><br><span class="line">response.statysText() <span class="comment">// 返回状态文本 比如 200 - OK 404 - Not Found 500 - Internal Server Error</span></span><br><span class="line">response .ok() <span class="comment">// 询问请求是否成功，true 对应 200 - 299 状态码，其他都是false</span></span><br><span class="line">responese.url() <span class="comment">// 返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。</span></span><br></pre></td></tr></table></figure>

<h2 id="其余参数"><a href="#其余参数" class="headerlink" title="其余参数"></a>其余参数</h2><p>如果只传一个URL参数，则fetch会默认发送GET请求，要想进一步配置请求方式，则要传入第二个参数————一个init对象，init对象要按照下表的key/value填充<br>(具体的就去MDN上查，这里只写一些常用的)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="comment">//具体的请求方法 ，“GET”，“POST”等</span></span><br><span class="line">    headers: <span class="comment">//一个用来定制HTTP标头的对象</span></span><br><span class="line">    body: <span class="comment">//POST请求的请求体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="常见的Fetch请求模式"><a href="#常见的Fetch请求模式" class="headerlink" title="常见的Fetch请求模式"></a>常见的Fetch请求模式</h1><p>这里是一些关于init对象的配置使用</p>
<h2 id="发送JSON数据"><a href="#发送JSON数据" class="headerlink" title="发送JSON数据"></a>发送JSON数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> postData = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xyy&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fetch (<span class="string">`url`</span>),&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: postDate,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在请求体中发送参数"><a href="#在请求体中发送参数" class="headerlink" title="在请求体中发送参数"></a>在请求体中发送参数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> postData = <span class="string">&#x27;foo=bar&amp;lorem=ipsum&#x27;</span>;</span><br><span class="line"></span><br><span class="line">fetch (<span class="string">`url`</span>),&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: postDate,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;/users&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="keyword">new</span> FormData(form)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>因为请求体支持FormData实现，所以fetch()就可以序列化并发送文件字段中的文件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> imageFormData = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="keyword">let</span> imageInput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;input[type=&#x27;file&#x27;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">imageFormData.append(<span class="string">&#x27;image&#x27;</span>,imageInput.file[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现多个文件:</span></span><br><span class="line"><span class="comment">// let imageInput = document.querySelector(&quot;input[type=&#x27;file&#x27;][multiple]&quot;);</span></span><br><span class="line"><span class="comment">// for(let i = 0;i &lt; imageInput.fileslength; ++i)</span></span><br><span class="line"><span class="comment">// imageFormData.append(&#x27;image&#x27;,imageInput.file[i]);</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">`url`</span>,&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">body</span>: imageFormData</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>具体更高深的就自己去看MDN吧。</p>
<h1 id="其他对象"><a href="#其他对象" class="headerlink" title="其他对象"></a>其他对象</h1><h2 id="Headers对象"><a href="#Headers对象" class="headerlink" title="Headers对象"></a>Headers对象</h2><p>Response对象里面有一个headers属性，指向Header对象，Headers对象就是所有外发请求和入站响应头部的容器，每个外发的Request实例都包涵一个空的Headers实例，可以通过Request.headers访问。</p>
<ol>
<li><p>headers对象形式：<br>headers对象与Map相似，因为Http头部本质上就是序列化后的键值对，所以Headers对象有get,set,has,delete等实例方法，也有相同的keys(),values()和entries()迭代器接口,对于这些方法的运用还是去看看Map吧，这里就不详细赘述了。</p>
</li>
<li><p>headers独有的特性<br>headers初始化的时候可以直接用普通obj形式对象(也就是{}包裹的键/值对对象)，Headers对象可以由append()方法添加多个值，调用不存在的值等同于调用set(),若是用append()多次添加一个键名，则该键名对应的值以逗号为分隔符显示。</p>
</li>
<li><p>头部护卫<br>就是限制Headers对象不被修改的一些知识，自行了解。</p>
</li>
</ol>
<h1 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h1><p>顾名思义，Request对象是获取资源请求的接口。这个接口暴露了请求的相关信息，也暴露了使用请求题的不同方式。</p>
<h2 id="创建Request对象"><a href="#创建Request对象" class="headerlink" title="创建Request对象"></a>创建Request对象</h2><p>通过构造函数初始化Request对象，为此传入一个input参数，一般是URL;</p>
<p>Request对象也接收第二个参数，一个init对象，和fetch中的第二个参数一样，不加配置的话就传入默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Request(<span class="string">`url`</span>，&#123;<span class="comment">/*一些key/value*/</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="克隆Request对象"><a href="#克隆Request对象" class="headerlink" title="克隆Request对象"></a>克隆Request对象</h2><p>除了构造函数创建Request对象外，还可以用clone()方法，</p>
<p>有两种方法可以克隆一个Request对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一.把Request实例作为input参数传给Request构造函数</span></span><br><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> Request(<span class="string">`url`</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = <span class="keyword">new</span> Request(r1); <span class="comment">// 如果传入init对象，则会覆盖。</span></span><br><span class="line"><span class="built_in">console</span>.log(r1.bodyused); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//不能克隆一摸一样的值，r1会被标记为已使用，bodyused的值为true</span></span><br><span class="line"><span class="comment">//还有一些关于referrer和mode属性的改变，具体属性可以自己去了解一下。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二.Request.clone()</span></span><br><span class="line"><span class="keyword">let</span> r1 = <span class="keyword">new</span> Request(<span class="string">`url`</span>);</span><br><span class="line"><span class="keyword">let</span> r2 = r1.clone() <span class="comment">//这个方法会让创建两个一摸一样的副本,bodyused的值为false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(r1===r2) <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果请求对象的bodyused值为true，那么就不能对该Request对象创建副本。</p>
<h2 id="在fetch-中使用Request对象"><a href="#在fetch-中使用Request对象" class="headerlink" title="在fetch()中使用Request对象"></a>在fetch()中使用Request对象</h2><p>fetch()和Request构造函数拥有相同的函数签名不是巧合，在调用fetch()的时候，可以传入已经构造好的Request实例而不是URL，和Request构造函数一样，传给fetch()的init对象会覆盖默认值。</p>
<p>关键点在于，通过fetch()使用Request实例后会把其bodyused属性设置为true，要想对同一个Request实例多次调用fetch(),必须在第一次发送fetch()请求前调用clone方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> Request(<span class="string">`url`</span>);</span><br><span class="line"></span><br><span class="line">fetch(r.clone());</span><br><span class="line">fetch(r);</span><br></pre></td></tr></table></figure>


<h1 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h1><p>Response对象是获取资源响应的接口。这个接口暴露了响应的相关信息，也暴露了使用响应体的不同方式。</p>
<h2 id="创建Response对象"><a href="#创建Response对象" class="headerlink" title="创建Response对象"></a>创建Response对象</h2><p>和前面几个对象一样，可以用构造函数的方法创建Response对象，且该构造函数不需要必须参数，此时Response实例的属性均为默认值，因为它并不代表实际的HTTP响应。</p>
<p>Response构造函数接收一个可选的body参数，这个body可以是null，等同于init对象中的body，还可以接收一个可选的init对象，该init对象应有三个键值对</p>
<pre><code>    headers 必须是Headers对象实例
    status 表示HTTP的状态码
    statusText 表示HTTP响应状态的字符串
</code></pre>
<p>但大部分情况下，产生Response对象的主要方式还是调用fetch(),fetch()返回一个最终会成为Response对象的Promise实例，</p>
<p>还有两种生成Response对象的静态方法，分别是Response.redirect()和Response.error()，前者接收一个URL和一个重定向状态码，(301,302…),返回重定向的Response对象:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Response.redirect(<span class="string">`url`</span>,<span class="number">301</span>)</span><br></pre></td></tr></table></figure>
<p>后者则用于产生表示网络错误的Response对象，(网络错误会导致fetch()期约被拒绝).</p>
<p>Response对象只包含一组只读属性，描述了完成后的状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">headers: <span class="comment">//响应包含的Headers对象</span></span><br><span class="line">ok: <span class="comment">//布尔值，表示HTTP状态码的含义</span></span><br><span class="line">redirected: <span class="comment">//布尔值，表示响应是否至少经过一次定向</span></span><br><span class="line">status: <span class="comment">//整数，表示响应的HTTP状态码</span></span><br><span class="line">statusText: <span class="comment">//字符串，对HTTP状态码的描述</span></span><br><span class="line">type: <span class="comment">//字符串，包含响应类型。分为basic/cors/error/opaque/opaqueredirect</span></span><br><span class="line">url: <span class="comment">//包含响应URL的字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="克隆Response对象"><a href="#克隆Response对象" class="headerlink" title="克隆Response对象"></a>克隆Response对象</h2><p>就是使用clone()方法呀，创建一个一摸一样的副本，和Request对象的clone差不多，该方法也主要用于多次读取Response对象，Response对象是只可以读取一次的。</p>
<h2 id="Request、Response、Body的混用"><a href="#Request、Response、Body的混用" class="headerlink" title="Request、Response、Body的混用"></a>Request、Response、Body的混用</h2><p>这部分内容涉及到Body的五个方法，用于将ReadableStream转存到缓冲区的内存里，这部分也没太懂，可能是浏览器机制和HTTP没有过多了解的缘故，打算重看一遍图解HTTP，所以这部分笔记就先不写了，有空再补，</p>
<h2 id="一次性流"><a href="#一次性流" class="headerlink" title="一次性流"></a>一次性流</h2><p>因为Body混入是构建在ReadableStream之上的，所以主体流只能使用一次。这也是为什么要用clone方法的原因。</p>
<h2 id="使用ReadableStream主体"><a href="#使用ReadableStream主体" class="headerlink" title="使用ReadableStream主体"></a>使用ReadableStream主体</h2><p>这部分也后续再补吧，实在没怎么看懂….</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>fetch-搜索用户</title>
    <url>/2021/05/10/fetch-%E6%90%9C%E7%B4%A2%E7%94%A8%E6%88%B7/</url>
    <content><![CDATA[<p>做项目嘛，肯定得与后端合作，这就需要从他们那里拿数据过来，也就是网络请求。在引入网络请求前，我们先明白几个概念。</p>
<span id="more"></span>
<h1 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h1><p>大家应该都知道XML是什么东西：<br><strong>XML(Extensible Markup Language)可扩展标记语言,跟html差不多，不过html是用来展示、表现数据，而XML则用来传输和储存数据</strong><br>那什么又是XMLHttpRequest 对象呢？<br>官方给的解释是<br>        <strong>XMLHTTP是一组API函数集，可被JavaScript、JScript、VBScript以及其它web浏览器内嵌的脚本语言调用，通过HTTP在浏览器和web服务器之间收发XML或其它数据</strong><br>也就是说他可以用于在后台与服务器交换数据<br>Emmmm,听上去挺模糊的，但有了XMLhttpRequest 对象，我们就可以：</p>
<pre><code>    在不重新加载页面的情况下更新网页
    在页面已加载后从服务器请求数据
    在页面已加载后从服务器接收数据
    在后台向服务器发送数据
</code></pre>
<p>哎呀，具体细节可以前W3C看看，我们接着往下说</p>
<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>AJAX(Asynchronous JavaScript and XML),异步的Js和XML技术，通俗点说就是通过异步编程实现网络请求数据交换等，快速实现动态网页。</p>
<h2 id="常用的ajax库"><a href="#常用的ajax库" class="headerlink" title="常用的ajax库"></a>常用的ajax库</h2><ol>
<li>jQuery: 比较重, 如果需要另外引入不建议使用</li>
<li>axios: 轻量级, 建议使用<br> 1)封装XmlHttpRequest对象的ajax<ol start="2">
<li>promise风格可以用在浏览器端和node服务</li>
</ol>
</li>
</ol>
<p>简单的看看axios的使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GET请求</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//POST请求</span></span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>但这不是我们今天的重点哈，这方面的内容也可以去自行找点资料去看，我们今天的重点是:</p>
<h1 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h1><p>fetch: 原生函数，不再使用XmlHttpRequest对象提交ajax请求 且更符合关注点分离的思想</p>
<p>fetch与ajax的不同</p>
<ol>
<li>当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject， 即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。</li>
<li>fetch 不会发送 cookies</li>
</ol>
<p>接下来就看看fetch的简单使用呗，</p>
<h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response.json()</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  fetch(url, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(data),</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="GitHub搜索用户案例"><a href="#GitHub搜索用户案例" class="headerlink" title="GitHub搜索用户案例"></a>GitHub搜索用户案例</h1><p>理论知识就到这了，接下来看看实际案例吧<br><img src="/2021/05/10/fetch-%E6%90%9C%E7%B4%A2%E7%94%A8%E6%88%B7/1.png" alt="1"><br>只有一个需求，就是按下搜索后开始搜索嘛</p>
<p>还是一样的先拆分组件 搜索和展示两个组件而已<br><img src="/2021/05/10/fetch-%E6%90%9C%E7%B4%A2%E7%94%A8%E6%88%B7/2.png" alt="2"></p>
<p>接下来就是写网络请求啦，这个需求只涉及到GET请求，就弄的详细点吧</p>
<h2 id="用axios"><a href="#用axios" class="headerlink" title="用axios"></a>用axios</h2><p>Search组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">search = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户的输入(连续解构赋值+重命名)</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">keyWordElement</span>: &#123; <span class="attr">value</span>: keyWord &#125; &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//发送请求前通知App更新状态</span></span><br><span class="line">    <span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isFirst</span>: <span class="literal">false</span>, <span class="attr">isLoading</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="comment">//发送网络请求</span></span><br><span class="line">    axios.get(<span class="string">`https://api.github.com/search/users?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>).then(</span><br><span class="line">        <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//请求成功后通知App更新状态</span></span><br><span class="line">            <span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">users</span>: response.data.items &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//请求失败后通知App更新状态</span></span><br><span class="line">            <span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">err</span>: error.message &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用fetch"><a href="#用fetch" class="headerlink" title="用fetch"></a>用fetch</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">search = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">       <span class="keyword">const</span>&#123;<span class="attr">keyWordElement</span>:&#123;<span class="attr">value</span>: keyWord&#125;&#125;=<span class="built_in">this</span>;</span><br><span class="line">       <span class="built_in">this</span>.props.updateAppState(&#123;<span class="attr">isFirst</span>:<span class="literal">false</span>,<span class="attr">isLoding</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">       fetch(<span class="string">`https://api.github.com/search/users?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>).then(</span><br><span class="line">           <span class="function"><span class="params">response</span> =&gt;</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> response.json()<span class="comment">//返回一个pending状态的Promise()</span></span><br><span class="line">           &#125;</span><br><span class="line">       ).then(</span><br><span class="line">           <span class="function"><span class="params">data</span> =&gt;</span> &#123;<span class="built_in">this</span>.props.updateAppState(&#123;<span class="attr">isLoding</span>:<span class="literal">false</span>,<span class="attr">users</span>: data.items&#125;)&#125;</span><br><span class="line">       ).catch(</span><br><span class="line">           <span class="function"><span class="params">error</span> =&gt;</span> &#123;<span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">err</span>: error.message &#125;)&#125;</span><br><span class="line">       )</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="优化后的fetch"><a href="#优化后的fetch" class="headerlink" title="优化后的fetch"></a>优化后的fetch</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">search = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">keyWordElement</span>: &#123; <span class="attr">value</span>: keyWord &#125; &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isFirst</span>: <span class="literal">false</span>, <span class="attr">isLoading</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">`https://api.github.com/search/users?q=<span class="subst">$&#123;keyWord&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> response.json()</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        <span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">users</span>: data.items &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">this</span>.props.updateAppState(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">err</span>: error.message &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





























]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep react</title>
    <url>/2021/09/12/Deep-react/</url>
    <content><![CDATA[<p>《深入react技术栈》读书笔记</p>
<span id="more"></span>

<h1 id="第一章-初入react世界"><a href="#第一章-初入react世界" class="headerlink" title="第一章 初入react世界"></a>第一章 初入react世界</h1><p>这章大致的介绍了react的一些基本概念 ，以及利用一个tab栏的例子引出了state，props，ref和生命周期函数的概念。要点如下：</p>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><ul>
<li>就是react是操纵虚拟DOM的<br><img src="/2021/09/12/Deep-react/vdom.png" alt="vdom"></li>
<li>写react的编程方式是<strong>函数式编程</strong>，也就是声明式。</li>
<li>虚拟DOM其实是以JSON对象的形式存在的，直接上代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">const</span> buttonJSX = <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-blue&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">em</span>&gt;</span>Confirm<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> buttonJSON = &#123;</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                    <span class="attr">props</span>: &#123;</span><br><span class="line">                    <span class="attr">className</span>: <span class="string">&#x27;btn btn-blue&#x27;</span>, </span><br><span class="line">                    <span class="attr">children</span>: [&#123;</span><br><span class="line">                      <span class="attr">type</span>: <span class="string">&#x27;em&#x27;</span>,</span><br><span class="line">                      <span class="attr">props</span>: &#123;</span><br><span class="line">                        <span class="attr">children</span>: <span class="string">&#x27;Confirm&#x27;</span> </span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;] </span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure>
<p>其他的部分没怎么细看了 似懂非懂</p>
<h1 id="第二章-漫谈React"><a href="#第二章-漫谈React" class="headerlink" title="第二章 漫谈React"></a>第二章 漫谈React</h1><h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><p>即react中的事件都是封装好的合成事件。</p>
<ol>
<li>事件委派<br>在虚拟DOM被渲染后，react会把所有的事件处理函数绑定到结构的最外层，用一个统一的事件监听器管理，也就是说并不会直接绑定到单一的DOM节点上。这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是 在这个统一的事件监听器上插入或删除一些对象;当事件发生时，首先被这个统一的事件监听器 处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升。</li>
<li>自动绑定<br>在 React 组件中，每个方法的上下文都会指向该组件的实例，即自动绑定 this 为当前组件。 而且 React 还会对这种引用进行缓存，以达到CPU和内存的最优化。在使用 ES6 classes 或者纯函数时，这种自动绑定就不复存在了，我们需要手动实现 this 的绑定。</li>
</ol>
<p>绑定this用bind方法或者使用箭头函数(在不传参的情况下可以用::的语法代替bind(),也就是说其实bind()方法在某种意义上已经被废弃了)。<br>然后现在有了hooks后函数组件的出现率应该会大于类组件了，而在函数组件中就没必要担心this的指向问题了。<br>然后我们也可以利用ref实现原生Js的事件，但没必要，都用上react不到  万不得已绝不轻易操纵真实DOM。</p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>无非就是受控组件和非受控组件的区别，这个没啥。</p>
<h2 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h2><p>用什么 css_moudles 复杂 看不懂 过</p>
<h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><p>这个看之前的博客， 有总结过的</p>
<h2 id="组件间抽象"><a href="#组件间抽象" class="headerlink" title="组件间抽象"></a>组件间抽象</h2><ol>
<li>mixin 第一次见这个东西 难懂 没理解 先过 <strong>mixin 是一个包含可被其他类使用而无需继承的方法的类</strong>这是维基百科的定义</li>
<li>高阶组件 。。还好没深挖，react就采取高阶组件的方式代替了mixin，关于这个东西的概念C++这种面向对象的语言专业课应该会有讲</li>
</ol>
<h3 id="实现高阶组件"><a href="#实现高阶组件" class="headerlink" title="实现高阶组件"></a>实现高阶组件</h3><p>实现高阶组件的方法有两种吗，一种叫**属性代理(props proxy)<strong>。高阶组件通过被包裹的 React 组件来操作 props，还有一种是</strong>反向继承(inheritance inversion)**。高阶组件继承于被包裹的 React 组件</p>
<p>这个感觉东西有点多啊，专门写一篇博客吧。<br><img src="/2021/09/12/Deep-react/comp:png.png" alt="comp"></p>
<h2 id="组件性能优化"><a href="#组件性能优化" class="headerlink" title="组件性能优化"></a>组件性能优化</h2><p>用purerender去解决不必要的渲染，好像hooks里useEffect可以用依赖解决这个问题</p>
<h3 id="pure-Render"><a href="#pure-Render" class="headerlink" title="pure Render"></a>pure Render</h3><p>先说纯函数 老生常谈的问题了</p>
<ol>
<li>给定相同的输入，它总是返回相同的输出; </li>
<li>过程没有副作用(side effect)1;</li>
<li>没有额外的状态依赖。<br>再往下看好像真的很像useEffect的依赖</li>
</ol>
<h3 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h3><p>没看明白 不懂 用useEffect算了</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>之前有写了篇博客关于key的机制</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>就是可以用react的一些动画库写，就不用写繁琐的css了，好像有点东西，后面再深究<br>现有的动画</p>
<ul>
<li>css</li>
<li>js-svg</li>
<li>react一些动画库 smooth啥的</li>
<li>React Transition 之前有了解过，收藏夹里吃灰好久了</li>
<li>react-motion</li>
<li>cubic-bezier （上面这两条都有关于缓动动画）</li>
</ul>
<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>这…..还没上线过项目，测试啥的歇会儿吧</p>
<p>然后用了一堆库对第一章的tab优化了我？？？？？？？<br>人傻了  代码歇会儿放吧</p>
<p>后面就是看源码的部分了 难之</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>interface和type</title>
    <url>/2021/09/11/interface%E5%92%8Ctype/</url>
    <content><![CDATA[<p>学了ts有段时间了 type跟interface的区别一直处于一个懵懂的状态，感觉很多地方他俩可以互相代替，和react联系起来后对于prop和state的定义上是用type或interface也有不明确的地方，所以写一篇博客谈谈理解和想法。</p>
<span id="more"></span>

<h1 id="简单定义"><a href="#简单定义" class="headerlink" title="简单定义"></a>简单定义</h1><p>在说区别前我们先了解一下什么是 interface 和 type</p>
<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p><strong>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</strong></p>
<p>大致意思就是用来规范对象 ｜ 类 的，对象和类需要满足接口所定义的属性， 接口可以被extend(继承)和implementing(实现)</p>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>type(类型别名)就是用来自定义类型的，什么联合类型交叉类型字面量类型等等，本质上说type其实是给你自定义类型重新取一个可读的名字<br>交叉类型(&amp;)可以实现和extend差不多的效果</p>
<h1 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h1><p>翻了好多博客和官方文档 得到这样一句话<br><strong>“type aliases can act sort of like interfaces, however, there are some subtle differences.”</strong><br>和开头说的差不多，type在很多地方可以替代interface，但还是有一些差别。</p>
<h2 id="是否创建新的变量名"><a href="#是否创建新的变量名" class="headerlink" title="是否创建新的变量名"></a>是否创建新的变量名</h2><p>官网中提到的第一处不同是“One difference is, that interfaces create a new name that is used everywhere. Type aliases don’t create a new name — for instance, error messages won’t use the alias name.”<br>这其实是不对的，在编译器中尝试会发现报错信息是一致的<br>比如</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> PointInterface &#123;</span><br><span class="line">   <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">   <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> PointType = &#123;</span><br><span class="line">   <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">   <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> getSquareI = <span class="function">(<span class="params">args: PointInterface</span>) =&gt;</span> args.x * args.y</span><br><span class="line"> <span class="keyword">const</span> getSquareT = <span class="function">(<span class="params">args: PointType</span>) =&gt;</span> args.x * args.y</span><br><span class="line"></span><br><span class="line"> <span class="comment">// error: 类型&#123;x: number&#125;不能赋值给squareI/T 类型的参数，因为缺少了 &#123;y: number&#125;属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关于extend-和-implemented"><a href="#关于extend-和-implemented" class="headerlink" title="关于extend 和 implemented"></a>关于extend 和 implemented</h2><p>第二处不同<br><strong>“A second more important difference is that type aliases cannot be extended or implemented from”</strong><br>Mad！！！这也是错的！！！ 直接看代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> TreeDimeions <span class="keyword">extends</span> PointType &#123;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Rectangele</span> <span class="title">implements</span> <span class="title">PointType</span> </span>&#123;</span><br><span class="line">    x= <span class="number">2</span></span><br><span class="line">    y= <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">RectangPrism</span> <span class="title">implements</span> <span class="title">TreeDimeions</span> </span>&#123;</span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    y = <span class="number">3</span></span><br><span class="line">    z = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 也可以通过type和interface实现对类的约束</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    area(): <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">type</span> Perimeter = &#123;</span><br><span class="line">    perimeter(): <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="title">implements</span> <span class="title">PointType</span>, <span class="title">Shape</span>, <span class="title">Perimeter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    y = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    area () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.x * <span class="built_in">this</span>.y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">perimeter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">this</span>.x + <span class="built_in">this</span>.y)*<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="type不能对其他type-extend和implement"><a href="#type不能对其他type-extend和implement" class="headerlink" title="type不能对其他type extend和implement"></a>type不能对其他type extend和implement</h2><p>第三处不同说<br><strong>“type aliases cannot extend/implement other types”</strong><br>这句话也不对，但不说完全不对，只能说部分正确</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  area(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Perimeter = &#123;</span><br><span class="line">  perimeter(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 &amp; 实现 extend</span></span><br><span class="line"><span class="keyword">type</span> RectangleShape = Shape &amp; Perimeter &amp; Point</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="title">implements</span> <span class="title">RectangleShape</span> <span class="title">Perimeter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    y = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    area () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.x * <span class="built_in">this</span>.y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">perimeter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">this</span>.x + <span class="built_in">this</span>.y)*<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现映射类型</span></span><br><span class="line"><span class="keyword">type</span> RectangleShape2 = Partial&lt;Shape &amp; Perimeter&gt; &amp; Point</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartialRectangle</span> <span class="title">implements</span> <span class="title">RectangleShape2</span> </span>&#123;</span><br><span class="line">  x = <span class="number">2</span></span><br><span class="line">  y = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二者区别-真"><a href="#二者区别-真" class="headerlink" title="二者区别 真"></a>二者区别 真</h1><p>叭叭了这么多，所以二者的区别到底在哪儿呢</p>
<ol>
<li><p><strong>you cannot use implements on an class with type alias if you use union operator within your type definition</strong><br>翻译就如果一个type是联合类型，那我就不能用类去实现他了<br><img src="/2021/09/11/interface%E5%92%8Ctype/1.gif" alt="gif"></p>
</li>
<li><p><strong>you cannot use extends on an interface with type alias if you use union operator within your type definition</strong><br>差不多意思，一个type是联合类型，接口就不能继承了</p>
</li>
</ol>
<p>这里那篇博客的解释是，类和接口都是一个 ***“blueprint” ***<br>所以他们不能实现和继承在 <em><strong>one or another shape</strong></em> 我英语太废物了完全不懂是什么意思啊赣了</p>
<ol start="3">
<li><strong>declaration merging doesn’t work with type alias</strong><br>type不能合并声明，这个很多博客都提到了，没啥多说的<br><img src="/2021/09/11/interface%E5%92%8Ctype/2.png" alt="png"><br>因为type是一个unique type entity，无论是在全局变量还是module scope中</li>
</ol>
<p>而在react中<br>always use interface for public API’s definition when authoring a library or 3rd party ambient type definitions<br>consider using type for your React Component Props and State</p>
<p>对于props和state还是用type吧， 然后interface用于公共的API和第三方库的实现<br>就是这样 具体区别可能要看看定义interface和type的源码来了解了</p>
<p><a href="https://medium.com/@martin_hotell/interface-vs-type-alias-in-typescript-2-7-2a8f1777af4c">参考链接</a></p>
<p><img src="/2021/09/11/interface%E5%92%8Ctype/3.png" alt="dif"></p>
<p>！在看深入react技术栈的时候看到一点:<br><strong>包括 C++ 等一些年龄较大的 OOP 语言， 它们都有一个强大但危险的多重继承特性。现代语言为了权衡利弊，大都舍弃了多重继承，只采用单继承，但单继承在实现抽象时有诸多不便之处。为了弥补缺失，Java 引入了接口(interface)， 其他一些语言则引入了像 mixin 的技巧，方法虽然不同，但都是为创造一种类似多重继承的效果， 事实上说它是组合更为贴切。</strong><br>结合Java来看，interface其实是更像抽象类的，所以用interface去规范类或许是更好的选择</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>git的用法</title>
    <url>/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>git 的笔记</p>
<span id="more"></span>
<p>git 管理的是修改<br>工作区里面有个不可见的.git文件， 是这一项目的版本库，版本库里有缓存区和分支</p>
<p>git add 添加文件到缓存区<br>git commit -m “” 把添加到缓存区到文件全部提交到master分支<br>git push 把提交到文件推送到远程仓库<br>git status 查看仓库状态<br>git diff 文件 查看该文件的修改<br>git log 查看修改日志<br>git checkout – [file] 把文件在工作区(就是目录or在编辑器里面)做的修改全部撤销<br>git reset HEAD [file] 当做了某修改并且 git add 后使用撤销</p>
<ul>
<li><p>git恢复版本(作出修改并git commit 后修改的方法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用git commit 多次提交不同版本</span><br><span class="line"></span><br><span class="line">git log --pretty=oneline 简要查看日志</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD^ 恢复到上一个版本 三个以上用 HEAD～3 (HEAD表示当前版本)</span><br><span class="line"></span><br><span class="line">git reset --hard commit Id  恢复到指定版本号</span><br><span class="line"></span><br><span class="line">git reflog </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>在工作区删文件</p>
<p>  git rm [file] 在版本库里删除文件<br>  git checkout – [file] </p>
</li>
</ul>
<h1 id="关于分支"><a href="#关于分支" class="headerlink" title="关于分支"></a>关于分支</h1><p>我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：<br><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/0.png"><br>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。</p>
<p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/l.png"><br>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/l-1.png"></p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>
<p><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/0-1.png"></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p>
<p><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/0-2.png"></p>
<ul>
<li><p>实战代码</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先，我们创建dev分支，然后切换到dev分支：</span><br><span class="line">git checkout -c dev</span><br><span class="line"></span><br><span class="line">git switch命令加上-b参数表示创建并切换，相当于以下两条命令：</span><br><span class="line">git branch dev</span><br><span class="line">git switch dev</span><br><span class="line"></span><br><span class="line">然后，用git branch命令查看当前分支：</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">git branch命令会列出所有分支，当前分支前面会标一个*号。</span><br><span class="line"></span><br><span class="line">然后，我们就可以在dev分支上正常提交</span><br><span class="line"></span><br><span class="line">dev分支的工作完成，我们就可以切换回master分支</span><br><span class="line">git switch master</span><br><span class="line"></span><br><span class="line">我们把dev分支的工作成果合并到master分支上：</span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line">删除dev分支</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用git log –graph命令可以看到分支合并图</p>
<p><code> git log --graph --pretty=oneline --abbrev-commit</code></p>
<ul>
<li>分支策略:</li>
</ul>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/0-3.png"></p>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<p> <code>git stash</code> 把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p>
<p> 场景：出现了一个Bug，但当前分支的工作还未完成提交，却必须马上修复bug,此时就用该命令</p>
<p><code>git stash list</code> 查看隐藏的现场<br><code>git stash pop</code> 恢复工作现场<br><code>git cherry-pic &lt;commmit&gt;</code> 让我们能复制一个特定的提交到当前分支(多个分支修改同一个Bug，即在某一个分支修改完成后直接用该命令复制给其他人)</p>
<ul>
<li><p>feature分支用于开发某一项新需求， issue-n 分支用于改bug</p>
</li>
<li><p><code>git push origin &lt;branch&gt;</code> 推送分支</p>
</li>
</ul>
<p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p>
<p>要查看远程库的信息，用<code>git remote -v</code></p>
<p>多人协作的工作模式通常是这样：</p>
<p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p>
<p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p>
<p>如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p>
<p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p><code>git rebase</code> 可以把本地未push的分叉提交历史整理成直线,目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
<h1 id="关于标签"><a href="#关于标签" class="headerlink" title="关于标签"></a>关于标签</h1><p>标签就是某个版本的快照 和某个commit绑定在一起<br><code>git tag &lt;name&gt;</code> 制作标签</p>
<p><code>git tag</code> 查看所有标签</p>
<p>标签默认打在当前版本号上，如果想要打到以前的版本上，找到之前版本的commit id <code>git tag &lt;name&gt; &lt;commit id&gt;</code></p>
<p><code>git show &lt;tagname&gt;</code> 查看详细的标签信息</p>
<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：<br><code>git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</code></p>
<p><code>git tag -d v0.1</code> 删除标签</p>
<p><code>git push origin &lt;tagname</code> 推送某个标签到远程仓库</p>
<p><code>git push origin --tags</code> 一次性推送</p>
<p>从远程删除标签</p>
<ol>
<li>先本地删除 <code> git tag -d v0.9</code></li>
<li>再远程删除 命令也是push <code>git push origin :refs/tags/v0.9</code></li>
</ol>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>iterm2</title>
    <url>/2021/06/09/iterm2/</url>
    <content><![CDATA[<p>关于自己Mac电脑的iterm2终端美化配置方案</p>
<span id="more"></span>

<p><img src="/2021/06/09/iterm2/2.png" alt="2"></p>
<h1 id="oh-my-zsh-安装"><a href="#oh-my-zsh-安装" class="headerlink" title="oh-my-zsh 安装"></a>oh-my-zsh 安装</h1><p>一个美化要用的东西，iterm2就直接App store下载就行了</p>
<p>先切换命令 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<p>再安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>

<p>安装失败就先git clone</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br></pre></td></tr></table></figure>

<p>再替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>这样就好啦</p>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>命令高量 代码补全 和一个jump 文件夹<br>前两个不咋用 最后一个好用<br>先安装brew 然后</p>
<p><code>brew install autojump</code></p>
<p>然后编辑 vim ~/.zshrc 文件, 找到 plugins 配置, 增加 autojump 插件.</p>
<h1 id="窗口外观"><a href="#窗口外观" class="headerlink" title="窗口外观"></a>窗口外观</h1><p>就是下拉式嘛 看下面这些就好咯<br><a href="https://www.bilibili.com/read/cv8638110/">链接</a><br>配色 rgb(133,73,71)<br>字体 Andale Moto</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>react2</title>
    <url>/2021/06/24/react2/</url>
    <content><![CDATA[<p>看 三天精通react/ React学习手册 / the-road-to-learn-react / 读后感</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个问题</span><br><span class="line">setstate的同步异步问题</span><br><span class="line">setstate的调用生命周期问题</span><br></pre></td></tr></table></figure>

<p>《三天精通react》</p>
<h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><p>先明白什么是组件<br>这里书上和木犀101都给出了一个类似的概念<br><strong>UI=f(x)</strong><br>即每一个组件就是一个纯函数，不过这个纯函数的返回值是UI结构，函数里面的x就是用于驱动UI更新的数据，这种通过数据驱动 UI 变化的方式，叫<strong>声明式编程</strong>，而直接对UI操作的叫命令行编程，比如原生DOM，声明式在思维上是更高级的编程范式。</p>
<p>无状态组件就是没state，所有的数据通过props接收，这里有个写法就是css当作变量而不是写在css文件里面</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  props: React.PropsWithChildren&lt;&#123; color?: string; onClick?: () =&gt; <span class="keyword">void</span> &#125;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; color, children, onClick &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> style = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>: color,</span><br><span class="line">    <span class="attr">border</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="attr">padding</span>: <span class="string">&quot;4px 6px&quot;</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;white&quot;</span>,</span><br><span class="line">    <span class="attr">cursor</span>: <span class="string">&quot;pointer&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;children&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有状态组件 就是带着state的组件，Hooks里面就用usestate(),具体用法也都知道，但切记不要写在生命周期函数里面，比如ComponentDidUpdate(),这样会导致无限重绘，页面假死。</p>
<p>即setstate()函数用于驱动页面更新，但UI更新总是有原因的</p>
<ul>
<li>⽤⼾触发的交互，如：键盘输⼊、⿏标点击、屏幕滑动等</li>
<li>定时器的触发，如： setTimeout 、 requestAnimationFrame 、 setInterval</li>
<li>IO 事件回调触发，如：AJAX 请求返回的回调</li>
</ul>
<p>总结就是， setCount 操作必须在某个回调中调⽤，不应该出现在生命周期函数的同步调⽤栈中执⾏。</p>
<p>useState()接收的参数是state的初始值，但在下列情况下需要接收函数作为参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始状态需要复杂计算</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> initialCount = props.data.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="function">() =&gt;</span> props.data.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始状态是复杂对象</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> [initialState, setState] = useState(&#123;</span><br><span class="line"><span class="attr">attr1</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line"><span class="attr">attr2</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="attr">attr50</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [initialState, setState] = useState(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line"><span class="attr">attr1</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line"><span class="attr">attr2</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="attr">attr50</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>传函数的好处是，当依赖 state ⾃⾝最新状态来更新状态时，不需要访问外部变量</p>
<h1 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h1><p>当需要存放⼀个数据，需要⽆论在哪⾥都取到最新状态时，需要使⽤ useRef。（实际开发少用，影响效率）</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>map()中的key</title>
    <url>/2021/06/09/map-%E4%B8%AD%E7%9A%84key/</url>
    <content><![CDATA[<p> 经典面试题:<br>      1). react/vue中的key有什么作用？（key的内部原理是什么？）<br>      2). 为什么遍历列表时，key最好不要用index?</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 虚拟DOM中key的作用：</span><br><span class="line">1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</span><br><span class="line">2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】,随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：</span><br><span class="line">a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：</span><br><span class="line">(1).若虚拟DOM中内容没变, 直接使用之前的真实DOM</span><br><span class="line">(2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</span><br><span class="line">b. 旧虚拟DOM中未找到与新虚拟DOM相同的key，根据数据创建新的真实DOM，随后渲染到到页面</span><br><span class="line">2. 用index作为key可能会引发的问题：</span><br><span class="line">   1.) 若对数据进行：逆序添加、逆序删除等破坏顺序操作,会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</span><br><span class="line">2.) 如果结构中还包含输入类的DOM：会产生错误DOM更新 ==&gt; 界面有问题。</span><br><span class="line">3.) 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作,仅用于渲染列表用于展示，使用index作为key是没有问题的。</span><br><span class="line">3. 开发中如何选择key?:</span><br><span class="line">1.)最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</span><br><span class="line">2.)如果确定只是简单的展示数据，用index也是可以的。</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"> 慢动作回放----使用index索引值作为key</span><br><span class="line"></span><br><span class="line">     初始数据：</span><br><span class="line">         &#123;id:1,name:&#x27;小张&#x27;,age:18&#125;,</span><br><span class="line">         &#123;id:2,name:&#x27;小李&#x27;,age:19&#125;,</span><br><span class="line">     初始的虚拟DOM：</span><br><span class="line">         &lt;li key=0&gt;小张---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li key=1&gt;小李---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">     更新后的数据：</span><br><span class="line">         &#123;id:3,name:&#x27;小王&#x27;,age:20&#125;,</span><br><span class="line">         &#123;id:1,name:&#x27;小张&#x27;,age:18&#125;,</span><br><span class="line">         &#123;id:2,name:&#x27;小李&#x27;,age:19&#125;,</span><br><span class="line">         更新数据后的虚拟DOM：</span><br><span class="line">         &lt;li key=0&gt;小王---20&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li key=1&gt;小张---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li key=2&gt;小李---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">慢动作回放----使用id唯一标识作为key</span><br><span class="line"></span><br><span class="line">初始数据：</span><br><span class="line">&#123;id:1,name:&#x27;小张&#x27;,age:18&#125;,</span><br><span class="line">&#123;id:2,name:&#x27;小李&#x27;,age:19&#125;,</span><br><span class="line">初始的虚拟DOM：</span><br><span class="line">&lt;li key=1&gt;小张---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line">&lt;li key=2&gt;小李---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">更新后的数据：</span><br><span class="line">&#123;id:3,name:&#x27;小王&#x27;,age:20&#125;,</span><br><span class="line">&#123;id:1,name:&#x27;小张&#x27;,age:18&#125;,</span><br><span class="line">&#123;id:2,name:&#x27;小李&#x27;,age:19&#125;,</span><br><span class="line">更新数据后的虚拟DOM：</span><br><span class="line">&lt;li key=3&gt;小王---20&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line">&lt;li key=1&gt;小张---18&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br><span class="line">&lt;li key=2&gt;小李---19&lt;input type=&quot;text&quot;/&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>react源码初探</title>
    <url>/2021/09/15/react%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>总算到这一步了 看react源码部分的笔记</p>
<span id="more"></span>

<h1 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h1><p>Virtual DOM 是 React 的核心与精髓所在,React就是靠着VDOM和高效的diff算法大量减少了渲染DOM的代价。<br>VDOM中转换成浏览器中真实的DOM树，即VDOM其实也存在于树这种数据结构中，那他就会有自己的节点，他的节点被称为 ReactNode， 分为3种类型 ReactElement、ReactFragment 和ReactText，其中，ReactElement 又分为 ReactComponentElement 和 ReactDOMElement。<br>先看看这些类型源码，涉及到Ts部分、</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReactNode = ReactElement | ReactFragment | ReactText;</span><br><span class="line"><span class="keyword">type</span> ReactElement = ReactComponentElement | ReactDOMElement;</span><br><span class="line"><span class="keyword">type</span> ReactDOMElement = &#123; <span class="attr">type</span> : <span class="built_in">string</span>,</span><br><span class="line"><span class="attr">props</span> : &#123;</span><br><span class="line"><span class="attr">children</span> : ReactNodeList, <span class="attr">className</span> : <span class="built_in">string</span>,</span><br><span class="line">etc.</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">key</span> : <span class="built_in">string</span> | <span class="built_in">boolean</span> | <span class="built_in">number</span> | <span class="literal">null</span>, <span class="attr">ref</span> : <span class="built_in">string</span> | <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> ReactComponentElement&lt;TProps&gt; = &#123; <span class="attr">type</span> : ReactClass&lt;TProps&gt;,</span><br><span class="line">props : TProps,</span><br><span class="line"><span class="attr">key</span> : <span class="built_in">string</span> | <span class="built_in">boolean</span> | <span class="built_in">number</span> | <span class="literal">null</span>, <span class="attr">ref</span> : <span class="built_in">string</span> | <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> ReactFragment = <span class="built_in">Array</span>&lt;ReactNode | ReactEmpty&gt;; <span class="keyword">type</span> ReactNodeList = ReactNode | ReactEmpty;</span><br><span class="line"><span class="keyword">type</span> ReactText = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> ReactEmpty = <span class="literal">null</span> | <span class="literal">undefined</span> | <span class="built_in">boolean</span>;</span><br></pre></td></tr></table></figure>
<p>然后我们写JSX的时候，react会帮我吗掉createElement方法构造虚拟节点，这是个蛮重要的部分，直接上代码</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// createElement 只是做了简单的参数修正，返回一个 ReactElement 实例对象， // 也就是虚拟元素的实例</span></span><br><span class="line">ReactElement.createElement = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">type</span>, config, children</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 初始化参数</span></span><br><span class="line"><span class="keyword">var</span> propName;</span><br><span class="line"><span class="keyword">var</span> props = &#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> key = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">var</span> ref = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">var</span> self = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">var</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在 config，则提取里面的内容 if (config != null) &#123;</span></span><br><span class="line"><span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">  ref = config.ref === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.ref;</span><br><span class="line">  key = config.key === <span class="literal">undefined</span> ? <span class="literal">null</span> : <span class="string">&#x27;&#x27;</span> + config.key;</span><br><span class="line">  self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self; </span><br><span class="line">  source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source; </span><br><span class="line"><span class="comment">// 复制 config 里的内容到 props(如 id 和 className 等)</span></span><br><span class="line">  <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.hasOwnProperty(propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class="line">      props[propName] = config[propName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 children，全部挂载到 props 的 children 属性上。如果只有一个参数，直接赋值给 children， // 否则做合并处理</span></span><br><span class="line"><span class="keyword">var</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">  props.children = children;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> childArray = <span class="built_in">Array</span>(childrenLength); </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">    childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>]; </span><br><span class="line">  &#125;</span><br><span class="line">  props.children = childArray; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果某个 prop 为空且存在默认的 prop，则将默认 prop 赋给当前的 prop </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">type</span> &amp;&amp; <span class="keyword">type</span>.defaultProps) &#123;</span><br><span class="line">  <span class="keyword">var</span> defaultProps = <span class="keyword">type</span>.defaultProps;</span><br><span class="line">  <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> props[propName] === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">       props[propName] = defaultProps[propName];</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回一个 ReactElement 实例对象</span></span><br><span class="line"><span class="keyword">return</span> ReactElement(<span class="keyword">type</span>, key, ref, self, source, ReactCurrentOwner.current, props); &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><p>Virtual DOM 模型通过 createElement 创建虚拟元素，那又是如何创建组件的呢?</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>高阶组件</title>
    <url>/2021/09/13/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>呜呜呜介绍一下高阶组件</p>
<span id="more"></span>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>这里直接看官方文档: <strong>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。</strong><br>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p>
<p>官方文档用了一个demo解释了一下，这里我就说个大概，就是当我们需要两个组件，一个是CommentList用于获取用户评论，一个是BlogPost用于订阅单篇博客，他们都共享<strong>订阅数据————渲染————取消订阅</strong>这么一个逻辑，这样我们就可以把这个公共逻辑抽象成一个函数，这个函数就是一个<strong>高阶组件</strong>，因为这个函数接受了一个普通组件作为参数返回了一个有着订阅逻辑后的新组件，直接上代码: (这里我随便写写，跟官方不一样了)</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本组件逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CommentList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState()</span><br><span class="line">  useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    DataSource.getComment(handleChange())<span class="comment">//获取订阅</span></span><br><span class="line">    <span class="keyword">return</span> DataSource.removeComment(handleChange())<span class="comment">//清除订阅</span></span><br><span class="line">  &#125;)</span><br><span class="line">  handleChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setData(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handleChange&#125;</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlogPost</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState()</span><br><span class="line">  useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    DataSource.getBlog(handleChange())<span class="comment">//获取订阅</span></span><br><span class="line">    <span class="keyword">return</span> DataSource.removeBlog(handleChange())<span class="comment">//清除订阅</span></span><br><span class="line">  &#125;)</span><br><span class="line">  handleChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setData(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handleChange&#125;</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶组件函数</span></span><br><span class="line"></span><br><span class="line">getDataComp = <span class="function">(<span class="params">Comp, getDataType,removeDataType</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      DataSource.getDataType()</span><br><span class="line">      <span class="keyword">return</span> DataSource.removeDateType()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setData(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">data</span>=<span class="string">&#123;state.data&#125;</span> <span class="attr">props</span>=<span class="string">&#123;...props&#125;/</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的订阅数据就会作为props传递了，可能这里我写的没有很明白，那就还是可以去官方文档看看。<br>然后高阶组件是纯函数，绝不要在高阶组件中修改原组件模型，并且要将不向关的props传给被包裹的组件，大多数 HOC 都应该包含一个类似于下面的 render 方法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 过滤掉非此 HOC 额外的 props，且不要进行透传</span></span><br><span class="line">  <span class="keyword">const</span> &#123; extraProp, ...passThroughProps &#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 props 注入到被包装的组件中。</span></span><br><span class="line">  <span class="comment">// 通常为 state 的值或者实例方法。</span></span><br><span class="line">  <span class="keyword">const</span> injectedProp = someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 props 传递给被包装组件</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">injectedProp</span>=<span class="string">&#123;injectedProp&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      &#123;<span class="attr">...passThroughProps</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mad 写着写着突然发现，自定义hook是不是可以代替高阶组件和 render props？？？哇日！？我麻了我麻了我麻了<br>这东西可以深挖，先放一放</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>todolist-hooks</title>
    <url>/2021/05/09/todolist-hooks/</url>
    <content><![CDATA[<p>用hooks写了份todolist，刚好就借这份project写出一些hooks的使用方法</p>
<span id="more"></span>
<h1 id="hooks基本语法介绍"><a href="#hooks基本语法介绍" class="headerlink" title="hooks基本语法介绍"></a>hooks基本语法介绍</h1><h2 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a>State Hook</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作</span><br><span class="line">(2). 语法: const [xxx, setXxx] = React.useState(initValue)  </span><br><span class="line">(3). useState()说明:</span><br><span class="line">        参数: 第一次初始化指定的值在内部作缓存</span><br><span class="line">        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数</span><br><span class="line">(4). setXxx()2种写法:</span><br><span class="line">        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值</span><br><span class="line">        setXxx(value =&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</span><br></pre></td></tr></table></figure>



<h2 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a>Effect Hook</h2><pre><code>    (1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)
    (2). React中的副作用操作:
            发ajax请求数据获取
            设置订阅 / 启动定时器
            手动更改真实DOM
    (3). 语法和说明: 
            useEffect(() =&gt; &#123; 
            // 在此可以执行任何带副作用操作
            return () =&gt; &#123; // 在组件卸载前执行
                // 在此做一些收尾工作, 比如清除定时器/取消订阅等
            &#125;
            &#125;, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行
            第二个参数限制了调用这个hooks的范围，则就会只有在statevalue发生改变时调用这个hook
        
    (4). 可以把 useEffect Hook 看做如下三个函数的组合
            componentDidMount()
            componentDidUpdate()
            componentWillUnmount() 
</code></pre>
<h2 id="Ref-Hook"><a href="#Ref-Hook" class="headerlink" title="Ref Hook"></a>Ref Hook</h2><pre><code>    (1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据
    (2). 语法: const refContainer = useRef()
    (3). 作用:保存标签对象,功能与React.createRef()一样
</code></pre>
<h2 id="自定义Hook与其他Hooks-API"><a href="#自定义Hook与其他Hooks-API" class="headerlink" title="自定义Hook与其他Hooks API"></a>自定义Hook与其他Hooks API</h2><p>这部分内容比较多，详情右边搜索关于hooks的详细博客，这里就先介绍最基础的三个。</p>
<h1 id="Todolist"><a href="#Todolist" class="headerlink" title="Todolist"></a>Todolist</h1><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>了解了hooks的基本语法，我们就正式开始写这份todolist的project吧。<br>先看项目的基本UI<br><img src="/2021/05/09/todolist-hooks/todolist.png" alt="td"><br>这算是比较基本的UI了，我们就从上往下拆分组件，可以拆解为<br>                1. 头部部分的输入框:Input 这可以包括标题的Todo，因为只是基本的样式没有交互效果，可以简单的与Input放在一起，叫他header组件也没什么问题<br>                2. 容器组件：List<br>                        3. List组件中的Item组件，这份todo就是个列表嘛，那必然就可以分类列表的容器组件和负责展示的Item组件<br>                4.尾部组件：Filter 其实叫他Footer组件也行，但他有三种不同的筛选状态，就叫他Filter吧</p>
<p>组件拆解完毕后，其中的html放在render（）/return（）里， css就作为文件放在对应的文件夹中，结构如图<br><img src="/2021/05/09/todolist-hooks/components.png" alt="cp">  </p>
<p><strong>这里的css样式文件我就没有拆了，因为是直接拿来的文件，不太分得清从哪开始拆，也没注释，实际自己写的时候一定要拆的</strong></p>
<h1 id="组件通信方式总结"><a href="#组件通信方式总结" class="headerlink" title="组件通信方式总结"></a>组件通信方式总结</h1><p>写完静态页面后就根据需求加交互效果呗，这里就会涉及到react组件之间如何传递数据，下面是一些总结</p>
<h2 id="组件间的关系："><a href="#组件间的关系：" class="headerlink" title="组件间的关系："></a>组件间的关系：</h2><ul>
<li>父子组件</li>
<li>兄弟组件（非嵌套组件）</li>
<li>祖孙组件（跨级组件）</li>
</ul>
<h2 id="几种通信方式："><a href="#几种通信方式：" class="headerlink" title="几种通信方式："></a>几种通信方式：</h2><pre><code>    1.props：
        (1).children props
        (2).render props
    2.消息订阅-发布：
        pubs-sub、event等等
    3.集中式管理：
        redux、dva等等
    4.conText:
        生产者-消费者模式
</code></pre>
<h2 id="比较好的搭配方式："><a href="#比较好的搭配方式：" class="headerlink" title="比较好的搭配方式："></a>比较好的搭配方式：</h2><pre><code>    父子组件：props
    兄弟组件：消息订阅-发布、集中式管理
    祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)
</code></pre>
<p>因为todolist算是比较简单的，我们就拿<strong>状态提升</strong>来写。</p>
<h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>就是把一些可以共享state的组件们的state提到他们共同的父组件中去，简单来说，这份数据你也要我也要他也要，但是我们一人写一份就很麻烦，不如把state交给一个老父亲，让他按需求发给我们就好了。<br>所以我们就在App组件中定义state,todos都知道是个列表嘛，我们就把todos看成一个对象数组，每个todo</p>
<pre><code>            const[todos,setTodos] = useState([])
</code></pre>
<p>初始化好后就用props把todos传下去呗，这样每个自组件都能共享这个state了</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>接下来开始写第一个功能，按照组件顺序自然就从Input开始。</p>
<h3 id="增加一个todo列表"><a href="#增加一个todo列表" class="headerlink" title="增加一个todo列表"></a>增加一个todo列表</h3><p>我们给这个事件函数命名为handleAdd(),组件内的函数一般都命名为handleXx<br>无非就是按下回车后给todo这个空数组添加一个元素todo对象呗<br>先给输入框绑定键盘事件</p>
<pre><code>            &lt;input onKeyUp=&#123;handleAdd&#125;&gt; //onKeyUp就是键盘按下后弹起就会触发
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleAdd</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; keyCode, target &#125; = e</span><br><span class="line">      <span class="keyword">if</span> (keyCode !== <span class="number">13</span>) <span class="keyword">return</span> <span class="comment">//判断是否为回车</span></span><br><span class="line">      <span class="keyword">const</span> todoObj = &#123; <span class="attr">id</span>: nanoid(), <span class="attr">content</span>: target.value, <span class="attr">completed</span>: <span class="literal">false</span>, <span class="attr">flag</span>: <span class="literal">true</span>, <span class="attr">editing</span>: <span class="literal">false</span> &#125; <span class="comment">//nanoid用于唯一生成唯一id，安装后引入就行，其他的属性是根据需求来添加的</span></span><br><span class="line">      props.addTodo(todoObj) <span class="comment">//因为state在App中，所以调用App中的方法来进行更新</span></span><br><span class="line">      target.value = <span class="string">&#x27;&#x27;</span>  <span class="comment">//清空输入框</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如上行所示，虽然你通过props接受到了state，可想要更新state，还得回App中，因为state在哪儿，操作state的方法就在哪儿 所以就得来个回调嘛<br>addTodo的具体函数如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">todoObj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> newTodos = [todoObj, ...todos]<span class="comment">// 注明一下为什么用扩展运算符而不用数组的push方法添加元素对象，因为push方法不是纯函数，他产生的新数组和原数组的指针指向不是同一个地址，可能回产生一些不必要的bug，所以就一般不用这些方法。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>关于纯函数以及函数的副作用等也可以右边搜索相关的详细解析博客啦</p>
<h3 id="完成所有todo"><a href="#完成所有todo" class="headerlink" title="完成所有todo"></a>完成所有todo</h3><p>这就是Input组件的第二个需求，也很简单，先handleCompleteAll调用App内相对应的方法，再用数组的map方法让每一个todo对象的completed属性变成true就可以了</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>这个组件没什么好说的，就是一个容器组件，把相应的state和方法用props传给Item就行<br>不过还是有一个需要注意的点，就是之前说过List其实可以看作是一个数组，Item是里面的元素，所以每一个Item都应该由map方法展示，代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &#123;todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Item</span>/&gt;</span></span>)&#125;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h2><p>这个需求就比较多啦<br>编辑 删除 完成<br>还有随着state的改变样式也跟着等等<br>不过具体思路还是和上面一样，也就不赘述啦</p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>对于需求方法也没什么好说的，还是同上<br>不过要注意一点，实现排他思想的tab栏切换<br>思路就是，把id放在state里面，每次点击一个tab栏的时候，就会传入自己的id变成state，这样只有自己的id和state吻合的时候才会实现单个tab选项卡高亮的效果</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>上面就是关于这个小项目的总结啦，好说这也是自己写的第一个react项目，也花了一些时间，写一篇博客记录下来，算是加强理解吧</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>初探动态规划/回溯</title>
    <url>/2021/09/15/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>数据结构上刷算法… 好说歹说算是入门了</p>
<span id="more"></span>

<h1 id="何为动态规划"><a href="#何为动态规划" class="headerlink" title="何为动态规划"></a>何为动态规划</h1><p>怎么说呢，动态规划就是是一种分治的思想，换句话说，就是把一个大问题，拆分成小问题，再把小问题接着拆分，拆到无可再分的时候，会得到最小的子问题，而子问题的答案很轻松就能得到，根据这个答案递推回去，就能得到原本问题的答案，是一种自底而上的做法。（当然也有自顶而下的方法）。动态规划核心套路是“穷举求最优解”，然后利用状态转移方程进行<strong>正确的穷举</strong>，也就是取消重叠子问题。<br>即，动态规划分治穷举后，两个重要特性就是 <strong>重叠子问题</strong>和<strong>最优子结构</strong></p>
<h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p>刚刚提到一个核心的概念，就是状态转移方程，这是做动态规划类问题最重要的一个步骤，也是最抽象的一个步骤，我们能想到状态转移方程就代表这道题我们理解了大半了，我们由斐波那契数列入手来引出这个概念。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span> (<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单吧，直接暴力递归，但是贼低效，鲁迅说过“所有递归问题都可以看作是树问题”，那我们就看看这个递归调用时的树，假设i = 20;<br><img src="/2021/09/15/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/fib.png" alt="fib"><br>看看时间复杂度？O(2^n)，直接裂开来，而且你会发现有大量的重复计算，比如f(18)和f(17)都被计算了两次，更往下的子节点被重复计算的次数更多，这就是之前提到的<strong>重叠子问题</strong>，所以为了解决这个问题，我们引入一个备忘录。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span> (<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">  dp[<span class="number">1</span>] = dp [<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] +  dp[i - <span class="number">2</span>]</span><br><span class="line">  <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这我们可以得知，我们知道这是第n代的兔子，让我们去求第n代兔子的总数，也就是dp(n),并且dp(n) = dp(n-1) + dp(n-2)，哎，那求dp(n)的问题是不是就转移到求dp(n-1) + dp(n-2)了，这个就叫状态转移方程，当然不要忘了n = 1 和n = 2的情况。综上，我们得到斐波那契数列的状态转移方程</p>
<p>dp(n) = { 1,  n = 1,2<br>{dp(n-1) + dp(n-2), n &gt; 2</p>
<p>这里解决了<strong>重叠子问题</strong>，那动态规划另一个重要特性<strong>最优子结构</strong>呢？<br>因为斐波那契不算真正的动态规划问题，写这个主要是为了引入如何抽象出状态转移方程，对于最优子结构，让我们往下看。</p>
<h2 id="典中典的凑硬币"><a href="#典中典的凑硬币" class="headerlink" title="典中典的凑硬币"></a>典中典的凑硬币</h2><p>说起动态规划就不得不提凑硬币的问题，太经典了属于是。再说凑硬币问题前我们简单聊一聊贪心算法，贪心算法其实是动态规划的一个特例，动态规划是一只分分分分分到最后找出最优解，而贪心是先分解若干个子问题，找出最优，再从这个最优子问题中接着分解，也就是说<strong>贪心算法是每一都要求出最优解的动态规划问题</strong>。<br>这里说回来凑硬币问题，比如我们有面值为1，5，11元的硬币，要求凑出15元所用的最少硬币数。用贪心的话就是，第一步的最优解肯定是面值最大的11元，然后还差四元就需要用四枚一元硬币，一共五枚。而这道题真正的最优解其实是三枚五元硬币，这样就能看出贪心和动态规划的区别了。<br>那么这道题我们该如何思考呢？又或者是说怎么列出状态转移方程？仔细思考一下，我们之前有提到过动态分解到最小子问题后往上递归，也就是“自低而上”的思维，那这个问题的最底部显然就是0个硬币凑0元，再往上也就是一个硬币， 也就是凑了1，5，11元还剩14，10，4元，分别需要 dp[14]+1,dp[10]+1,dp[4]+1个，（这里dp[n]是凑n元需要的硬币数，这里因为要求最少硬币数，所以需要在dp[14],dp[10],dp[1]中找出最优的情况，所以底层往上的第一步，就是<br>dp[15] = min(dp[15-1],dp[15-5],dp[15-10])+1,这里15由未知数代替，考虑边界情况，也就是n&lt;=0的情况，那我们不就能得到状态转移方程了？<br>dp[n] = { 0 ,n&lt;=0<br>{min(dp[15 - coin]), n&gt;0<br>得到状态转移方程，再用自底而上的思维，得出代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> changeCoin = <span class="function">(<span class="params">coins,amount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化备忘录,用Infinity填满备忘录，Infinity说明该值不可以用硬币凑出来</span></span><br><span class="line">  <span class="keyword">let</span> dp = newArray(amount + <span class="number">1</span>).fill(<span class="literal">Infinity</span>)</span><br><span class="line">  dp[<span class="number">0</span>] = [<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> coin <span class="keyword">of</span> coins)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coin &lt;= i)</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - coin] + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[amount] === <span class="literal">Infinity</span> ? -<span class="number">1</span> : dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就结束啦！<br>那么最后，怎样判断一个问题是不是动态规划问题呢？<br>一般有</p>
<ul>
<li>求最大值，最小值</li>
<li>判断方案是否可行</li>
<li>统计方案个数</li>
<li>子问题是否满足最优子结构，即每个子问题都不影响其他子问题</li>
</ul>
<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>看完动态规划，我们就简单说一下回溯，回溯重点就是这个“回”字，他从本质上来说就是遍历决策树的过程，我们需要抓住这三点：</p>
<ul>
<li>路径 也就是做过的选择</li>
<li>选择列表 当前可以选择的部分</li>
<li>结束条件 到达决策树底部，没有新的选择</li>
</ul>
<p>回溯是有框架的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表): <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">result.add(路径) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表: 做选择</span><br><span class="line">backtrack(路径, 选择列表) 撤销选择</span><br></pre></td></tr></table></figure>
<p>可以看到 这串代码的核心是，递归调用 backtrack，并且在递归之前做选择，递归之后撤销选择就行。</p>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>最基本的回溯问题就是全排列问题了，就比如给我们【1，2，3】三个数字，求出他们不重复情况的全排列，可以得到以下决策树<br><img src="/2021/09/15/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/jueceshu.png" alt="jcs"><br>我们站在决策树的顶端，此时我们的选择列表是【1，2，3】，没有路径，因为我们还没做过选择，假设我们选择2后到达第二个节点，那么我们的选择列表是【1，3】，2就变成了我们的路径，然后 backtrack函数，就像是个指针，在这个树上游走，要维护每个节点的选择列表和路径，当它走到树的底层后，就触发了结束条件。<br>再然后，如何遍历一个树？ 要记住，所有搜索问题其实都是树的遍历问题，而多叉树的遍历，有两个重要框架，前序遍历和后序遍历，前序遍历在递归进入下一个节点前进行，后续遍历在进入一个节点后执行，前序遍历让多叉树得以向某一子节点递归，后序遍历可以让多叉树依次对多个子节点递归遍历，依照这个思路以及前面的框架，我们得出全排列代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> allSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  backTrack = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 判断是否满足结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(nums.length === path.length)&#123;</span><br><span class="line">      res.push([...path])  </span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决重复路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(path.indexOf(nums[i]) !== -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/** 前序遍历 */</span></span><br><span class="line">      path.push(nums[i])</span><br><span class="line"></span><br><span class="line">      backTrack(path)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 后序遍历</span></span><br><span class="line">      path.pop()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backTrack([])</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p>这个也是回溯经典啊，单比全排列稍微复杂一丢丢，题目的意思就是给我们一个N x N的棋盘，在上面摆N个皇后，让这些皇后不能互相攻击，问我们有几种摆法。<br>然后写回溯问题，我们一定要想明白它的决策树，和写动态规划要想明白df方程是一样的。<br>对于N皇后的决策树，我们可以想决策树的每一层，就是棋盘上的每一行，然后那一层的每一个节点，对应的就是棋盘上那一行的每个列。<br>直接套用上面框架</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Queen = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> board = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="string">&#x27;.&#x27;</span>.repeat(n))</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  isValid = <span class="function">(<span class="params">board, row, col</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = board.length</span><br><span class="line">    <span class="comment">//检查列皇后是否冲突</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(board[i][col] === <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左对角线冲突</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>,j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(board[i][j] === <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右对角线冲突，</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>,j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(board[i][j] === <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  repalceAt = <span class="function">(<span class="params">str,index,target</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> strAry = str.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    strAry[index] = target</span><br><span class="line">    <span class="keyword">return</span> strAry.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  backTrack = <span class="function">(<span class="params">board, row</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(row === board.length)&#123;</span><br><span class="line">      res.push([...board])</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> len = board.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; len; col++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!isValid(board,row,col))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//前序</span></span><br><span class="line">      board[row] = repalceAt(board[row],col,<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      backTrack(board, row + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//后序</span></span><br><span class="line">      board[row] =repalceAt(board[row],col,<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  backTrack(board,<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="回溯和动态规划"><a href="#回溯和动态规划" class="headerlink" title="回溯和动态规划"></a>回溯和动态规划</h2><p>至此回溯就简单的说到这了啊<br>这里我们看到回溯和动态规划的联系和区别，联系就是，二者都需要通过穷举来解题，但动态规划需要通过备忘录解决重叠子问题来优化并找出最佳答案，而回溯就算真正的暴力求解了。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>react</title>
    <url>/2021/06/09/react/</url>
    <content><![CDATA[<p><strong>写在前面</strong></p>
<p><strong>终于可以重新在新电脑(mbp)上写博客啦 话说为什么我的笔记是直接从react开始的…因为是刚好在学react 所以就先写点总结啦，后面会陆续补上html，css,Js的相关笔记博客的。感觉mos系统也要写点笔记，iterm2的命令行写点总结啥的 有点好用的嗦</strong><br>正式开始react相关笔记啦</p>
<span id="more"></span>
<h1 id="对React的理解"><a href="#对React的理解" class="headerlink" title="对React的理解"></a>对React的理解</h1><h2 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h2><ol>
<li>具体的理解有点说不上来，可能还是自己学太浅来。等后续理解深了用的多了再回来补。按照教程官网学长等各方面说法，react就是通过数据驱动虚拟DOM更新，不需要实际去操作DOM，大部分情况下state有更改那么UI就会出现变化，而state的更改又基于用户的操作，总之很方便。 </li>
<li>运用diff算法最小化重绘页面，加上操作虚拟DOM，就是react高效的两个原因</li>
<li>虚拟DOM其实就是一种特殊的JS一般对象，后续会被react渲染成真实DOM</li>
<li>一般运用JSX语法</li>
</ol>
<h1 id="React基本概念"><a href="#React基本概念" class="headerlink" title="React基本概念"></a>React基本概念</h1><p>概念好像和理解差不多…Emmmmm，那就写点详细的东西</p>
<h2 id="关于JSX"><a href="#关于JSX" class="headerlink" title="关于JSX"></a>关于JSX</h2><ol>
<li><p>全称:  JavaScript XML</p>
</li>
<li><p>react定义的一种类似于XML的JS扩展语法: JS + XML本质是React.createElement(component, props, …children)方法的语法糖</p>
</li>
<li><p>作用: 用来简化创建虚拟DOM </p>
<pre><code> 1)写法：var ele = &lt;h1&gt;; Hello JSX! &lt;/h1&gt;
 2)注意1：它不是字符串, 也不是HTML/XML标签
 3)注意2：它最终产生的就是一个JS对象
</code></pre>
</li>
<li><p>语法规则</p>
</li>
<li><p>jsx语法规则：</p>
<pre><code> 1).定义虚拟DOM时，不要写引号。
 2).标签中混入JS表达式时要用&#123;&#125;。
 3).样式的类名指定不要用class，要用className。
 4).内联样式，要用style=&#123;&#123;key:value&#125;&#125;的形式去写。
 5).只有一个根标签
 6).标签必须闭合
 7).标签首字母
 (1).若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错。
 (2).若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。
</code></pre>
</li>
<li><p>ReactDOM.render(VDOM,RDOM)</p>
</li>
<li><p>语法:  ReactDOM.render(virtualDOM, containerDOM)</p>
</li>
<li><p>作用: 将虚拟DOM元素渲染到页面中的真实容器DOM中显示</p>
</li>
<li><p>参数说明</p>
</li>
</ol>
<p>1)参数一: 纯js或jsx创建的虚拟dom对象<br>2)参数二: 用来包含虚拟DOM元素的真实dom元素对象(一般是一个div)</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h2><p> {里面放的是表达式}，表达式代表着一个值，而for循环啥的叫语句，不会产生值</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件:"></a>组件:</h2><p> <strong>比模块还牛的东西，就对一个页面来说拆就完了，拆到你想不出来这个组件到底能叫什么名字的时候就代表这个组件你已经成功的拆到底了</strong><br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 类式组件</span><br><span class="line">  (1)出hooks之前是主流，基本都用这个，hooks出来后也能用，但最好还是hooks嘛</span><br><span class="line">  (2)一些类的相关知识就详见于JS总结啦</span><br><span class="line">  (3)执行了ReactDOM.render(&amp;lt;MyComponent/&gt;.......之后，发生了什么？</span><br><span class="line">	1.React解析组件标签，找到了MyComponent组件。</span><br><span class="line">	2.发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。</span><br><span class="line">	3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。</span><br><span class="line">   (4)组件里面的render()方法是挂在类的原型对象上的，供组件使用，组件实例对象调用这个方法，那么就是render中的this就指向这个组件实例</span><br><span class="line">2. 函数式组件</span><br><span class="line">  (1)用hooks 贼香 hooks后面有笔记介绍的</span><br><span class="line">  (2)执行了ReactDOM.render(&amp;lt; MyComponent/&gt;.......之后，发生了什么？</span><br><span class="line">	1.React解析组件标签，找到了MyComponent组件。</span><br><span class="line">	2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中</span><br></pre></td></tr></table></figure></p>
<h2 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h2><p>1.表单非受控组件，提交的数据现用现取<br>就是用ref操作实际DOM，比如在表单中输入结束后，给button添加一个函数提交数据</p>
<p>2.表单受控组件，提交的数据存放在state中<br>在HTML的表单元素中，它们通常自己维护一套state，并随着用户的输入自己进行UI上的更新，这种行为是不被我们程序所管控的。而如果将React里的state属性和表单元素的值建立依赖关系，再通过onChange事件与setState()结合更新state属性，就能达到控制用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素就叫做受控组件。</p>
<h2 id="高阶函数和函数的柯里化"><a href="#高阶函数和函数的柯里化" class="headerlink" title="高阶函数和函数的柯里化"></a>高阶函数和函数的柯里化</h2><ol>
<li>当一个函数接受的参数是函数或者返回值是函数，那么这个函数就是高阶函数</li>
<li>柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式（给注册事件的回调函数传参）</li>
<li>不用柯里化的形式：在内莲函数中写一个回调 （）=&gt; func ,这个回调func就作为事件发生时的回调</li>
</ol>
<h1 id="React三大核心属性"><a href="#React三大核心属性" class="headerlink" title="React三大核心属性"></a>React三大核心属性</h1><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><ol>
<li>state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合)</li>
<li>组件被称为”状态机”, 通过更新组件的state来更新对应的页面显示(重新渲染组件)</li>
<li>总之就是 UI里面所有所有的可视改变，背后都代表着一种state某个值的改变，也就是说state中的数据驱动UI视图更新<br>state中的数据不可直接更改，必须利用setState() 方法重新渲染页面，是一个合并的动作而不是替换</li>
</ol>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p><em><strong>概念：</strong></em></p>
<ol>
<li>每个组件对象都会有props(properties的简写)属性</li>
<li>组件标签的所有属性都保存在props中(props也是个对象)</li>
</ol>
<p><em><strong>作用：</strong></em></p>
<ol>
<li>通过标签属性从组件外向组件内传递变化的数据</li>
<li>注意，组件内部不要修改react，广泛用于父子组件传递数据</li>
</ol>
<h2 id="refs与事件处理"><a href="#refs与事件处理" class="headerlink" title="refs与事件处理"></a>refs与事件处理</h2><ol>
<li><p>理解： 一组kv对象,key是refs，value是当前使用ref的一个节点，用于标识节点（可代替id)<br>就是获取当前用ref标识的节点 有点类似于操作真实的DOM了，所以实际开发中最好不要使用，不然容易引起效率问题。</p>
</li>
<li><p>使用</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). 字符串形式 //已经废弃了</span><br><span class="line">&lt;input ref=&quot;input1&quot;/&gt;</span><br><span class="line">(2). 回调形式</span><br><span class="line">&lt;input ref=&#123;(c)=&gt;&#123;this.input1 = c&#125;&#125;/&gt;</span><br><span class="line">(3). createRef</span><br><span class="line">myRef = React.createRef()  &lt;input ref=&#123;this.myRef&#125;/&gt;</span><br><span class="line"></span><br><span class="line">事件处理</span><br><span class="line">三种形式，和原生一样，但最好还是用内联的方式，因为其他两种在操作真实的DOM</span><br><span class="line">a. React使用的是自定义(合成)事件, 而不是使用的原生DOM事件 —————— 为了更好的兼容性</span><br><span class="line">b. React中的事件是通过事件委托方式处理的(委托给组件最外层的元素) ————————为了的高效</span><br></pre></td></tr></table></figure>

<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>新钩子<br><img src="/2021/06/09/react/1.png" alt="1"><br>旧钩子<br><img src="/2021/06/09/react/2.png" alt="2"><br>区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1).废弃了三个钩子</span><br><span class="line">1.componentWillMount</span><br><span class="line">2.componentWillReceiveProps</span><br><span class="line">3.componentWillUpdate</span><br><span class="line">2).重要的钩子</span><br><span class="line">1.render：初始化渲染或更新渲染调用</span><br><span class="line">2.componentDidMount：开启监听, 发送ajax请求，订阅与发布，开启定时器等等</span><br><span class="line">3.componentWillUnmount：做一些收尾工作, 如: 清理定时器</span><br></pre></td></tr></table></figure>



<h1 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h1><p><code>npx create-react-app xx</code><br>即用于快速创建一个基于react模版的项目</p>
<h2 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1.项目结构"></a>1.项目结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ---- 静态资源文件夹</span><br><span class="line">		favicon.icon ------ 网站页签图标</span><br><span class="line">		index.html -------- 主页面</span><br><span class="line">		logo192.png ------- logo图</span><br><span class="line">		logo512.png ------- logo图</span><br><span class="line">		manifest.json ----- 应用加壳的配置文件</span><br><span class="line">		robots.txt -------- 爬虫协议文件</span><br><span class="line">src ---- 源码文件夹</span><br><span class="line">		App.css -------- App组件的样式</span><br><span class="line">		App.js --------- App组件</span><br><span class="line">		App.test.js ---- 用于给App做测试</span><br><span class="line">		index.css ------ 样式</span><br><span class="line">		index.js ------- 入口文件</span><br><span class="line">		logo.svg ------- logo图</span><br><span class="line">		reportWebVitals.js</span><br><span class="line">			--- 页面性能分析文件(需要web-vitals库的支持)</span><br><span class="line">		setupTests.js</span><br><span class="line">			---- 组件单元测试的文件(需要jest-dom库的支持)</span><br></pre></td></tr></table></figure>
<h2 id="2-编码流程"><a href="#2-编码流程" class="headerlink" title="2.编码流程"></a>2.编码流程</h2><ol>
<li>拆分组件: 拆分界面,抽取组件</li>
<li>实现静态组件: 使用组件实现静态页面效果</li>
<li>实现动态组件 3.1 动态显示初始化数据<pre><code> 3.1.1 数据类型
 3.1.2 数据名称
 3.1.2 保存在哪个组件?
</code></pre>
 3.2 交互(从绑定事件监听开始)</li>
</ol>
<h2 id="3-具体项目-详情可见todolist分享"><a href="#3-具体项目-详情可见todolist分享" class="headerlink" title="3.具体项目: 详情可见todolist分享"></a>3.具体项目: 详情可见todolist分享</h2><h1 id="React-AJAX"><a href="#React-AJAX" class="headerlink" title="React AJAX"></a>React AJAX</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>1.React本身只关注于界面, 并不包含发送ajax请求的代码<br>2.前端应用需要通过ajax请求与后台进行交互(json数据)<br>3.react应用中需要集成第三方ajax库(或自己封装)</p>
<h2 id="常用AJAX库"><a href="#常用AJAX库" class="headerlink" title="常用AJAX库"></a>常用AJAX库</h2><p>1.jQuery: 比较重, 如果需要另外引入不建议使用<br>2.axios: 轻量级, 建议使用<br>1)封装XmlHttpRequest对象的ajax<br>2) promise风格<br>3)可以用在浏览器端和node服务器端</p>
<p><strong>关于AJAX/axios和fetch的区别与运用，有一篇专门的博客 去&lt;——搜一下就好啦（可能还放在了GitHub搜索用户里面</strong></p>
<h1 id="React-路由"><a href="#React-路由" class="headerlink" title="React 路由"></a>React 路由</h1><h2 id="1-SPA的理解"><a href="#1-SPA的理解" class="headerlink" title="1.SPA的理解"></a>1.SPA的理解</h2><p>1.单页Web应用（single page web application，SPA）。<br>2.整个应用只有一个完整的页面。<br>3.点击页面中的链接不会刷新页面，只会做页面的局部更新。<br>4.数据都需要通过ajax请求获取, 并在前端异步展现。</p>
<h2 id="2-路由的理解"><a href="#2-路由的理解" class="headerlink" title="2.路由的理解"></a>2.路由的理解</h2><p>1.什么是路由?<br>1.一个路由就是一个映射关系(key:value)<br>2.key为路径, value可能是function或component<br>2.路由分类<br>1.后端路由：<br>1)理解： value是function, 用来处理客户端提交的请求。<br>2)注册路由： router.get(path, function(req, res))<br>3)工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据<br>2.前端路由：<br>1)浏览器端路由，value是component，用于展示页面内容。<br>2)注册路由: <code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code><br>3)工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件</p>
<h2 id="3-react-router-dom的理解"><a href="#3-react-router-dom的理解" class="headerlink" title="3.react-router-dom的理解"></a>3.react-router-dom的理解</h2><p>1.react的一个插件库。<br>2.专门用来实现一个SPA应用。<br>基于react的项目基本都会用到此库。</p>
<h2 id="4-内置组件"><a href="#4-内置组件" class="headerlink" title="4.内置组件"></a>4.内置组件</h2><pre><code>    1.&lt;BrowserRouter&gt;
    2.&lt;HashRouter&gt;
    3.&lt;Route&gt;
    4.&lt;Redirect&gt;
    5.&lt;Link&gt;
    6.&lt;NavLink&gt;
    7.&lt;Switch&gt;

    // 其它
    1.history对象
    2.match对象
    3.withRouter函数
</code></pre>
<h1 id="流行的开源React-UI组件库"><a href="#流行的开源React-UI组件库" class="headerlink" title="流行的开源React UI组件库"></a>流行的开源React UI组件库</h1><p>I. material-ui(国外)<br>1.官网: <a href="http://www.material-ui.com/#/">http://www.material-ui.com/#/</a><br>2.github: <a href="https://github.com/callemall/material-ui">https://github.com/callemall/material-ui</a><br>II. ant-design(国内蚂蚁金服)<br>1.官网: <a href="https://ant.design/index-cn">https://ant.design/index-cn</a><br>Github: <a href="https://github.com/ant-design/ant-design/">https://github.com/ant-design/ant-design/</a></p>
<p><code>关于蚂蚁金服的使用请左栏搜索啦</code></p>
<h1 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h1><h2 id="setState更新状态的2种写法"><a href="#setState更新状态的2种写法" class="headerlink" title="setState更新状态的2种写法"></a>setState更新状态的2种写法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). setState(stateChange, [callback])------对象式的setState</span><br><span class="line">    1.stateChange为状态改变对象(该对象可以体现出状态的更改)</span><br><span class="line">    2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用</span><br><span class="line">					</span><br><span class="line">(2). setState(updater, [callback])------函数式的setState</span><br><span class="line">    1.updater为返回stateChange对象的函数。</span><br><span class="line">    2.updater可以接收到state和props。</span><br><span class="line">    4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</span><br><span class="line">总结:</span><br><span class="line">	1.对象式的setState是函数式的setState的简写方式(语法糖)</span><br><span class="line">	2.使用原则：</span><br><span class="line">		(1).如果新状态不依赖于原状态 ===&gt; 使用对象方式</span><br><span class="line">		(2).如果新状态依赖于原状态 ===&gt; 使用函数方式</span><br><span class="line">		(3).如果需要在setState()执行后获取最新的状态数据, </span><br><span class="line">		要在第二个callback函数中读取</span><br></pre></td></tr></table></figure>



<h1 id="lazyLoad"><a href="#lazyLoad" class="headerlink" title="lazyLoad"></a>lazyLoad</h1><h2 id="路由组件的lazyLoad"><a href="#路由组件的lazyLoad" class="headerlink" title="路由组件的lazyLoad"></a>路由组件的lazyLoad</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包</span></span><br><span class="line"><span class="keyword">const</span> Login = lazy(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;@/pages/Login&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面</span></span><br><span class="line">&lt;Suspense fallback=&#123;<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>loading.....<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">       <span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/xxx&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Xxxx&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">           <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line">   &lt;/Suspense&gt;</span><br></pre></td></tr></table></figure>


<h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>&lt;Fragment&gt;&lt;Fragment&gt;
&lt;&gt;&lt;/&gt;
</code></pre>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>可以不用必须有一个真实的DOM根标签了</p>
<hr>


<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p> 一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1) 创建Context容器对象：</span></span><br><span class="line">	<span class="keyword">const</span> XxxContext = React.createContext()  </span><br><span class="line">	<span class="keyword">const</span> &#123;Provider,Consumer&#125; = XxxContext</span><br><span class="line">	</span><br><span class="line"><span class="comment">//2) 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据：</span></span><br><span class="line">	&lt;xxxContext.Provider value=&#123;数据&#125;&gt;</span><br><span class="line">		子组件</span><br><span class="line">    &lt;/xxxContext.Provider&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//3) 后代组件读取数据：</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式:仅适用于类组件 </span></span><br><span class="line">	  <span class="keyword">static</span> contextType = xxxContext  <span class="comment">// 声明接收context</span></span><br><span class="line">	  <span class="keyword">const</span> &#123;value&#125; = <span class="built_in">this</span>.context <span class="comment">// 读取context中的value数据</span></span><br><span class="line">	  </span><br><span class="line">	<span class="comment">//第二种方式: 函数组件与类组件都可以</span></span><br><span class="line">	  &lt;xxxContext.Consumer&gt;</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="function"><span class="params">value</span> =&gt;</span> ( <span class="comment">// value就是context中的value数据</span></span><br><span class="line">	        要显示的内容</span><br><span class="line">	      )</span><br><span class="line">	    &#125;</span><br><span class="line">	  &lt;/xxxContext.Consumer&gt;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><pre><code>在应用开发中一般不用context, 一般都它的封装react插件
</code></pre>
<hr>


<h1 id="组件优化"><a href="#组件优化" class="headerlink" title="组件优化"></a>组件优化</h1><h2 id="Component的2个问题"><a href="#Component的2个问题" class="headerlink" title="Component的2个问题"></a>Component的2个问题</h2><ol>
<li><p>只要执行setState(),即使不改变状态数据, 组件也会重新render()</p>
</li>
<li><p>只当前组件重新render(), 就会自动重新render子组件 ==&gt; 效率低</p>
</li>
</ol>
<h2 id="效率高的做法"><a href="#效率高的做法" class="headerlink" title="效率高的做法"></a>效率高的做法</h2><p> 只有当组件的state或props数据发生改变时才重新render()</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p> Component中的shouldComponentUpdate()总是返回true</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><pre><code>办法1: 
    重写shouldComponentUpdate()方法
    比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false
办法2:  
    使用PureComponent 从&#39;react&#39;中引进
    PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true
    注意: 
        只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  
        不要直接修改state数据, 而是要产生新数据
项目中一般使用PureComponent来优化
</code></pre>
<hr>


<h1 id="render-props-类似于Vue的插槽技术"><a href="#render-props-类似于Vue的插槽技术" class="headerlink" title="render props (类似于Vue的插槽技术 )"></a>render props (类似于Vue的插槽技术 )</h1><h2 id="如何向组件内部动态传入带内容的结构-标签"><a href="#如何向组件内部动态传入带内容的结构-标签" class="headerlink" title="如何向组件内部动态传入带内容的结构(标签)?"></a>如何向组件内部动态传入带内容的结构(标签)?</h2><pre><code>Vue中: 
    使用slot技术, 也就是通过组件标签体传入结构  &lt;AA&gt;&lt;BB/&gt;&lt;/AA&gt;
React中:
    使用children props: 通过组件标签体传入结构
    使用render props: 通过组件标签属性传入结构, 一般用render函数属性
</code></pre>
<h2 id="children-props"><a href="#children-props" class="headerlink" title="children props"></a>children props</h2><pre><code>&lt;A&gt;
  &lt;B&gt;xxxx&lt;/B&gt;
&lt;/A&gt;
xxx会在B组件中用 this.props.children接收
问题: 如果B组件需要A组件内的数据, ==&gt; 做不到 
</code></pre>
<h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><pre><code>&lt;A render=&#123;(data) =&gt; &lt;C data=&#123;data&#125;&gt;&lt;/C&gt;&#125;&gt;&lt;/A&gt;
A组件: &#123;this.props.render(内部state数据)&#125;
C组件: 读取A组件传入的数据显示 &#123;this.props.data&#125; 
</code></pre>
<hr>

<h1 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h1><h2 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h2><p>错误边界：用来捕获后代组件错误，渲染出备用页面</p>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p>
<h2 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h2><p>getDerivedStateFromError配合componentDidCatch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生命周期函数，一旦后台组件报错，就会触发</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">getDerivedStateFromError</span>(<span class="params">error</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    <span class="comment">// 在render之前触发</span></span><br><span class="line">    <span class="comment">// 返回新的state</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">hasError</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentDidCatch</span>(<span class="params">error, info</span>)</span> &#123;  <span class="comment">//是后代组件渲染出错后调用的生命周期函数</span></span><br><span class="line">    <span class="comment">// 统计页面的错误。发送请求发送到后台去</span></span><br><span class="line">    <span class="built_in">console</span>.log(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组件通信方式总结"><a href="#组件通信方式总结" class="headerlink" title="组件通信方式总结"></a>组件通信方式总结</h1><h2 id="方式："><a href="#方式：" class="headerlink" title="方式："></a>方式：</h2><pre><code>    props：
        (1).children props
        (2).render props
    消息订阅-发布：
        pubs-sub、event等等
    集中式管理：
        redux、dva等等
    conText:
        生产者-消费者模式
</code></pre>
<h2 id="组件间的关系"><a href="#组件间的关系" class="headerlink" title="组件间的关系"></a>组件间的关系</h2><pre><code>    父子组件：props
    兄弟组件(非嵌套组件)：消息订阅-发布、集中式管理
    祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(用的少)
</code></pre>
<h1 id="消息订阅与发布机制"><a href="#消息订阅与发布机制" class="headerlink" title="消息订阅与发布机制"></a>消息订阅与发布机制</h1><p>1)import PubSub from ‘pubsub-js’ //引入<br>2)PubSub.subscribe(‘msg’, function(data){ }); //订阅<br>3)PubSub.publish(‘msg’, data) //发布消息</p>
<p>例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 某个组件中订阅消息</span></span><br><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span> token = PubSub.subscribe(<span class="string">&#x27;msg&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/*函数体*/</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卸载组件后取消订阅</span></span><br><span class="line"><span class="function"><span class="title">ComponentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		PubSub.unsubscribe(<span class="built_in">this</span>.token)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//某个组件发布消息</span></span><br><span class="line">PubSub.publish(<span class="string">&#x27;masg&#x27;</span>,data)</span><br><span class="line"><span class="comment">// 一般发过去的是state对象，然后在订阅消息消息的function里面写setstate()</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
</search>
