<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/js/config.js"></script>
<meta name="description" content="对现阶段(ES6 - ES12)的新特性进行一点简单的总结">
<meta property="og:type" content="article">
<meta property="og:title" content="自ES6往后的Js新特性">
<meta property="og:url" content="http://example.com/2021/12/16/%E8%87%AAES6%E5%BE%80%E5%90%8E%E7%9A%84Js%E6%96%B0%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="Le-zone">
<meta property="og:description" content="对现阶段(ES6 - ES12)的新特性进行一点简单的总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1725797/202104/1725797-20210418143154504-916308179.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1725797/202104/1725797-20210418143146821-1153645970.png">
<meta property="article:published_time" content="2021-12-16T06:21:40.000Z">
<meta property="article:modified_time" content="2021-12-16T11:57:49.874Z">
<meta property="article:author" content="Lruler">
<meta property="article:tag" content="Js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2020.cnblogs.com/blog/1725797/202104/1725797-20210418143154504-916308179.png">


<link rel="canonical" href="http://example.com/2021/12/16/%E8%87%AAES6%E5%BE%80%E5%90%8E%E7%9A%84Js%E6%96%B0%E7%89%B9%E6%80%A7/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;2021&#x2F;12&#x2F;16&#x2F;%E8%87%AAES6%E5%BE%80%E5%90%8E%E7%9A%84Js%E6%96%B0%E7%89%B9%E6%80%A7&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;12&#x2F;16&#x2F;自ES6往后的Js新特性&#x2F;&quot;,&quot;title&quot;:&quot;自ES6往后的Js新特性&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>自ES6往后的Js新特性 | Le-zone</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Le-zone" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Le-zone</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81JavaScript-%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="nav-number">1.0.1.</span> <span class="nav-text">一、JavaScript 的诞生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81JavaScript-%E4%B8%8E-ECMAScript-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.0.2.</span> <span class="nav-text">二、JavaScript 与 ECMAScript 的关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6"><span class="nav-number">2.</span> <span class="nav-text">ES6</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES7"><span class="nav-number">3.</span> <span class="nav-text">ES7</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES8"><span class="nav-number">4.</span> <span class="nav-text">ES8</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES9"><span class="nav-number">5.</span> <span class="nav-text">ES9</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3"><span class="nav-number">5.0.1.</span> <span class="nav-text">1.异步迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Promise-finally"><span class="nav-number">5.0.2.</span> <span class="nav-text">2.Promise.finally()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Rest-Spread-%E5%B1%9E%E6%80%A7"><span class="nav-number">5.0.3.</span> <span class="nav-text">3.Rest&#x2F;Spread 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%91%BD%E5%90%8D%E6%8D%95%E8%8E%B7%E7%BB%84"><span class="nav-number">5.0.4.</span> <span class="nav-text">4.正则表达式命名捕获组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8D%E5%90%91%E6%96%AD%E8%A8%80"><span class="nav-number">5.0.5.</span> <span class="nav-text">5.正则表达式反向断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-dotAll-%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.6.</span> <span class="nav-text">6.正则表达式 dotAll 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-Unicode-%E8%BD%AC%E4%B9%89"><span class="nav-number">5.0.7.</span> <span class="nav-text">7.正则表达式 Unicode 转义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E9%9D%9E%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.0.8.</span> <span class="nav-text">8.非转义序列的模板字符串</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES10"><span class="nav-number">6.</span> <span class="nav-text">ES10</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%A1%8C%E5%88%86%E9%9A%94%E7%AC%A6%EF%BC%88U-2028%EF%BC%89%E5%92%8C%E6%AE%B5%E5%88%86%E9%9A%94%E7%AC%A6%EF%BC%88U-2029%EF%BC%89%E7%AC%A6%E5%8F%B7%E7%8E%B0%E5%9C%A8%E5%85%81%E8%AE%B8%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E5%AD%97%E4%B8%AD%EF%BC%8C%E4%B8%8E-JSON-%E5%8C%B9%E9%85%8D"><span class="nav-number">6.0.1.</span> <span class="nav-text">1.行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与 JSON 匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9B%B4%E5%8A%A0%E5%8F%8B%E5%A5%BD%E7%9A%84-JSON-stringify"><span class="nav-number">6.0.2.</span> <span class="nav-text">2.更加友好的 JSON.stringify</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%96%B0%E5%A2%9E%E4%BA%86Array%E7%9A%84-flat-%E6%96%B9%E6%B3%95%E5%92%8C-flatMap-%E6%96%B9%E6%B3%95"><span class="nav-number">6.0.3.</span> <span class="nav-text">3.新增了Array的 flat()方法和 flatMap()方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-prototype-flat"><span class="nav-number">6.0.3.1.</span> <span class="nav-text">Array.prototype.flat()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-prototype-flatMap"><span class="nav-number">6.0.3.2.</span> <span class="nav-text">Array.prototype.flatMap()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%96%B0%E5%A2%9E%E4%BA%86String%E7%9A%84-trimStart-%E6%96%B9%E6%B3%95%E5%92%8C-trimEnd-%E6%96%B9%E6%B3%95"><span class="nav-number">6.0.4.</span> <span class="nav-text">4.新增了String的 trimStart()方法和 trimEnd()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Object-fromEntries"><span class="nav-number">6.0.5.</span> <span class="nav-text">5. Object.fromEntries()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Symbol-prototype-description"><span class="nav-number">6.0.6.</span> <span class="nav-text">6. Symbol.prototype.description</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-String-prototype-matchAll"><span class="nav-number">6.0.7.</span> <span class="nav-text">7. String.prototype.matchAll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#matchAll-%E5%8F%AF%E4%BB%A5%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%94%A8%E4%BA%8E%E5%88%86%E7%BB%84"><span class="nav-number">6.0.7.1.</span> <span class="nav-text">matchAll 可以更好的用于分组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Function-prototype-toString-%E7%8E%B0%E5%9C%A8%E8%BF%94%E5%9B%9E%E7%B2%BE%E7%A1%AE%E5%AD%97%E7%AC%A6%EF%BC%8C%E5%8C%85%E6%8B%AC%E7%A9%BA%E6%A0%BC%E5%92%8C%E6%B3%A8%E9%87%8A"><span class="nav-number">6.0.8.</span> <span class="nav-text">8. Function.prototype.toString()现在返回精确字符，包括空格和注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E4%BF%AE%E6%94%B9-catch-%E7%BB%91%E5%AE%9A"><span class="nav-number">6.0.9.</span> <span class="nav-text">9.修改 catch 绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E6%96%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-BigInt"><span class="nav-number">6.0.10.</span> <span class="nav-text">10.新的基本数据类型 BigInt</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES11"><span class="nav-number">7.</span> <span class="nav-text">ES11</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Promise-allSettled"><span class="nav-number">7.0.1.</span> <span class="nav-text">1.Promise.allSettled</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-all-%E7%BC%BA%E9%99%B7"><span class="nav-number">7.0.1.1.</span> <span class="nav-text">Promise.all 缺陷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-allSettled-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">7.0.1.2.</span> <span class="nav-text">Promise.allSettled 的优势</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8F%AF%E9%80%89%E9%93%BE"><span class="nav-number">7.0.2.</span> <span class="nav-text">2.可选链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">7.0.3.</span> <span class="nav-text">3.空值合并运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-dynamic-import"><span class="nav-number">7.0.4.</span> <span class="nav-text">4.dynamic-import</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-globalThis"><span class="nav-number">7.0.5.</span> <span class="nav-text">5.globalThis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-BigInt"><span class="nav-number">7.0.6.</span> <span class="nav-text">6.BigInt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-String-prototype-matchAll-1"><span class="nav-number">7.0.7.</span> <span class="nav-text">7.String.prototype.matchAll</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES12"><span class="nav-number">8.</span> <span class="nav-text">ES12</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-replaceAll"><span class="nav-number">8.0.1.</span> <span class="nav-text">1. replaceAll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Promise-any"><span class="nav-number">8.0.2.</span> <span class="nav-text">2. Promise.any</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-WeakRefs"><span class="nav-number">8.0.3.</span> <span class="nav-text">3. WeakRefs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">8.0.4.</span> <span class="nav-text">4. 逻辑运算符和赋值表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%95%B0%E5%AD%97%E5%88%86%E9%9A%94%E7%AC%A6"><span class="nav-number">8.0.5.</span> <span class="nav-text">5. 数字分隔符</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lruler"
      src="https://avatars.githubusercontent.com/u/75160088?v=4">
  <p class="site-author-name" itemprop="name">Lruler</p>
  <div class="site-description" itemprop="description">Passionate love is a thirst</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Lruler" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Lruler" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1204312199@qq.com" title="E-Mail → mailto:1204312199@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/16/%E8%87%AAES6%E5%BE%80%E5%90%8E%E7%9A%84Js%E6%96%B0%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/75160088?v=4">
      <meta itemprop="name" content="Lruler">
      <meta itemprop="description" content="Passionate love is a thirst">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Le-zone">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          自ES6往后的Js新特性
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-16 14:21:40 / 修改时间：19:57:49" itemprop="dateCreated datePublished" datetime="2021-12-16T14:21:40+08:00">2021-12-16</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>对现阶段(ES6 - ES12)的新特性进行一点简单的总结</p>
<span id="more"></span>

<p><strong>摘自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/suwanbin/p/14673414.html#es122021">这篇博客</a>（原本不想放的，仔细想想还是放了好，有助于了解Js的历史和ESM到底是什么，说的很清楚）</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JavaScript 是当今使用最广泛的、发展最好的前后端（后端主要是 Nodejs）语言，如果我们想要灵活使用 JavaScript，我们首先需要了解的就是 JavaScript 和 ECMAScript(ES) 的基础知识及发展历程。</p>
<h3 id="一、JavaScript-的诞生"><a href="#一、JavaScript-的诞生" class="headerlink" title="一、JavaScript 的诞生"></a>一、JavaScript 的诞生</h3><p>JavaScript 因为互联网而生，紧跟着浏览器的出现而问世。回顾它的历史，就要从浏览器的历史讲起。</p>
<p>1990年底，欧洲核能研究组织（CERN）科学家 Tim Berners-Lee，在全世界最大的电脑网络——互联网的基础上，发明了万维网（World Wide Web），从此可以在网上浏览网页文件。最早的网页只能在操作系统的终端里浏览，也就是说只能使用命令行操作，网页都是在字符窗口中显示，这当然非常不方便。</p>
<p>1992年底，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做 Mosaic。这是人类历史上第一个浏览器，从此网页可以在图形界面的窗口浏览。</p>
<p>1994年10月，NCSA 的一个主要程序员 Marc Andreessen 联合风险投资家 Jim Clark，成立了 Mosaic 通信公司（Mosaic Communications），不久后改名为 Netscape。这家公司的方向，就是在 Mosaic 的基础上，开发面向普通用户的新一代的浏览器 Netscape Navigator。</p>
<p>1994年12月，Navigator 发布了1.0版，市场份额一举超过90%。</p>
<p>Netscape 公司很快发现，Navigator 浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。当时，网速很慢而且上网费很贵，有些操作不宜在服务器端完成。比如，如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。</p>
<p>管理层对这种浏览器脚本语言的设想是：功能不需要太强，语法较为简单，容易学习和部署。那一年，正逢 Sun 公司的 Java 语言问世，市场推广活动非常成功。Netscape 公司决定与 Sun 公司合作，浏览器支持嵌入 Java 小程序（后来称为 Java applet）。但是，浏览器脚本语言是否就选用 Java，则存在争论。后来，还是决定不使用 Java，因为网页小程序不需要 Java 这么“重”的语法。但是，同时也决定脚本语言的语法要接近 Java，并且可以支持 Java 程序。这些设想直接排除了使用现存语言，比如 Perl、Python 和 TCL。</p>
<p>1995年，Netscape 公司雇佣了程序员 Brendan Eich 开发这种网页脚本语言。Brendan Eich 有很强的函数式编程背景，希望以 Scheme 语言（函数式语言鼻祖 LISP 语言的一种方言）为蓝本，实现这种新语言。</p>
<p>1995年5月，Brendan Eich 只用了10天，就设计完成了这种语言的第一版。它是一个大杂烩，语法有多个来源。</p>
<ul>
<li>基本语法：借鉴 C 语言和 Java 语言。</li>
<li>数据结构：借鉴 Java 语言，包括将值分成原始值和对象两大类。</li>
<li>函数的用法：借鉴 Scheme 语言和 Awk 语言，将函数当作第一等公民，并引入闭包。</li>
<li>原型继承模型：借鉴 Self 语言（Smalltalk 的一种变种）。</li>
<li>正则表达式：借鉴 Perl 语言。</li>
<li>字符串和数组处理：借鉴 Python 语言。</li>
</ul>
<p>为了保持简单，这种脚本语言缺少一些关键的功能，比如块级作用域、模块、子类型（subtyping）等等，但是可以利用现有功能找出解决办法。这种功能的不足，直接导致了后来 JavaScript 的一个显著特点：对于其他语言，你需要学习语言的各种功能，而对于 JavaScript，你常常需要学习各种解决问题的模式。而且由于来源多样，从一开始就注定，JavaScript 的编程风格是函数式编程和面向对象编程的一种混合体。</p>
<p>Netscape 公司的这种浏览器脚本语言，最初名字叫做 Mocha，1995年9月改为 LiveScript。12月，Netscape 公司与 Sun 公司（Java 语言的发明者和所有者）达成协议，后者允许将这种语言叫做 JavaScript。这样一来，Netscape 公司可以借助 Java 语言的声势，而 Sun 公司则将自己的影响力扩展到了浏览器。</p>
<p>之所以起这个名字，并不是因为 JavaScript 本身与 Java 语言有多么深的关系（事实上，两者关系并不深，详见下节），而是因为 Netscape 公司已经决定，使用 Java 语言开发网络应用程序，JavaScript 可以像胶水一样，将各个部分连接起来。当然，后来的历史是 Java 语言的浏览器插件失败了，JavaScript 反而发扬光大。</p>
<p>1995年12月4日，Netscape 公司与 Sun 公司联合发布了 JavaScript 语言，对外宣传 JavaScript 是 Java 的补充，属于轻量级的 Java，专门用来操作网页。</p>
<p>1996年3月，Navigator 2.0 浏览器正式内置了 JavaScript 脚本语言。</p>
<h3 id="二、JavaScript-与-ECMAScript-的关系"><a href="#二、JavaScript-与-ECMAScript-的关系" class="headerlink" title="二、JavaScript 与 ECMAScript 的关系"></a>二、JavaScript 与 ECMAScript 的关系</h3><p>要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给国际标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript ，这个版本就是1.0版。</p>
<p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript ，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA ，不是 Netscape ，这样有利于保证这门语言的开放性和中立性。</p>
<p><strong>因此，ECMAScript 和 JavaScript 的关系是，ECMAScript 是一个简单的 JavaScript 标准规范，JavaScript 是 ECMAScript 的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript ）。并且，ECMAScript 持续不断的为 JavaScript 添加新功能。</strong></p>
<p>从 1997年7月 ECMAScript 1.0 发布到现在，ECMAScript 已经正式发布了 11 版，下面我们主要介绍从ES6（ES2015）到ES11（最新 ES2020 ）期间，每版发布的新功能。</p>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>这个是比较重要的一个版本，现在很多常用的语法都是基于这一版，下面是其中一部分</p>
<ul>
<li>类</li>
<li>模块化</li>
<li>箭头函数</li>
<li>函数参数默认值</li>
<li>模板字符串</li>
<li>解构赋值</li>
<li>延展操作符</li>
<li>对象属性简写</li>
<li>Promise</li>
<li>Let 与 Const</li>
</ul>
<p>然后具体讲解的话我们去看看阮一峰的书 <a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/">ES6</a></p>
<h1 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h1><p>这个内容比较少，估计搞完ES6大家都累了…</p>
<ol>
<li>Array.prototype.includes()</li>
</ol>
<p>这个方法大家用的比较多吧，不用includes其实还可以用index，-1就是不存在嘛</p>
<ol start="2">
<li>** 运算符</li>
</ol>
<p>这个就是乘方，Math.pow()的语法糖，比如2 ** 3 === Math.pow(2, 3) === 8</p>
<h1 id="ES8"><a href="#ES8" class="headerlink" title="ES8"></a>ES8</h1><ul>
<li>async/await</li>
<li><code>Object.values()</code></li>
<li><code>Object.entries()</code></li>
<li>String padding: <code>padStart()</code>和 <code>padEnd()</code>，填充字符串达到当前长度</li>
<li>函数参数列表结尾允许逗号</li>
<li><code>Object.getOwnPropertyDescriptors()</code></li>
<li><code>ShareArrayBuffer</code>和 <code>Atomics</code>对象，用于从共享内存位置读取和写入</li>
</ul>
<p>Es8补充的内容还挺多的</p>
<ol>
<li>async/await</li>
</ol>
<p>这个就不用多说了，Js中异步的终极解决方案</p>
<p><strong>async 是一个通过异步执行并隐式返回 Promise 作为结果的函数</strong></p>
<p>然后用await处理Promise.resolve()后的情况，详细不多说，只做简介</p>
<ol start="2">
<li>Object.values()</li>
</ol>
<p>很明显，遍历一个对象的值，然后以返回一个值的数组</p>
<ol start="3">
<li>Object.entries()</li>
</ol>
<p>这个有意思，是遍历一个对象的key/value对，然后同样以数组(一个二维数组)方式返回，简单的看看使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES8之前</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;key:&#x27;</span> + key + <span class="string">&#x27; value:&#x27;</span> + obj[key])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES8之后</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj1)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;key&#125;</span> value:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>String padding: <code>padStart()</code>和 <code>padEnd()</code></p>
<p>允许将空字符串或其他字符串添加到原始字符串的开头或结尾。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0.0&#x27;</span>.padStart(<span class="number">4</span>, <span class="string">&#x27;10&#x27;</span>))</span><br><span class="line"><span class="comment">// 10.0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0.0&#x27;</span>.padStart(<span class="number">20</span>))</span><br><span class="line"><span class="comment">//                  0.0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0.0&#x27;</span>.padStart(<span class="number">20</span>, <span class="string">&#x27;10&#x27;</span>))</span><br><span class="line"><span class="comment">// 101010101010101010.0</span></span><br><span class="line"><span class="comment">// padEnd同理咯</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Object.getOwnPropertyDescriptors()</li>
</ol>
<p>返回 <code>obj</code>对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jine&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;18&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj2))</span><br><span class="line"><span class="comment">// 大概这样</span></span><br><span class="line">&#123;<span class="attr">name</span>: &#123;…&#125;, <span class="attr">age</span>: &#123;…&#125;&#125;</span><br><span class="line"><span class="attr">age</span>:</span><br><span class="line">configurable: <span class="literal">true</span></span><br><span class="line"><span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line"><span class="attr">get</span>: ƒ age()</span><br><span class="line"><span class="attr">set</span>: <span class="literal">undefined</span></span><br><span class="line">[[Prototype]]: <span class="built_in">Object</span></span><br><span class="line"><span class="attr">name</span>:</span><br><span class="line">configurable: <span class="literal">true</span></span><br><span class="line"><span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line"><span class="attr">value</span>: <span class="string">&quot;Jine&quot;</span></span><br><span class="line"><span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>SharedArrayBuffer对象和Atomics对象</li>
</ol>
<p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p>
<p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作</p>
<p>没用过，不知道，不清楚</p>
<h1 id="ES9"><a href="#ES9" class="headerlink" title="ES9"></a>ES9</h1><h3 id="1-异步迭代"><a href="#1-异步迭代" class="headerlink" title="1.异步迭代"></a>1.异步迭代</h3><p>在 <code>async/await</code>的某些时刻，你可能尝试在同步循环中调用异步函数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">await</span> doSomething(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码不会正常运行，下面这段同样也不会：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.forEach(<span class="keyword">async</span> (i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> doSomething(i)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，循环本身依旧保持同步，并在在内部异步函数之前全部调用完成。</p>
<p>ES2018 引入异步迭代器（asynchronous iterators），这就像常规迭代器，除了 <code>next()</code>方法返回一个 Promise。因此 <code>await</code>可以和 <code>for...of</code>循环一起使用，以串行的方式运行异步操作。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    doSomething(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Promise-finally"><a href="#2-Promise-finally" class="headerlink" title="2.Promise.finally()"></a>2.Promise.finally()</h3><p>一个 Promise 调用链要么成功到达最后一个 <code>.then()</code>，要么失败触发 <code>.catch()</code>。在某些情况下，你想要在无论 Promise 运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。</p>
<p><code>.finally()</code>允许你指定最终的逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  doSomething1()</span><br><span class="line">    .then(doSomething2)</span><br><span class="line">    .then(doSomething3)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">    .finally(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Rest-Spread-属性"><a href="#3-Rest-Spread-属性" class="headerlink" title="3.Rest/Spread 属性"></a>3.Rest/Spread 属性</h3><p>就是对…运算符的扩展，ES6的时候还只能作用于数组，到了ES9才可以作用于对象</p>
<h3 id="4-正则表达式命名捕获组"><a href="#4-正则表达式命名捕获组" class="headerlink" title="4.正则表达式命名捕获组"></a>4.正则表达式命名捕获组</h3><p>JavaScript 正则表达式可以返回一个匹配的对象——一个包含匹配字符串的类数组，例如：以 <code>YYYY-MM-DD</code>的格式解析日期：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reDate = <span class="regexp">/([0-9]&#123;4&#125;)-([0-9]&#123;2&#125;)-([0-9]&#123;2&#125;)/</span>,</span><br><span class="line">  match = reDate.exec(<span class="string">&#x27;2018-04-30&#x27;</span>),</span><br><span class="line">  year = match[<span class="number">1</span>],</span><br><span class="line">  month = match[<span class="number">2</span>],</span><br><span class="line">  day = match[<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>这样的代码很难读懂，并且改变正则表达式的结构有可能改变匹配对象的索引。</p>
<p>ES2018 允许命名捕获组使用符号 <code>?&lt;name&gt;</code>，在打开捕获括号 <code>(</code>后立即命名，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reDate = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>,</span><br><span class="line">  match = reDate.exec(<span class="string">&#x27;2018-04-30&#x27;</span>),</span><br><span class="line">  year = match.groups.year,</span><br><span class="line">  month = match.groups.month, <span class="comment">// 04</span></span><br><span class="line">  day = match.groups.day</span><br></pre></td></tr></table></figure>

<p>任何匹配失败的命名组都将返回 <code>undefined</code>。</p>
<p>命名捕获也可以使用在 <code>replace()</code>方法中。例如将日期转换为美国的 MM-DD-YYYY 格式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reDate = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>,</span><br><span class="line">  d = <span class="string">&#x27;2018-04-30&#x27;</span>,</span><br><span class="line">  usDate = d.replace(reDate, <span class="string">&#x27;$&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-正则表达式反向断言"><a href="#5-正则表达式反向断言" class="headerlink" title="5.正则表达式反向断言"></a>5.正则表达式反向断言</h3><p>目前 JavaScript 在正则表达式中支持先行断言（lookahead）。这意味着匹配会发生，但不会有任何捕获，并且断言没有包含在整个匹配字段中。例如从价格中捕获货币符号：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reLookahead = <span class="regexp">/\D(?=\d+)/</span>,</span><br><span class="line">  match = reLookahead.exec(<span class="string">&#x27;$123.89&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>ES2018 引入以相同方式工作但是匹配前面的反向断言（lookbehind），这样我就可以忽略货币符号，单纯的捕获价格的数字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reLookbehind = <span class="regexp">/(?&lt;=\D)\d+/</span>,</span><br><span class="line">  match = reLookbehind.exec(<span class="string">&#x27;$123.89&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>以上是 <strong>肯定反向断言</strong>，非数字 <code>\D</code>必须存在。同样的，还存在 <strong>否定反向断言</strong>，表示一个值必须不存在，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reLookbehindNeg = <span class="regexp">/(?&lt;!\D)\d+/</span>,</span><br><span class="line">  match = reLookbehind.exec(<span class="string">&#x27;$123.89&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h3 id="6-正则表达式-dotAll-模式"><a href="#6-正则表达式-dotAll-模式" class="headerlink" title="6.正则表达式 dotAll 模式"></a>6.正则表达式 dotAll 模式</h3><p>正则表达式中点 <code>.</code>匹配除回车外的任何单字符，标记 <code>s</code>改变这种行为，允许行终止符的出现，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/hello.world/.test(<span class="string">&#x27;hello\nworld&#x27;</span>);</span><br><span class="line"><span class="regexp">/hello.world/</span>s.test(<span class="string">&#x27;hello\nworld&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="7-正则表达式-Unicode-转义"><a href="#7-正则表达式-Unicode-转义" class="headerlink" title="7.正则表达式 Unicode 转义"></a>7.正则表达式 Unicode 转义</h3><p>到目前为止，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES2018添加了 Unicode 属性转义——形式为 <code>\p&#123;...&#125;</code>和 <code>\P&#123;...&#125;</code>，在正则表达式中使用标记 <code>u</code> (unicode) 设置，在 <code>\p</code>块儿内，可以以键值对的方式设置需要匹配的属性而非具体内容。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span></span><br><span class="line">reGreekSymbol.test(<span class="string">&#x27;π&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>此特性可以避免使用特定 Unicode 区间来进行内容类型判断，提升可读性和可维护性。</p>
<h3 id="8-非转义序列的模板字符串"><a href="#8-非转义序列的模板字符串" class="headerlink" title="8.非转义序列的模板字符串"></a>8.非转义序列的模板字符串</h3><p>之前， <code>\u</code>开始一个 unicode 转义， <code>\x</code>开始一个十六进制转义， <code>\</code>后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，例如 Windows 文件路径 <code>C:\uuu\xxx\111</code>。更多细节参考模板字符串。</p>
<h1 id="ES10"><a href="#ES10" class="headerlink" title="ES10"></a>ES10</h1><ul>
<li>行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与 JSON 匹配</li>
<li>更加友好的 JSON.stringify</li>
<li>新增了Array 的 <code>flat()</code>方法和 <code>flatMap()</code>方法</li>
<li>新增了String 的 <code>trimStart()</code>方法和 <code>trimEnd()</code>方法</li>
<li><code>Object.fromEntries()</code></li>
<li><code>Symbol.prototype.description</code></li>
<li><code>String.prototype.matchAll</code></li>
<li><code>Function.prototype.toString()</code>现在返回精确字符，包括空格和注释</li>
<li>简化 <code>try &#123;&#125; catch &#123;&#125;</code>,修改 <code>catch</code> 绑定</li>
<li>新的基本数据类型 <code>BigInt</code></li>
<li>globalThis</li>
<li>import()</li>
<li>Legacy RegEx</li>
<li>私有的实例方法和访问器</li>
</ul>
<h3 id="1-行分隔符（U-2028）和段分隔符（U-2029）符号现在允许在字符串文字中，与-JSON-匹配"><a href="#1-行分隔符（U-2028）和段分隔符（U-2029）符号现在允许在字符串文字中，与-JSON-匹配" class="headerlink" title="1.行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与 JSON 匹配"></a>1.行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与 JSON 匹配</h3><p>以前，这些符号在字符串文字中被视为行终止符，因此使用它们会导致 SyntaxError 异常。</p>
<h3 id="2-更加友好的-JSON-stringify"><a href="#2-更加友好的-JSON-stringify" class="headerlink" title="2.更加友好的 JSON.stringify"></a>2.更加友好的 JSON.stringify</h3><p>如果输入 Unicode 格式但是超出范围的字符，在原先 JSON.stringify 返回格式错误的 Unicode 字符串。现在实现了一个改变 JSON.stringify 的第3阶段提案，因此它为其输出转义序列，使其成为有效 Unicode（并以UTF-8表示）</p>
<h3 id="3-新增了Array的-flat-方法和-flatMap-方法"><a href="#3-新增了Array的-flat-方法和-flatMap-方法" class="headerlink" title="3.新增了Array的 flat()方法和 flatMap()方法"></a>3.新增了Array的 <code>flat()</code>方法和 <code>flatMap()</code>方法</h3><p><code>flat()</code>和 <code>flatMap()</code>本质上就是是归纳（reduce） 与 合并（concat）的操作。</p>
<h4 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat()"></a>Array.prototype.flat()</h4><p><code>flat()</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">arr1.flat()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]]</span><br><span class="line">arr2.flat()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]]</span><br><span class="line">arr3.flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//使用 Infinity 作为深度，展开任意深度的嵌套数组</span></span><br><span class="line">arr3.flat(<span class="literal">Infinity</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>其次，还可以利用 <code>flat()</code>方法的特性来去除数组的空项</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr4.flat()</span><br></pre></td></tr></table></figure>

<h4 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap()"></a>Array.prototype.flatMap()</h4><p><code>flatMap()</code> 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。 这里我们拿 map 方法与 flatMap 方法做一个比较。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr1.map(<span class="function">(<span class="params">x</span>) =&gt;</span> [x * <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// 只会将 flatMap 中的函数返回的数组 “压平” 一层</span></span><br><span class="line">arr1.flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [[x * <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="4-新增了String的-trimStart-方法和-trimEnd-方法"><a href="#4-新增了String的-trimStart-方法和-trimEnd-方法" class="headerlink" title="4.新增了String的 trimStart()方法和 trimEnd()方法"></a>4.新增了String的 <code>trimStart()</code>方法和 <code>trimEnd()</code>方法</h3><p>新增的这两个方法很好理解，分别去除字符串首尾空白字符，这里就不用例子说声明了。</p>
<h3 id="5-Object-fromEntries"><a href="#5-Object-fromEntries" class="headerlink" title="5. Object.fromEntries()"></a>5. <code>Object.fromEntries()</code></h3><p><code>Object.entries()</code>方法的作用是返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p>
<p><strong>而 <code>Object.fromEntries()</code> 则是 <code>Object.entries()</code> 的反转。</strong></p>
<p><code>Object.fromEntries()</code> 函数传入一个键值对的列表，并返回一个带有这些键值对的新对象。这个迭代参数应该是一个能够实现 @iterator 方法的的对象，返回一个迭代器对象。它生成一个具有两个元素的类似数组的对象，第一个元素是将用作属性键的值，第二个元素是与该属性键关联的值。</p>
<ul>
<li>通过 Object.fromEntries， 可以将 Map 转化为 Object:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>],</span><br><span class="line">])</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(map)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 Object.fromEntries， 可以将 Array 转化为 Object:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(arr)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure>

<h3 id="6-Symbol-prototype-description"><a href="#6-Symbol-prototype-description" class="headerlink" title="6. Symbol.prototype.description"></a>6. <code>Symbol.prototype.description</code></h3><p>通过工厂函数 Symbol（）创建符号时，您可以选择通过参数提供字符串作为描述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;The description&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>以前，访问描述的唯一方法是将符号转换为字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert.equal(sym.description, <span class="string">&#x27;The description&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>现在引入了getter Symbol.prototype.description以直接访问描述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert.equal(sym.description, <span class="string">&#x27;The description&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-String-prototype-matchAll"><a href="#7-String-prototype-matchAll" class="headerlink" title="7. String.prototype.matchAll"></a>7. <code>String.prototype.matchAll</code></h3><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器。 在 matchAll 出现之前，通过在循环中调用 regexp.exec 来获取所有匹配项信息（regexp 需使用 /g 标志：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="built_in">RegExp</span>(<span class="string">&#x27;foo*&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;table football, foosball&#x27;</span></span><br><span class="line"><span class="keyword">while</span> ((matches = regexp.exec(str)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Found <span class="subst">$&#123;matches[<span class="number">0</span>]&#125;</span>. Next starts at <span class="subst">$&#123;regexp.lastIndex&#125;</span>.`</span>)</span><br><span class="line">  <span class="comment">// expected output: &quot;Found foo. Next starts at 19.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用 matchAll ，就可以不必使用 while 循环加 exec 方式（且正则表达式需使用／g标志）。使用 matchAll 会得到一个迭代器的返回值，配合 for…of, array spread, or Array.from() 可以更方便实现功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="built_in">RegExp</span>(<span class="string">&#x27;foo*&#x27;</span>, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;table football, foosball&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> matches = str.matchAll(regexp)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> matches) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Array [ &quot;foo&quot; ]</span></span><br><span class="line"><span class="comment">// Call matchAll again to create a new iterator</span></span><br><span class="line">matches = str.matchAll(regexp)</span><br><span class="line"><span class="built_in">Array</span>.from(matches, <span class="function">(<span class="params">m</span>) =&gt;</span> m[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h4 id="matchAll-可以更好的用于分组"><a href="#matchAll-可以更好的用于分组" class="headerlink" title="matchAll 可以更好的用于分组"></a>matchAll 可以更好的用于分组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/t(e)(st(\d?))/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;test1test2&#x27;</span></span><br><span class="line">str.match(regexp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [...str.matchAll(regexp)]</span><br><span class="line">array[<span class="number">0</span>]</span><br><span class="line">array[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="8-Function-prototype-toString-现在返回精确字符，包括空格和注释"><a href="#8-Function-prototype-toString-现在返回精确字符，包括空格和注释" class="headerlink" title="8. Function.prototype.toString()现在返回精确字符，包括空格和注释"></a>8. <code>Function.prototype.toString()</code>现在返回精确字符，包括空格和注释</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">comment</span> */ <span class="title">foo</span> /* <span class="title">another</span> <span class="title">comment</span> */(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.toString())</span><br><span class="line"><span class="comment">// ES2019 会把注释一同打印</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString())</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="comment">/* another comment */</span> <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar.toString())</span><br></pre></td></tr></table></figure>

<h3 id="9-修改-catch-绑定"><a href="#9-修改-catch-绑定" class="headerlink" title="9.修改 catch 绑定"></a>9.修改 <code>catch</code> 绑定</h3><p>在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的。ES10 提案使我们能够简单的把变量省略掉。</p>
<p>不算大的改动。</p>
<p>之前是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-新的基本数据类型-BigInt"><a href="#10-新的基本数据类型-BigInt" class="headerlink" title="10.新的基本数据类型 BigInt"></a>10.新的基本数据类型 <code>BigInt</code></h3><p>现在的基本数据类型（值类型）不止5种（ES6 之后是六种）了哦！加上BigInt一共有七种基本数据类型，分别是：String、Number、Boolean、Null、Undefined、Symbol、BigInt</p>
<h1 id="ES11"><a href="#ES11" class="headerlink" title="ES11"></a>ES11</h1><h3 id="1-Promise-allSettled"><a href="#1-Promise-allSettled" class="headerlink" title="1.Promise.allSettled"></a>1.Promise.allSettled</h3><h4 id="Promise-all-缺陷"><a href="#Promise-all-缺陷" class="headerlink" title="Promise.all 缺陷"></a>Promise.all 缺陷</h4><p>都知道 <code>Promise.all</code> 具有并发执行异步任务的能力。但它的最大问题就是如果其中某个任务出现异常(<code>reject</code>)，所有任务都会挂掉，<code>Promise</code> 直接进入 <code>reject</code> 状态。</p>
<p>想象这个场景：你的页面有三个区域，分别对应三个独立的接口数据，使用 <code>Promise.all</code> 来并发三个接口，如果其中任意一个接口服务异常，状态是 reject，这会导致页面中该三个区域数据全都无法渲染出来，因为任何 <code>reject</code> 都会进入 catch 回调, 很明显，这是无法接受的，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(&#123; <span class="attr">code</span>: <span class="number">500</span>, <span class="attr">msg</span>: <span class="string">&#x27;服务异常&#x27;</span> &#125;),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">list</span>: [] &#125;),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">list</span>: [] &#125;),</span><br><span class="line">])</span><br><span class="line">  .then(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果其中一个任务是 reject，则不会执行到这个回调。</span></span><br><span class="line">    RenderContent(ret)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 本例中会执行到这个回调</span></span><br><span class="line">    <span class="comment">// error: &#123;code: 500, msg: &quot;服务异常&quot;&#125;</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Promise-allSettled-的优势"><a href="#Promise-allSettled-的优势" class="headerlink" title="Promise.allSettled 的优势"></a>Promise.allSettled 的优势</h4><p>我们需要一种机制，如果并发任务中，无论一个任务正常或者异常，都会返回对应的的状态（<code>fulfilled</code> 或者 <code>rejected</code>）与结果（业务 <code>value</code> 或者 拒因 <code>reason</code>），在 <code>then</code> 里面通过 <code>filter</code> 来过滤出想要的业务逻辑结果，这就能最大限度的保障业务当前状态的可访问性，而 <code>Promise.allSettled</code> 就是解决这问题的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(&#123; <span class="attr">code</span>: <span class="number">500</span>, <span class="attr">msg</span>: <span class="string">&#x27;服务异常&#x27;</span> &#125;),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">list</span>: [] &#125;),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">list</span>: [] &#125;),</span><br><span class="line">]).then(<span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      0: &#123;status: &quot;rejected&quot;, reason: &#123;...&#125;&#125;</span></span><br><span class="line"><span class="comment">      1: &#123;status: &quot;fulfilled&quot;, value: &#123;...&#125;&#125;</span></span><br><span class="line"><span class="comment">      2: &#123;status: &quot;fulfilled&quot;, value: &#123;...&#125;&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 过滤掉 rejected 状态，尽可能多的保证页面区域数据渲染</span></span><br><span class="line">  RenderContent(</span><br><span class="line">    ret.filter(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> el.status !== <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-可选链"><a href="#2-可选链" class="headerlink" title="2.可选链"></a>2.可选链</h3><p><code>可选链</code> 可让我们在查询具有多层级的对象时，不再需要进行冗余的各种前置校验。</p>
<p>日常开发中，我们经常会遇到这种查询</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = user &amp;&amp; user.info &amp;&amp; user.info.name</span><br></pre></td></tr></table></figure>

<p>又或是这种</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = user &amp;&amp; user.info &amp;&amp; user.info.getAge &amp;&amp; user.info.getAge()</span><br></pre></td></tr></table></figure>

<p>这是一种丑陋但又不得不做的前置校验，否则很容易命中 <code>Uncaught TypeError: Cannot read property...</code> 这种错误，这极有可能让你整个应用挂掉。</p>
<p>用了 Optional Chaining ，上面代码会变成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = user?.info?.name</span><br><span class="line"><span class="keyword">var</span> age = user?.info?.getAge?.()</span><br></pre></td></tr></table></figure>

<p>可选链中的 <code>?</code> 表示如果问号左边表达式有值, 就会继续查询问号后面的字段。根据上面可以看出，用可选链可以大量简化类似繁琐的前置校验操作，而且更安全。</p>
<h3 id="3-空值合并运算符"><a href="#3-空值合并运算符" class="headerlink" title="3.空值合并运算符"></a>3.空值合并运算符</h3><p>当我们查询某个属性时，经常会遇到，如果没有该属性就会设置一个默认的值。比如下面代码中查询玩家等级。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> level = (user.data &amp;&amp; user.data.level) || <span class="string">&#x27;暂无等级&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 JS 中，空字符串、0 等，当进行逻辑操作符判断时，会自动转化为 false。在上面的代码里，如果玩家等级本身就是 0 级, 变量 level 就会被赋值 <code>暂无等级</code> 字符串，这是逻辑错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> level;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> user.level === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    level = user.level;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!user.level) &#123;</span><br><span class="line">    level = <span class="string">&#x27;暂无等级&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    level = user.level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看看用空值合并运算符如何处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;level&quot;: 0</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">var</span> level = <span class="string">`<span class="subst">$&#123;user.level&#125;</span>级`</span> ?? <span class="string">&#x27;暂无等级&#x27;</span></span><br><span class="line"><span class="comment">// level -&gt; &#x27;0级&#x27;</span></span><br></pre></td></tr></table></figure>

<p>用空值合并运算在逻辑正确的前提下，代码更加简洁。</p>
<p><strong>空值合并运算符</strong> 与 <strong>可选链</strong> 相结合，可以很轻松处理多级查询并赋予默认值问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> level = user.data?.level ?? <span class="string">&#x27;暂无等级&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-dynamic-import"><a href="#4-dynamic-import" class="headerlink" title="4.dynamic-import"></a>4.dynamic-import</h3><p>按需 <code>import</code> 提案几年前就已提出，如今终于能进入 ES 正式规范。这里个人理解成 “<strong>按需</strong>“ 更为贴切。现代前端打包资源越来越大，打包成几 M 的 JS 资源已成常态，而往往前端应用初始化时根本不需要全量加载逻辑资源，为了首屏渲染速度更快，很多时候都是按需加载，比如懒加载图片等。而这些按需执行逻辑资源都体现在某一个事件回调中去加载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">el.onclick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">`/path/current-logic.js`</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">module</span>.doSomthing()</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// load error;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，webpack 目前已很好的支持了该特性。</p>
<h3 id="5-globalThis"><a href="#5-globalThis" class="headerlink" title="5.globalThis"></a>5.globalThis</h3><p>JavaScript 在不同的环境获取全局对象有不同的方式，NodeJS 中通过 <code>global</code>, Web 中通过 <code>window</code>, <code>self</code> 等，有些甚至通过 <code>this</code> 获取，但通过 <code>this</code> 是及其危险的，<code>this</code> 在 JavaScript 中异常复杂，它严重依赖当前的执行上下文，这些无疑增加了获取全局对象的复杂性。</p>
<p>过去获取全局对象，可通过一个全局函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (typeofwindow !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    returnwindow</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">global</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">global</span></span><br><span class="line">  &#125;</span><br><span class="line">  thrownewError(<span class="string">&#x27;unable to locate global object&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> globals = getGlobal()</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis</span></span><br></pre></td></tr></table></figure>

<p>而 <code>globalThis</code> 目的就是提供一种标准化方式访问全局对象，有了 <code>globalThis</code>后，你可以在任意上下文，任意时刻都能获取到全局对象。</p>
<h3 id="6-BigInt"><a href="#6-BigInt" class="headerlink" title="6.BigInt"></a>6.BigInt</h3><p>JavaScript 中 <code>Number</code> 类型只能安全的表示<code>-(2^53-1)</code>至 <code>2^53-1</code> 范的值，即 <code>Number.MIN_SAFE_INTEGER</code> 至 <code>Number.MAX_SAFE_INTEGER</code>，超出这个范围的整数计算或者表示会丢失精度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>.MAX_SAFE_INTEGER <span class="comment">// -&gt; 9007199254740991</span></span><br><span class="line"></span><br><span class="line">num = num + <span class="number">1</span> <span class="comment">// -&gt; 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次加 +1 后无法正常运算</span></span><br><span class="line">num = num + <span class="number">1</span> <span class="comment">// -&gt; 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个不同的值，却返回了true</span></span><br><span class="line"><span class="number">9007199254740992</span> === <span class="number">9007199254740993</span> <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p>为解决此问题，ES2020 提供一种新的数据类型：<code>BigInt</code>。使用 <code>BigInt</code> 有两种方式：</p>
<ol>
<li>在整数字面量后面加<code>n</code>。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bigIntNum = <span class="number">9007199254740993n</span></span><br></pre></td></tr></table></figure>

<ol>
<li>使用 <code>BigInt</code> 函数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bigIntNum = <span class="built_in">BigInt</span>(<span class="number">9007199254740</span>)</span><br><span class="line"><span class="keyword">var</span> anOtherBigIntNum = <span class="built_in">BigInt</span>(<span class="string">&#x27;9007199254740993&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>通过 <code>BigInt</code>， 我们可以安全的进行大数整型计算。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bigNumRet = <span class="number">9007199254740993n</span> + <span class="number">9007199254740993n</span> <span class="comment">// -&gt; -&gt; 18014398509481986n</span></span><br><span class="line">bigNumRet.toString() <span class="comment">// -&gt; &#x27;18014398509481986&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ol>
<li><code>BigInt</code> 是一种新的数据原始（primitive）类型。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">9007199254740993n</span> <span class="comment">// -&gt; &#x27;bigint&#x27;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>尽可能避免通过调用函数 <code>BigInt</code> 方式来实例化超大整型。因为参数的字面量实际也是 <code>Number</code> 类型的一次实例化，超出安全范围的数字，可能会引起精度丢失。</li>
</ol>
<h3 id="7-String-prototype-matchAll-1"><a href="#7-String-prototype-matchAll-1" class="headerlink" title="7.String.prototype.matchAll"></a>7.String.prototype.matchAll</h3><blockquote>
<p>The <code>matchAll()</code> method returns an iterator of all results matching a string against a regular expression, including capturing groups. ——MDN</p>
</blockquote>
<p>思考下面代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&lt;text&gt;JS&lt;/text&gt;&lt;text&gt;正则&lt;/text&gt;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/&lt;\w+&gt;(.*?)&lt;\/\w+&gt;/g</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg))</span><br><span class="line"><span class="comment">// -&gt; [&quot;&lt;text&gt;JS&lt;/text&gt;&quot;, &quot;&lt;text&gt;正则&lt;/text&gt;&quot;]</span></span><br></pre></td></tr></table></figure>

<p>可以看出返回的数组里包含了父匹配项，但未匹配到子项（group）。移除全局搜索符”<code>g</code>“试试。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&lt;text&gt;JS&lt;/text&gt;&lt;text&gt;正则&lt;/text&gt;&#x27;</span></span><br><span class="line"><span class="comment">// 注意这里没有全局搜素标示符&quot;g&quot;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/&lt;\w+&gt;(.*?)&lt;\/\w+&gt;/</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面会打印出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    &quot;&lt;text&gt;JS&lt;/text&gt;&quot;,</span></span><br><span class="line"><span class="comment">    &quot;JS&quot;,</span></span><br><span class="line"><span class="comment">    index: 0,</span></span><br><span class="line"><span class="comment">    input:</span></span><br><span class="line"><span class="comment">    &quot;&lt;text&gt;JS&lt;/text&gt;&lt;text&gt;正则&lt;/text&gt;&quot;,</span></span><br><span class="line"><span class="comment">    groups: undefined</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这样可以获取到匹配的父项，包括子项（group），但只能获取到第一个满足的匹配字符。能看出上面无法匹配到<code>&lt;text&gt;正则&lt;/text&gt;</code>。</p>
<p>如果获取到全局所有匹配项，包括子项呢？</p>
<p>ES2020 提供了一种简易的方式：<code>String.prototype.matchAll</code>, 该方法会返回一个迭代器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&lt;text&gt;JS&lt;/text&gt;&lt;text&gt;正则&lt;/text&gt;&#x27;</span></span><br><span class="line"><span class="keyword">var</span> allMatchs = str.matchAll(<span class="regexp">/&lt;\w+&gt;(.*?)&lt;\/\w+&gt;/g</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> allMatchs) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一次迭代返回：</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    &quot;&lt;text&gt;JS&lt;/text&gt;&quot;,</span></span><br><span class="line"><span class="comment">    &quot;JS&quot;,</span></span><br><span class="line"><span class="comment">    index: 0,</span></span><br><span class="line"><span class="comment">    input: &quot;&lt;text&gt;JS&lt;/text&gt;&lt;text&gt;正则&lt;/text&gt;&quot;,</span></span><br><span class="line"><span class="comment">    groups: undefined</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">第二次迭代返回：</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    &quot;&lt;text&gt;正则&lt;/text&gt;&quot;,</span></span><br><span class="line"><span class="comment">    &quot;正则&quot;,</span></span><br><span class="line"><span class="comment">    index: 15,</span></span><br><span class="line"><span class="comment">    input: &quot;&lt;text&gt;JS&lt;/text&gt;&lt;text&gt;正则&lt;/text&gt;&quot;,</span></span><br><span class="line"><span class="comment">    groups: undefined</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>能看出每次迭代中可获取所有的匹配，以及本次匹配的成功的一些其他元信息。</p>
<h1 id="ES12"><a href="#ES12" class="headerlink" title="ES12"></a>ES12</h1><h3 id="1-replaceAll"><a href="#1-replaceAll" class="headerlink" title="1. replaceAll"></a>1. replaceAll</h3><blockquote>
<p>返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">str.replaceAll(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;&#x27;</span>); <span class="comment">// &quot;heo word&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Promise-any"><a href="#2-Promise-any" class="headerlink" title="2. Promise.any"></a>2. Promise.any</h3><blockquote>
<p>Promise.any() 接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">&#x27;我是失败的Promise_1&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">&#x27;我是失败的Promise_2&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> promiseList = [promise1, promise2];</span><br><span class="line"><span class="built_in">Promise</span>.any(promiseList)</span><br><span class="line">.then(<span class="function"><span class="params">values</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/1725797/202104/1725797-20210418143154504-916308179.png" alt="img"></p>
<h3 id="3-WeakRefs"><a href="#3-WeakRefs" class="headerlink" title="3. WeakRefs"></a>3. WeakRefs</h3><blockquote>
<p>使用WeakRefs的Class类创建对对象的弱引用(对对象的弱引用是指当该对象应该被GC回收时不会阻止GC的回收行为)</p>
</blockquote>
<h3 id="4-逻辑运算符和赋值表达式"><a href="#4-逻辑运算符和赋值表达式" class="headerlink" title="4. 逻辑运算符和赋值表达式"></a>4. 逻辑运算符和赋值表达式</h3><blockquote>
<p>逻辑运算符和赋值表达式，新特性结合了逻辑运算符（&amp;&amp;，||，??）和赋值表达式而JavaScript已存在的 复合赋值运算符有：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a ||= b</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">a = a || (a = b)</span><br><span class="line"></span><br><span class="line">a &amp;&amp;= b</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">a = a &amp;&amp; (a = b)</span><br><span class="line"></span><br><span class="line">a ??= b</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">a = a ?? (a = b)</span><br></pre></td></tr></table></figure>

<h3 id="5-数字分隔符"><a href="#5-数字分隔符" class="headerlink" title="5. 数字分隔符"></a>5. 数字分隔符</h3><blockquote>
<p>数字分隔符，可以在数字之间创建可视化分隔符，通过_下划线来分割数字，使数字更具可读性</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> money = <span class="number">1_000_000_000</span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">const</span> money = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1_000_000_000</span> === <span class="number">1000000000</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img2020.cnblogs.com/blog/1725797/202104/1725797-20210418143146821-1153645970.png" alt="img"></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Js/" rel="tag"># Js</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/12/12/vite%E6%90%AD%E5%BB%BAreact/" rel="prev" title="vite搭建react">
                  <i class="fa fa-chevron-left"></i> vite搭建react
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<span id="timeDate">载入天数...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("05/06/2021 15:13:14");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 " + dnum + " 天 "+ hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lruler</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
