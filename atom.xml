<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Le-zone</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-20T12:39:00.286Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Lruler</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react-hooks</title>
    <link href="http://example.com/2021/11/18/react-hooks/"/>
    <id>http://example.com/2021/11/18/react-hooks/</id>
    <published>2021-11-18T13:40:17.000Z</published>
    <updated>2021-11-20T12:39:00.286Z</updated>
    
    <content type="html"><![CDATA[<p>对react-hooks系统的做一次总结吧，不然总是写着查写着查</p><span id="more"></span><p>对于react-hooks不多赘述，就理解为这些hooks让函数组件拥有了类组件的大部分功能并代替类组件使用就行</p><p>然后react中有七大hooks</p><ol><li>useState 函数组件中使用State</li><li>useEffect 函数组件中的副作用使用</li><li>useContext 全局数据共享</li><li>useReducer 简化版redux</li><li>userMemo / useCallback 缓存, 优化性能</li><li>useRef 引用实例，保存变量</li><li>自定义hook</li></ol><h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><p>useState就是衍生自setState()，它让函数组件从无状态的简单组件变成了复杂组件，使用方式和setState()差不多，每个组件通过维护自己的state去处理一些业务逻辑,其实使用上是比较简单的，但深究起来…龟龟，就设计到react的底层逻辑了，就是每次setState后会发生什么。</p><p>所以，为了了解useState的用法，我们还是先探究一下setState()的工作机制。</p><p>对于setState的使用其实很简单，react官方文档的例子看看就能懂</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.timerID = <span class="built_in">setInterval</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="built_in">this</span>.tick(),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">tick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>具体我就不解释了，就是每次setState()会重新render然后又依次调用生命周期函数，然后DidMount后又tick了一下，this.state()指向一个全新的引用，又重新render，就出现了一个每秒钟递增的计时器效果。其他对于state的基本使用官方文档讲的已经很明白了，这里不赘述，我们在这里就说一下setState()会经常被提起的两个问题</p><ol><li>setState()是同步更新还是异步更新</li><li>setState()是合并更新还是替换更新</li></ol><p>先说第二点吧，直接结论，setState是合并更新，直接看代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.state = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setState(&#123;<span class="attr">d</span>: <span class="number">4</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上是 setState(&#123;...this.state, d: 4&#125;)</span></span><br></pre></td></tr></table></figure><p>为什么是合并更新很好理解嘛，因为控制某个组件的状态都得放在this.state这一个对象里面，然后我们想想看，假设这个页面需要的状态很多，也就是要有一堆key value，但我们每次更改state应该只会更改其中的一项，那我们每次写都要</p><p><code>setState(&#123;...this.state, a: xx&#125;)</code></p><p>万一哪次我们忘了，会咋样，就看上面那块，整个state就变成了{d: 4},那用到a,b的地方渲染的就是undefined，Oh，然后GG，所以为了避免这种情况发生react就在底层做了这么一层浅合并的处理，当然，这也不完全是好的。我们在看下面这一串代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.state = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="string">&#x27;muxiMfe&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  setState(&#123; <span class="attr">a</span>: <span class="number">2</span>&#125;) </span><br><span class="line">  setState(&#123; <span class="attr">b</span>:<span class="string">&quot;muxiMbe&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想想看，最后我们console.log(this.state)，输出是什么？是{a: 2, b:”muxiMbe”}吗？ 这个问题放在后面讲了异步同步的问题再来解答，大家伙好好想想。</p><p>而useState()是替换更新，这个待会儿再讲。所以，在明确setState()是合并更新后，我们再来看第一个问题</p><p>setState()是同步更新还是异步更新？</p><p>我们看看react官网怎么说</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">State 的更新可能是异步的</span><br><span class="line">出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。</span><br></pre></td></tr></table></figure><p>啥意思呢，假设有如下代码 (为了方便就简写一些伪代码)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.state = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  setState(&#123;<span class="attr">a</span>: a + <span class="number">1</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//a 输出？</span></span><br></pre></td></tr></table></figure><p>大家应该都知道a会输出2，这就说明了setState是异步执行的，所以a拿到的还是之前的值，那为什么setState()会被异步执行？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (xxx) &#123;</span><br><span class="line">  setState() <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">setState() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>如果是同步更新，会出现什么样的情况？ 就是当代码执行到1的时候， 页面被重新render一次，然后到2，又重新render一次，所以我们每一次调用setState()都会重新渲染页面，这对性能的消耗是巨大的。</p><p>接下来说的要涉及到Js的循环队列，这部分也比较重要，说起来比较麻烦，这里就不讲了。可以自行了解。</p><p>为了解决这个问题，react就在底层实现了一个缓存队列，每次的setState()都不会立刻执行，都会放到这个缓存队列里面去(类似于原生Js的任务队列)，然后去执行其他语句(执行栈)，等到执行栈空后，再来合并更新缓存队列里面的state，这样哪怕一个事件处理函数里有多个setState()，也只会重新调用一次render。</p><p>那，官网上说 可能是异步的，所以什么时候是同步的呢？</p><p>我们先想想我们什么时候会用到setState()</p><ol><li>生命周期里面发送请求后重绘页面</li><li>与用户发生交互</li><li>定时器触发</li></ol><p>这里注意到，生命周期和与用户交互的合成事件，都是react自己封装的API，所以他们都会对这里面调用的setState()进行包装处理放入缓存队列中，也就是会异步执行，而定时器(又或者addEventsListener)，是浏览器自带的API，react并没有对其封装重写，所以定时器里的setState()就会跳出react的控制，不会被放到缓存队列中，也就是说：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.state = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> setState(&#123;<span class="attr">a</span>: a + <span class="number">1</span>&#125;))</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 这里的a 就会是2</span></span><br></pre></td></tr></table></figure><p>而setState()是如何执行异步/同步的呢？</p><p>查看react源码发现，代码中有一个变量锁<strong>isBatchingUpdates</strong>,isBatchingUpdates表示是否进行批量更新，初始化时默认为false，batchedUpdates方法会将isBatchingUpdates设为true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  <span class="attr">isBatchingUpdates</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">batchedUpdates</span>: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ReactDefaultBatchingStrategy;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了合并setState，我们需要一个队列来保存每次setState的数据，然后在一段时间后，清空这个队列并渲染组件，这个队列就是dirtyComponents。当isBatchingUpdates为true时，将会执行 <strong>dirtyComponents.push(component);</strong> 将组件push到dirtyComponents队列。<br> 调用setState()时，其实已经调用了ReactUpdates.batchedUpdates，此时isBatchingUpdates便是true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">dirtyComponents.push(component);</span><br></pre></td></tr></table></figure><p>至此，setState实现了合并和批量处理。</p><p>好，这时候我们再来看看刚刚那个遗留问题，console.log(a)到底会输出啥？答案是{a:1, b:”muxiMbe”}</p><p>为啥？ 想想看，</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.state = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="string">&#x27;muxiMfe&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  setState(&#123;...this.state, <span class="attr">a</span>: <span class="number">2</span>&#125;) <span class="comment">//执行这一句的时候，this.state是对&#123;a:1, b:&#x27;muxiMfe&#x27;&#125;的引用，推入缓存队列的新状态应该是&#123;a:2, b:&#x27;muxiMfe&#x27;&#125;</span></span><br><span class="line">  setState(&#123;...this.state, <span class="attr">b</span>:<span class="string">&quot;muxiMbe&quot;</span>&#125; <span class="comment">// 这一句，this.state仍然是对&#123;a:1, b:&#x27;muxiMfe&#x27;&#125;的引用，推入缓存队列的状态是&#123;a:1, b:&quot;muxiMbe&quot;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行栈执行完毕，合并更新处理缓存队列的state，后面的会覆盖前面的，故输出&#123;a:1, b:&quot;muxiMbe&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>那再想想这个输出什么？</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.state = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="string">&#x27;muxiMfe&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onClick1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  setState(&#123;<span class="attr">a</span>: <span class="number">2</span>&#125;)</span><br><span class="line">  setState(&#123;...this.state, <span class="attr">b</span>:<span class="string">&#x27;muxiMbe&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onClick2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  setState(&#123;<span class="attr">a</span>: <span class="number">2</span>&#125;)</span><br><span class="line">  setState(&#123;<span class="attr">b</span>: <span class="string">&#x27;muxiMbe&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1输出&#123;a:1, b:&#x27;muxiMbe&#x27;&#125; 2输出&#123;a:2, b:&#x27;muxiMbe&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>可能现在还对setState()有点迷糊，但没事，哎，我们的重点是啥，useState()!</p><p>首先我们明确，useState()是让函数组件中有了state,返回一个xx(某个state的名字)和setXX() (设置这个state的方法)，然后这个setXX,大部分特性setState()的特性是一样的，但又有些不一样，这里官方文档也提到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意</span><br><span class="line"></span><br><span class="line">你可能想知道：为什么叫 useState 而不叫 createState?</span><br><span class="line"></span><br><span class="line">“Create” 可能不是很准确，因为 state 只在组件首次渲染的时候被创建。在下一次重新渲染时，useState 返回给我们当前的 state。否则它就不是 “state”了！这也是 Hook 的名字总是以 use 开头的一个原因。我们将在后面的 Hook 规则中了解原因。</span><br></pre></td></tr></table></figure><p>想想看为啥，类组件如何渲染虚拟DOM？render方法，他的state则是类的一个属性，所以无论render几次，this.state只是指向一个新的引用地址而已，也就是说整个类不会被销毁重新创建，只是会依次调用相应的生命周期方法，而函数组件呢？ 他只有一个return，所以每次状态改变，都会重新调用一次这个函数，函数作用域销毁重建，内部变量也是这样一个步骤。所以为了保存上一次的变量，要么用闭包(很多一些简易版的useState()的源码就是通过闭包实现)，要么用ref，所以这里也可以解答为什么useState()是替换更新而不是合并更新了。</p><p>先看看一般大佬们自己封装的简易版useState()</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memoizedState: any[] = [] <span class="comment">// hooks 的值存放在这个数组里</span></span><br><span class="line"><span class="keyword">let</span> cursor = <span class="number">0</span> <span class="comment">// 当前 memoizedState 的索引</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initialValue: any</span>) </span>&#123;</span><br><span class="line">    memoizedState[cursor] = memoizedState[cursor] || initialValue</span><br><span class="line">    <span class="keyword">const</span> currentCursor = cursor</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState: any</span>) </span>&#123;</span><br><span class="line">        memoizedState[currentCursor] = newState</span><br><span class="line">        cursor = <span class="number">0</span></span><br><span class="line">        render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [memoizedState[cursor++], setState] <span class="comment">// 返回当前 state，并把 cursor 加 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很明显的看出来返回的setState就运用到了闭包来访问memmoizedState，源码更为复杂，比如这里就没有涉及到刚刚提及的异步问题，这里的useState()都是同步执行。</p><p>所以，useState()也和setState()一样在合成事件中是异步的吗？答案是肯定的。和setState一样，useState在合成事件以及useEffect这些react封装的API呈现异步更新，而在定时器等webAPI中的话就是同步执行。</p><p>而如何异步执行大体流程也和setState一样，先放入缓存队列后在批量更新，重新执行函数组件的每一行代码。那就带来另一个问题，重新执行每一行代码，那为什么useState中的state不会被传进去的initState覆盖？ 这里看上面的代码<code>memoizedState[cursor] = memoizedState[cursor] || initialValue</code>就能解释，react底层同样做了类似的处理(应该是更流弊的处理不过我还没看懂)来让initialValue只传入一次。</p><p>所以，其实弄懂了setState(),useState()也没什么特别难懂的地方。但还是要注意一些问题</p><ol><li>useState如何同步获取代码</li></ol><p>既然都说了useState在大多数情况下其实是异步更新的？那现在有个需求，我就是想更新state后立刻拿到最新的state，我该如何操作？先看setState()</p><p>其实setState有两个参数，第一个就是新的state的值，第二个是一个callback函数，这个callback函数会在缓存队列被清空后立刻执行,这样就可以拿到最新的state了。 那函数组件呢？ 哎，用useEffect, useEffect也会在每次函数组件更新时都执行一遍，在这里拿到state最新的代码就行(注意依赖)</p><ol start="2"><li>用useState返回的setState更新状态后会发生什么</li></ol><p>还是一样，先想想看setState后发生什么？ 首先this.state指向一个新对象，然后重新调render()，其他的生命周期再走一遍</p><p>而useState没那么多复杂，比如你的函数组件叫App, 那在useState这个hooks里，更新你的state后，直接App()，对，就是直接再调用一下这个函数而已。</p><p>所以我们看一下代码，再来检测一下对setState/useState工作机制的掌握程度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [a, setA] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>, a)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClickWithPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setA(<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span>)</span><br><span class="line">      setA(<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClickWithoutPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setA(<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span>)</span><br><span class="line">    setA(<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClickWithPromise&#125;</span>&gt;</span>&#123;a&#125; 异步执行<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClickWithoutPromise&#125;</span>&gt;</span>&#123;a&#125; 同步执行<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以点击两个按钮，分别会发生什么？</p><p>第一个两行输出，a 2 和 a 3 第二个只会输出一行 a 3 setState同理，具体原因不解释了，再仔细看看之前说的那些。</p><p>至此，对于state的机制应该算是说的差不多了，至于源码究竟是怎么实现的，目前还看不懂呜呜呜。</p><p>但你们以为这就结束了？不不不，我们再来想一个问题。</p><p>首先我们明确，react代码最后会被编译解释成原生的Js，那问题来了，对于setState()，他到底是宏任务还是微任务？</p><p>简单解释一下什么是宏任务和微任务，具体了解还得和前面提到的事件循环机制一起去好好看看。</p><p>就举个例子，我们把Js的任务队列当成一个银行柜台，然后里面的每个任务当成顾客，顾客一个个去银行柜台办理业务，任务就一个个执行。那银行柜台是怎么给顾客办理业务的？顾客按照先来后到的顺序编号，然后一个个叫号，叫到谁谁去，所以在这里，每一个顾客，就是一个宏任务，然后办理业务的时候，总会遇见一些大爷大妈，你给他办完了银行业务，准备叫下一个了，哎，他不走，他非要把你拽住，说“小姑娘我看你怪俊俏的嘞，我隔壁村头有个小伙子蛮不错的你们要不要认识一下？”然后柜台又得皱着眉头把这些杂七杂八的事给处理完，哎，这些事，就是微任务。</p><p>所以我们可以得出</p><ul><li><p>宏任务永远在微任务前执行</p></li><li><p>微任务没有执行完成前不得进行下一个宏任务</p></li></ul><p>宏任务有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">script(整体代码)</span><br><span class="line">setTimeout()</span><br><span class="line">setInterval()</span><br><span class="line">postMessage</span><br><span class="line">I/O</span><br><span class="line">UI交互事件</span><br></pre></td></tr></table></figure><p>微任务有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.then</span><br><span class="line">Object.observe</span><br><span class="line">MutationObserver</span><br><span class="line">process.nextTick(Node.js 环境)</span><br></pre></td></tr></table></figure><p>哎，那我们想想看，setState作为一个“异步操作”，那他到底是会被放入宏任务队列，还是微任务队列呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;宏任务触发&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微任务触发&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    ...this.state</span><br><span class="line">  &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setState&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出啥？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setState</span><br><span class="line">微任务触发</span><br><span class="line">宏任务触发</span><br></pre></td></tr></table></figure><p>在一个事件循环中，入执行栈的事件比微任务晚，但执行时间却早于微任务，怎么，setState是同步任务？可不对啊，前面不是很明白的说了setState在合成事件中和生命周期里面是异步任务吗？哎，都说了，是在react合成事件中和生命周期里面被react底层处理后，<strong>才显示异步的状态</strong>，那我们把他拿出来看看呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始运行&#x27;</span>)</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      ...this.State</span><br><span class="line">    &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;setState&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;结束运行&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果毫无意外的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始运行</span><br><span class="line">setState</span><br><span class="line">结束运行</span><br></pre></td></tr></table></figure><p><em><strong>所以！！！setState在本质上就是在一个事件循环中，在运行上是基于同步代码的实现，他并不会被推到任务队列里面去！他只是有异步的行为而已，说得通俗一点，setState是一个伪异步，或者可以称为defer，即延迟执行但本身还在一个事件循环，所以它的执行顺序在同步代码后、异步代码前。</strong></em></p><p>至此，对于state的机制大概就到这里了，因为useState在hooks里面的特性还是与setState高度类似的，所以可能主要还是再讲setState。</p><p>接下来就看看另一个贼重要的hooks——useEffect()</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对react-hooks系统的做一次总结吧，不然总是写着查写着查&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>搞钱项目总结</title>
    <link href="http://example.com/2021/11/15/%E6%90%9E%E9%92%B1%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/11/15/%E6%90%9E%E9%92%B1%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2021-11-15T12:11:01.000Z</published>
    <updated>2021-11-18T02:12:51.893Z</updated>
    
    <content type="html"><![CDATA[<p>这个就是接了一个心理学院的项目，帮他们做一个测试卷嘛，一千五，哎，缺钱，接了，写的比较随意，但学了点东西，写篇总结。</p><span id="more"></span><h1 id="React-Router-v6"><a href="#React-Router-v6" class="headerlink" title="React-Router v6"></a>React-Router v6</h1><p>首先就是因为之前写的都是学长学姐已经把脚手架都搭好了，所以对于router的使用还停留在v5版本，然后这次自己新开一个脚手架，mad，router偷偷摸摸升级到v6，像什么Switch啊Redirect啥的直接移除了，所以写的时候有点崩溃，然后就看了文档跟一些博客后就回去接着写了，这里就简单的介绍一下v6的一些用法。</p><h2 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h2><p>这没啥 就是换了个名字，代替Switch</p><h2 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h2><p>这个 改的我 奇奇怪怪莫名其妙</p><p>以前很方便啊，用activeClassName，然后给自己自定义的类名写一点样式就可以做到自定义了，(以前是默认加上active的类名)，然后升级到v6后，我们康康这个贼官方文档怎么说的</p><p><strong>One difference as of <code>v6.0.0-beta.3</code> is that <code>activeClassName</code> and <code>activeStyle</code> have been removed from <code>NavLinkProps</code>. Instead, you can pass a function to either <code>style</code> or <code>className</code> that will allow you to customize the inline styling or the class string based on the component’s active state.</strong></p><p>我是真的想啸，直接给移除了，现在想改类名或者直接写行内样式的话得用函数形式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">&quot;messages&quot;</span></span><br><span class="line">  style=&#123;<span class="function">(<span class="params">&#123; isActive &#125;</span>) =&gt;</span></span><br><span class="line">    isActive ? activeStyle : <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&gt;</span><br><span class="line">  Messages</span><br><span class="line">&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure><p>官网用例, className同理</p><h2 id="Navigate"><a href="#Navigate" class="headerlink" title="Navigate"></a>Navigate</h2><p>同样换名 代替 Redirect</p><p><code>&lt;Route path=&quot;*&quot; element=&#123;&lt;Navigate to&#39;/login&#39; /&gt;&#125; /&gt;</code></p><h2 id="Route-element"><a href="#Route-element" class="headerlink" title="Route element"></a>Route element</h2><p>就是v5 Route component + render 的结合体嘛， 就是可以给自己的子路由传props咯，也很简单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/home&#x27;</span> element= &#123;<span class="xml"><span class="tag">&lt;<span class="name">Home</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>&#125; /&gt;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h2 id="Link-to"><a href="#Link-to" class="headerlink" title="Link to"></a>Link to</h2><p>就是加了点to的方式，因为v6的嵌套路由相对于v5升级了很多(后面会提到)，所以作为一种跳转方式Link to肯定也要相应的升级，这里直接看文档怎么说的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// If your routes look like this</span><br><span class="line">&lt;Route path=&quot;app&quot;&gt;</span><br><span class="line">  &lt;Route path=&quot;dashboard&quot;&gt;</span><br><span class="line">    &lt;Route path=&quot;stats&quot; /&gt;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">&lt;/Route&gt;</span><br><span class="line"></span><br><span class="line">// and the current URL is /app/dashboard (with or without</span><br><span class="line">// a trailing slash)</span><br><span class="line">&lt;Link to=&quot;stats&quot;&gt;               =&gt; &lt;a href=&quot;/app/dashboard/stats&quot;&gt;</span><br><span class="line">&lt;Link to=&quot;../stats&quot;&gt;            =&gt; &lt;a href=&quot;/app/stats&quot;&gt;</span><br><span class="line">&lt;Link to=&quot;../../stats&quot;&gt;         =&gt; &lt;a href=&quot;/stats&quot;&gt;</span><br><span class="line">&lt;Link to=&quot;../../../stats&quot;&gt;      =&gt; &lt;a href=&quot;/stats&quot;&gt;</span><br><span class="line"></span><br><span class="line">// On the command line, if the current directory is /app/dashboard</span><br><span class="line">cd stats                        # pwd is /app/dashboard/stats</span><br><span class="line">cd ../stats                     # pwd is /app/stats</span><br><span class="line">cd ../../stats                  # pwd is /stats</span><br><span class="line">cd ../../../stats               # pwd is /stats</span><br></pre></td></tr></table></figure><p>.代表当前路径 ..代表上一级路径嘛</p><h2 id="useRoutes"><a href="#useRoutes" class="headerlink" title="useRoutes"></a>useRoutes</h2><p>就是配置式路由， 代替react-router-config，不怎么常用吧好像，大部分还是愿意写JSX而不是JS来声明路由的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> element = useRoutes([</span><br><span class="line">    <span class="comment">// These are the same as the props you provide to &lt;Route&gt;</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;dashboard&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Dashboard</span> /&gt;</span></span> &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;invoices&quot;</span>,</span><br><span class="line">      <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Invoices</span> /&gt;</span></span>,</span><br><span class="line">      <span class="comment">// Nested routes use a children property, which is also</span></span><br><span class="line">      <span class="comment">// the same as &lt;Route&gt;</span></span><br><span class="line">      children: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;:id&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">Invoice</span> /&gt;</span></span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;sent&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">SentInvoices</span> /&gt;</span></span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Not found routes work as you&#x27;d expect</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;*&quot;</span>, <span class="attr">element</span>: <span class="xml"><span class="tag">&lt;<span class="name">NotFound</span> /&gt;</span></span> &#125;</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The returned element will render the entire element</span></span><br><span class="line">  <span class="comment">// hierarchy with all the appropriate context it needs</span></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码大概长这样</p><h2 id="useNavigate"><a href="#useNavigate" class="headerlink" title="useNavigate"></a>useNavigate</h2><p>代替useHistory, 然后看他的interface嘛navigate接受两个参数一个to 一个opt, to可以用来写路径或者直接1，-1这些数字，就是原来history里面的push啊go啊，然后opt就是用来设置是否replace和路由传参的(state参数)</p><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>就是对于子路由的实现，v5版本得这样写</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/profile&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Profile&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Profile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> match = useRouteMatch();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">match.url</span>&#125;/<span class="attr">me</span>`&#125;&gt;</span>My Profile<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">match.path</span>&#125;/<span class="attr">me</span>`&#125;&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">MyProfile</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">match.path</span>&#125;/<span class="attr">:id</span>`&#125;&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">OthersProfile</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>菁程和工作台都是这样一个写法，然后到了v6,咱就可以</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v6</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Routes, Route, Link, Outlet &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Approach #1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;profile/*&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Profile</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Profile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;me&quot;</span>&gt;</span>My Profile<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;me&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">MyProfile</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;:id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">OthersProfile</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Approach #2</span></span><br><span class="line"><span class="comment">// You can also define all</span></span><br><span class="line"><span class="comment">// &lt;Route&gt; in a single place</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;profile&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Profile</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;:id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">MyProfile</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;me&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">OthersProfile</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Profile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;me&quot;</span>&gt;</span>My Profile<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>注意，这里的 <Outlet>也是v6的新写法，就是表示子路由界面的Element</Outlet></strong></p><p>大概就是这些改动，具体还没有深读过，没办法，太菜了，还停留在调API的阶段。</p><h1 id="关于Contnent-type"><a href="#关于Contnent-type" class="headerlink" title="关于Contnent-type"></a>关于Contnent-type</h1><p>然后由于是开的JS项目，所以还是手写封装fetch，这个小幸运已经讲过了，原本我以为交互会很简单，结果，万万没想到，大家一定别找一个天天学C++的后端，就是一个需求是前端需要传一个数组，后端跟我说不行没法处理，不能绑定啥吧啦吧啦的，我寻思这不是欺负我不懂？但后端如果能接受Json的话我把数组转成Json再给他不行？再不济我转成字符串给他？然后找了一个我从来没见过的格式让我传，就是这个<br><img src="/2021/11/15/%E6%90%9E%E9%92%B1%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/1..png" alt="postman"></p><p>X-www-from-urlencoded，人给我看傻了，没见过这种数据格式，于是就上网搜了下，说实话，搜了也没看懂，因为实在没多少用，接下来就是直接搬的概念了。</p><h2 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h2><ol><li>form-data</li></ol><p> 就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来说明文件类型；content-disposition，用来说明字段的一些信息；</p><p>由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。</p><p><img src="/2021/11/15/%E6%90%9E%E9%92%B1%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/fd1.png"></p><p><img src="/2021/11/15/%E6%90%9E%E9%92%B1%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/fd2.png"></p><ol><li>X-www-form-urlencoded</li></ol><p>就是<strong>application/x-www-from-urlencoded</strong>,会将表单内的数据转换为键值对，比如,name=java&amp;age = 23</p><p><img src="/2021/11/15/%E6%90%9E%E9%92%B1%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/url1.png"></p><p><img src="/2021/11/15/%E6%90%9E%E9%92%B1%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/url2.png"></p><ol><li>raw 这个就是我们比较熟悉的的一种格式了，可以上传任意格式的文本，text/json/xml/html等，然后我们大部分还是传json过去，因为json可以序列化大部分数据类型嘛</li></ol><p><img src="/2021/11/15/%E6%90%9E%E9%92%B1%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/raw1.png"></p><p><img src="/2021/11/15/%E6%90%9E%E9%92%B1%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/raw2.png"></p><ol><li><p>binary</p><pre><code>   相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。</code></pre></li></ol><p>multipart/form-data与x-www-form-urlencoded区别</p><pre><code>           multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息；           x-www-form-urlencoded：只能上传键值对，并且键值对都是间隔分开的。</code></pre><p>然后我们就可以看到，这些格式在headers里面的content- type都同，那什么是content- type呢？</p><h2 id="认识content-type"><a href="#认识content-type" class="headerlink" title="认识content-type"></a>认识content-type</h2><p>HTTP协议（RFC2616）采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，相应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以 及可能的实体内容。</p><p>通常HTTP消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成。<br>HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p><p>请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content- Base、Content-Encoding、Content-Language、 Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、 Etag、Expires、Last-Modified、extension-header。</p><p>Content-Type是返回消息中非常重要的内容，表示后面的文档属于什么MIME类型。Content-Type: [type]/[subtype]; parameter。例如最常见的就是text/html，它的意思是说返回的内容是文本类型，这个文本又是HTML格式的。原则上浏览器会根据Content-Type来决定如何显示返回的消息体内容。</p><h2 id="content-type-和Accept"><a href="#content-type-和Accept" class="headerlink" title="content-type 和Accept"></a>content-type 和Accept</h2><p>然后在之前有关fetch封装的代码里面，我们可以看到基本上只设置了两个值，Accept和content- type，那我们看看这二者的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">（1）Accept属于请求头， Content-Type属于实体头。</span><br><span class="line">Http报头分为通用报头，请求报头，响应报头和实体报头。</span><br><span class="line">请求方的http报头结构：通用报头|请求报头|实体报头</span><br><span class="line">响应方的http报头结构：通用报头|响应报头|实体报头</span><br><span class="line"></span><br><span class="line">（2）Accept代表发送端（客户端）希望接受的数据类型。</span><br><span class="line">比如：Accept：text/xml;</span><br><span class="line">代表客户端希望接受的数据类型是xml类型</span><br><span class="line"></span><br><span class="line">Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。</span><br><span class="line">比如：Content-Type：text/html;</span><br><span class="line">代表发送端发送的数据格式是html。</span><br><span class="line"></span><br><span class="line">二者合起来，</span><br><span class="line">Accept:text/xml；</span><br><span class="line">Content-Type:text/html</span><br><span class="line">即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html</span><br></pre></td></tr></table></figure><p>3.content-type 概览</p><p>这就贴一些常见的格式</p><p>常见的媒体格式类型如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">text</span>/html ： HTML格式</span><br><span class="line"><span class="built_in">text</span>/plain ：纯文本格式      </span><br><span class="line"><span class="built_in">text</span>/xml ：  <span class="keyword">XML</span>格式</span><br><span class="line"><span class="built_in">image</span>/gif ：gif图片格式    </span><br><span class="line"><span class="built_in">image</span>/jpeg ：jpg图片格式 </span><br><span class="line"><span class="built_in">image</span>/png：png图片格式</span><br></pre></td></tr></table></figure><p>以application开头的媒体格式类型：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">application/xhtml+<span class="keyword">xml</span> <span class="title">：XHTML</span>格式</span><br><span class="line">application/<span class="keyword">xml</span>     <span class="title">： XML</span>数据格式</span><br><span class="line">application/atom+<span class="keyword">xml</span>  <span class="title">：Atom</span> XML聚合格式    </span><br><span class="line">application/json    ： JSON数据格式</span><br><span class="line">application/pdf       ：pdf格式  </span><br><span class="line">application/msword  ： Word文档格式</span><br><span class="line">application/octet-stream ： 二进制流数据（如常见的文件下载）</span><br><span class="line">application/x-www-form-urlencoded ： <span class="tag">&lt;form encType=””&gt;</span>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以audio开头的常见媒体格式文件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&#x27;audio</span>/x-wav&#x27; : <span class="type">wav</span>文件</span><br><span class="line"><span class="symbol">&#x27;audio</span>/x-ms-wma&#x27; : <span class="type">wma</span> 文件</span><br><span class="line"><span class="symbol">&#x27;audio</span>/mp3&#x27; : <span class="type">mp3</span>文件</span><br></pre></td></tr></table></figure><p>以video开头的常见媒体格式文件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&#x27;video</span>/x-ms-wmv&#x27; : <span class="type">wmv</span>文件</span><br><span class="line"><span class="symbol">&#x27;video</span>/mpeg4&#x27; : <span class="type">mp4</span>文件</span><br><span class="line"><span class="symbol">&#x27;video</span>/avi&#x27; : <span class="type">avi</span>文件</span><br></pre></td></tr></table></figure><p>另外一种常见的媒体格式是上传文件之时使用的：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipart/<span class="keyword">form</span>-<span class="keyword">data</span> ： 需要在表单中进行文件上传时，就需要使用该格式</span><br></pre></td></tr></table></figure><p><strong>注意，fetch的默认方式是text，而AJAX是urlencoded</strong></p><p>但是，实际开发中，基本上还都是用raw的格式，因为Json太好用了，后端拿到数据后也不需要进行过多的处理，看了菁程和工作台，基本上都是只有application/json这一种格式，哪怕需要有文件上传，比如头像的上传，都会先转换成文本来处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上传图片后的处理方式  </span></span><br><span class="line"><span class="function"><span class="title">changeImg</span>(<span class="params">changeKind</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> imgFile = <span class="built_in">this</span>[changeKind].files[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (imgFile) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(imgFile.type)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">      <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line">      <span class="comment">// 将文件以Data URL形式进行读入页面</span></span><br><span class="line">      reader.readAsDataURL(imgFile);</span><br><span class="line"></span><br><span class="line">      reader.onload = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        _this.setState(&#123;</span><br><span class="line">          <span class="attr">img</span>: e.target.result,</span><br><span class="line">          imgFile</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 保存头像后的处理</span></span><br><span class="line">   <span class="keyword">if</span> (imgFile) &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">new</span> FormData();</span><br><span class="line">      data.append(<span class="string">&quot;image&quot;</span>, imgFile);</span><br><span class="line">     </span><br><span class="line">      ManageService.savePersonalAvatar(data)</span><br><span class="line">        .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.setState(&#123; <span class="attr">ifSave</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">          Store.dispatch(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;substituteAvatar&quot;</span>,</span><br><span class="line">            <span class="attr">payload</span>: img || <span class="string">&quot;&quot;</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>然后又在fetch中对body进行Json序列化，总的来说虽然动用FormData对象，但上传的时候依旧是Json数据。那不用Json怎么传？我只能说给大家看看原本的urlcoded长啥样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释的部分是原本的urlcoded格式写法，主要要更改headers里面的content-type   </span></span><br><span class="line"><span class="function"><span class="title">message</span>(<span class="params">result, group_id</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// let postResult = JSON.stringify(result)</span></span><br><span class="line">        <span class="comment">// let urlencoded = new URLSearchParams(BASE)</span></span><br><span class="line">        <span class="comment">// for (let i = 0; i &lt; result.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     urlencoded.append(&quot;result&quot;, result[i])</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// urlencoded.append(&quot;group_id&quot;, `$&#123;group_id&#125;`)</span></span><br><span class="line">        <span class="comment">// let urlStr = urlencoded.toString()  这里的urlStr类似于query参数的形式，&amp;result=1这种</span></span><br><span class="line">        <span class="keyword">return</span> Fetch(BASE + <span class="string">&#x27;/message&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: &#123;</span><br><span class="line">                <span class="attr">result</span>: result,</span><br><span class="line">                <span class="attr">group_id</span>: <span class="string">`<span class="subst">$&#123;group_id&#125;</span>`</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大概就是这些，算是对自己http知识方面的一个补充，这个项目逻辑也不算难，用状态提升就能解决大部分问题，主要自己写的比较赶，代码有点丑，所以多的也不放了，挣钱嘛，不寒颤。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个就是接了一个心理学院的项目，帮他们做一个测试卷嘛，一千五，哎，缺钱，接了，写的比较随意，但学了点东西，写篇总结。&lt;/p&gt;</summary>
    
    
    
    <category term="project" scheme="http://example.com/categories/project/"/>
    
    
    <category term="project" scheme="http://example.com/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>muxi-workbench总结</title>
    <link href="http://example.com/2021/10/18/muxi-workbench%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/10/18/muxi-workbench%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-18T11:52:01.000Z</published>
    <updated>2021-10-18T11:52:01.473Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>小幸运项目总结</title>
    <link href="http://example.com/2021/10/18/%E5%B0%8F%E5%B9%B8%E8%BF%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/10/18/%E5%B0%8F%E5%B9%B8%E8%BF%90%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-18T11:51:44.000Z</published>
    <updated>2021-11-18T02:15:34.225Z</updated>
    
    <content type="html"><![CDATA[<p>同时打三份工的日子终于放缓了一会儿，可以静下心来学点和写点总结博客了，这篇就是关于小幸运的总结博客</p><span id="more"></span><h1 id="项目概览"><a href="#项目概览" class="headerlink" title="项目概览"></a>项目概览</h1><p>大家应该也都玩过小幸运，具体的功能需求我就不多说了，当时暑假开工的时候，Uni那边是分了一个同级的女生一起，由于两个人都没有什么开发经验，所以一开始抽组件就没怎么抽，能复用的逻辑也大部分没有思考到(就比如弹窗)，一开始就是各自写各自的页面，所以也没有什么能过多交流的部分，再之后就是Uni那边换了一个大三的学长带我写，无论是代码的规范性还是一些逻辑写法都让我学到很多，(就比如css多按两个tab健就能让代码第一眼看上去无比美观)</p><p>接下来的介绍顺序应该是我先说一些我自己写的并值得拿出来的东西，然后就说一下通过这个项目学到了哪些。</p><p>我写的部分就是Home -&gt; Wishes -&gt; Send三个界面 和Service的封装</p><h1 id="Fetch的封装"><a href="#Fetch的封装" class="headerlink" title="Fetch的封装"></a>Fetch的封装</h1><p>进去后学长就让我先负责Service对象的封装，因为之前写的组件啊和路由跳转啊啥的都太自主化了（就是没怎么沟通我自己一个人在写根本不知道对方负责的部分到哪儿了的那种），很乱，所以学长就去重构部分静态代码和重写组件了，测接口的任务就我自己开始写了。</p><p>而之前并没有什么和后端有交互的项目经历，唯一的hackathon还是用Taro写的，没什么参考性，所以一开始就蛮懵的。就去找了些团队项目的代码直接放上去了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我不懂为啥不直接lucky.itoken呢...</span></span><br><span class="line"><span class="keyword">const</span> BASEURL = <span class="built_in">window</span>.location.href.slice(<span class="number">0</span>, <span class="built_in">window</span>.location.href.indexOf(<span class="string">&#x27;/&#x27;</span>, <span class="number">10</span>)) + <span class="string">&quot;/api&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fetch</span>(<span class="params">url, opt = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>) <span class="comment">//现在一般取名叫Authorization</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    opt.method = opt.method || <span class="string">&#x27;GET&#x27;</span>;</span><br><span class="line">    opt.headers = &#123;</span><br><span class="line">        <span class="attr">Accept</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    opt.headers.token = token</span><br><span class="line"></span><br><span class="line">    opt.body = <span class="built_in">JSON</span>.stringify(opt.data) || <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (opt.formdata) &#123;</span><br><span class="line">        opt.body = opt.formdata;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetch(url, opt)</span><br><span class="line">        .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response.ok) &#123;</span><br><span class="line">                <span class="keyword">return</span> response.json().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> response.json().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_, reject</span>) =&gt;</span> &#123; <span class="comment">//可以直接写成Promise.reject()</span></span><br><span class="line">                        reject(res);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.status === -<span class="number">2</span>) &#123;</span><br><span class="line">                alert(res.msg)</span><br><span class="line">                <span class="built_in">localStorage</span>.removeItem(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重定向到根目录，重新登录</span></span><br><span class="line">                <span class="keyword">let</span> redirectpos = <span class="built_in">window</span>.location.href</span><br><span class="line">                redirectpos = redirectpos.slice(<span class="number">0</span>, redirectpos.indexOf(<span class="string">&#x27;/&#x27;</span>, <span class="number">10</span>) + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">window</span>.location.href(redirectpos)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (res.status !== <span class="number">0</span>) &#123;</span><br><span class="line">                    alert(res.msg)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            alert(<span class="string">`服务端错误：<span class="subst">$&#123;e.message&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这算是最简单的一种封装形式了，然后我看了下菁程和老版工作台的代码，他们的token都存在了cookie里面，然后就有关于cookie操作的文件，目前我也没有遇到过要用cookie的情况，就没去仔细看了，然后他们还在Fetch的基础上再封装，也就是直接把GET,POST,DELETE这些请求方式当作方法暴露出来，就可以直接以get(url)方式来写了(菁程是这样的)。然后这里在测试的时候有一个bug，就是用户去查看自己的愿望时看到的愿望不是自己的，我当时是以为是后端问题，因为这是返回的response错了，但后端明确说了自己没问题，然后武理那边说这是缓存的问题，就是GET请求会有缓存而POST请求没有，所以要么给GET请求加上时间戳，要么把换成POST请求，换成POST的话后端那边就要改，于是就选择了前者，然后前者就需要再每一个GET里面加上一句生成当前时间戳的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getLightManInfo</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="keyword">new</span> URL(BASEURL + <span class="string">&#x27;/user/info/lightman&#x27;</span>)</span><br><span class="line">    url.searchParams.append(<span class="string">&quot;wish_id&quot;</span>, id)</span><br><span class="line">    url.searchParams.append(<span class="string">&quot;time&quot;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().getTime())</span><br><span class="line">    <span class="keyword">return</span> Fetch(url)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>所以这里如果我们之前封装好了GET,把这段逻辑放进去，就不需要重复写了，可惜时间上来不及了唉。。。</p><p>然后菁程对于我刚刚说的GET啊POST啊的再封装是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">url, data?</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> opts: OptsProps = data;   <span class="comment">//高阶函数？ 函数柯里化？</span></span><br><span class="line">    <span class="keyword">return</span> fn(url, opts);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> encapsulationMethod = <span class="function">(<span class="params">method</span>) =&gt;</span> &#123; <span class="comment">// 把时间戳加在这里就行</span></span><br><span class="line">  <span class="keyword">let</span> optsObj;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">url, opts</span>) =&gt;</span> &#123;</span><br><span class="line">    optsObj = opts || &#123;&#125;;</span><br><span class="line">    optsObj.method = method;</span><br><span class="line">    <span class="keyword">return</span> FetchData(url, optsObj);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> get = proxy(encapsulationMethod(<span class="string">&#x27;GET&#x27;</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> post = proxy(encapsulationMethod(<span class="string">&#x27;POST&#x27;</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> put = proxy(encapsulationMethod(<span class="string">&#x27;PUT&#x27;</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Delete = proxy(encapsulationMethod(<span class="string">&#x27;DELETE&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> putCompanyInfoLogo = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> put(<span class="string">&#x27;/company/info/logo&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">token</span>: <span class="literal">true</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后呢，现在写新的Ts项目，比如工作台2.0和木犀云，都用了Pont, 在Pont里只需要最简单的处理一下fetch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Request = <span class="function">(<span class="params">url, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (options === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">        options = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    url = <span class="string">`/api/v1<span class="subst">$&#123;url&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">    options.headers = &#123;</span><br><span class="line">        <span class="attr">Accept</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    options.headers.Authorization = <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.body) &#123;</span><br><span class="line">        options.body = <span class="built_in">JSON</span>.stringify(options.body)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fetch(url, options).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> res.json()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Request</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在最外层</span></span><br><span class="line">pontCore.useFetch(Request)</span><br></pre></td></tr></table></figure><p>至于Pont的具体原理还没有细究，但是很牛逼，其他的什么url都不用写，参数会自动提示，只需要调用接口就行！</p><h1 id="滑动愿望的动画"><a href="#滑动愿望的动画" class="headerlink" title="滑动愿望的动画"></a>滑动愿望的动画</h1><p>这个动画没啥好讲的，我用的就是最原始的写法，没有用任何库，原理和暑假直播讲的景深特效差不多，首先三个树叶绝对定位，然后写上不同的z-index凸显层级，再然后左边的就left: -10vw 右边的就left:10vw。然后这里要处理三个事件，onTouchStart, onTouchMove, onTouchEnd，分别对应手指接触屏幕，手指在屏幕上滑动，手指离开屏幕。然后根据手指在屏幕上滑动的距离找出一个比例关系去改变left就行。 思路和实现都很简单，但这种写法我觉得还是蛮烂的，所以就简单的放一下相对应的事件处理函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start/Move/End 都是控制愿望刷新动画的相关函数</span></span><br><span class="line"><span class="keyword">const</span> onTouchStart = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> touch = e.targetTouches[<span class="number">0</span>]</span><br><span class="line">    setStartX(&#123; <span class="attr">start</span>: touch.pageX, <span class="attr">move</span>: <span class="string">&#x27;&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> onTouchMove = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> touch = e.targetTouches[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> move_X = ((touch.pageX - startX.start) / <span class="number">5</span>)</span><br><span class="line">    setStartX(startX)</span><br><span class="line">    setMove(&#123; <span class="attr">img1</span>: move_X, <span class="attr">img2</span>: <span class="number">10</span>, <span class="attr">img3</span>: <span class="number">20</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> onTouchEnd = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setUpDate(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> (move.img1 &lt; -<span class="number">25</span>) &#123;</span><br><span class="line">        setMove(&#123; <span class="attr">img1</span>: -<span class="number">90</span>, <span class="attr">img2</span>: <span class="number">0</span>, <span class="attr">img3</span>: <span class="number">10</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (move.img1 &gt; <span class="number">20</span>) &#123;</span><br><span class="line">        setMove(&#123; <span class="attr">img1</span>: <span class="number">90</span>, <span class="attr">img2</span>: <span class="number">0</span>, <span class="attr">img3</span>: <span class="number">10</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        setMove(&#123; <span class="attr">img1</span>: <span class="number">0</span>, <span class="attr">img2</span>: <span class="number">10</span>, <span class="attr">img3</span>: <span class="number">20</span> &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 刷新愿望</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        setUpDate(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">let</span> newWishSource = wishes</span><br><span class="line">        newWishSource.push(newWishSource[<span class="number">0</span>])</span><br><span class="line">        newWishSource.splice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        setWishes(newWishSource)</span><br><span class="line">        <span class="comment">// 刷新动画</span></span><br><span class="line">        setMove(moveState)</span><br><span class="line">    &#125;, <span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就事后看了一些动画库 没准儿以后能用上</p><ul><li><a href="https://segmentfault.com/a/1190000018861018">React-transition-group 路由页面跳转动画库</a></li></ul><p>​        <a href="https://juejin.cn/post/6887471865720209415">优化方案</a></p><p><a href="http://reactcommunity.org/react-transition-group/transition-group">官网</a></p><ul><li><a href="https://react-spring.io/">react-spring</a> 这个好像可以用来写树叶滑动的动画，但没实践</li></ul><p>还有一些其他的，但也没必要，这种库会一个就行，大不了自己写，虽然可能会烂的一批….</p><h1 id="武理的第三方登录"><a href="#武理的第三方登录" class="headerlink" title="武理的第三方登录"></a>武理的第三方登录</h1><p>然后这里就是关于武理的一个第三方登录机制，就是说武理那边不直接暴露接口给Uni用嘛，就需要跳转到智慧理工大那个页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> goWHUT = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> position = <span class="built_in">window</span>.location.href</span><br><span class="line">    <span class="keyword">let</span> continueurl = position.slice(<span class="number">0</span>, position.indexOf(<span class="string">&#x27;/&#x27;</span>, <span class="number">10</span>))</span><br><span class="line">    <span class="keyword">let</span> posturl = continueurl + <span class="string">&quot;/api/login/whut/callback&quot;</span></span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">`https://ias.sso.itoken.team/portal.php?posturl=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(posturl)&#125;</span>&amp;continueurl=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(continueurl)&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后登录成功后智慧理工大会自动带着cookie重定向回来，我们就在cookie里拿到token就行了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> token = cookie.load(<span class="string">&#x27;jwt_token&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">        <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;token&#x27;</span>, token)</span><br><span class="line">        props.history.push(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;token&quot;</span>)) &#123;</span><br><span class="line">        props.history.push(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [props.history])</span><br></pre></td></tr></table></figure><p>学长告诉我是调用了一个ias接口，这我查半天没查到这个接口到底是个啥，总体的登录逻辑应该和通行证差不多吧，带着一个landing过去并存入cookie防止landing丢失，然后登录成功后依据landing并带着code重定向回来，嗯，大概是这样</p><h1 id="文本下划线的自动生成"><a href="#文本下划线的自动生成" class="headerlink" title="文本下划线的自动生成"></a>文本下划线的自动生成</h1><p>这个！ 破需求！ 折磨了我好久 ！ 查了n多方法！终于让我看到大佬的实现方式 直接上代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// wishes页面的下划线生成(处理超长文本)</span><br><span class="line"><span class="selector-class">.wishes</span> &#123;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, <span class="built_in">rgba</span>(<span class="number">241</span>, <span class="number">197</span>, <span class="number">126</span>, <span class="number">0</span>) <span class="number">10px</span>, transparent <span class="number">10px</span>),</span><br><span class="line"><span class="built_in">linear-gradient</span>(to left, <span class="built_in">rgba</span>(<span class="number">241</span>, <span class="number">197</span>, <span class="number">126</span>, <span class="number">0</span>) <span class="number">10px</span>, transparent <span class="number">10px</span>),</span><br><span class="line"><span class="built_in">linear-gradient</span>(<span class="built_in">rgba</span>(<span class="number">241</span>, <span class="number">197</span>, <span class="number">126</span>, <span class="number">0</span>) <span class="number">30px</span>, black <span class="number">30px</span>, black <span class="number">31px</span>, white <span class="number">31px</span>);</span><br><span class="line">&#125;</span><br><span class="line">// send页面的下划线生成</span><br><span class="line"><span class="selector-class">.send</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, <span class="built_in">rgb</span>(<span class="number">241</span>, <span class="number">197</span>, <span class="number">126</span>) <span class="number">10px</span>, transparent <span class="number">10px</span>),</span><br><span class="line">                <span class="built_in">linear-gradient</span>(to left, <span class="built_in">rgb</span>(<span class="number">241</span>, <span class="number">197</span>, <span class="number">126</span>) <span class="number">10px</span>, transparent <span class="number">10px</span>),</span><br><span class="line">                <span class="built_in">linear-gradient</span>(<span class="built_in">rgb</span>(<span class="number">241</span>, <span class="number">197</span>, <span class="number">126</span>) <span class="number">30px</span>, black <span class="number">30px</span>, black <span class="number">31px</span>, white <span class="number">31px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就当你在textarea里面写下超长文本后，由于background- image的默认repeat，咱就能看见自动出现的下划线咯！ 不过好像有点bug，就是在send页面，下划线不会跟着滑动，而wishes可以，这个没太懂，可能是textarea的原因？</p><h1 id="总体逻辑"><a href="#总体逻辑" class="headerlink" title="总体逻辑"></a>总体逻辑</h1><p>最后在大概梳理一下小幸运的逻辑吧，(没准有遗忘的地方？)</p><ol><li>进入选择学校,武理还是华师，两个Link，无交互，如果选择武理就是到智慧理工大进行第三方登录，华师的话跳转到login界面</li><li>在login界面输入账号密码，调后端给的接口，登陆成功后token存入localstorage中，并调用checkemail接口查询是否绑定邮箱，未绑定就到bindemail页面去调接口绑定一下再去home，绑定的就直接去home (这里前端没有写正则规范邮箱格式，不知道后端有没有写)</li><li>home页面就是九个分类嘛，一个tags数组map生成就行，修一下样式，然后根据分类可以进入愿望池，或者直接投递我的愿望</li><li>投递我的愿望也就是一个from嘛，愿望内容分类姓名联系方式啥的，不是很难，就是要写太多受控组件比较麻烦，不过应该会有一种自定义hooks的写法统一处理的，不过相关写法我自己没想出来也没查到，不然太多useState()也太麻烦了（又比如可以用antd的那种组件封装的形式？）</li><li>愿望池页面的难点就是动画和对树叶上超长文本愿望的处理咯，这里上面也已经说过了，(overflow:scroll和下划线解决)，然后一个是点亮愿望的按钮一个是去往我的愿望列表</li><li>点亮愿望的按钮按下去就会弹出一个表单，和Send页面几乎一致，也就是多写几个useState()的事。。。</li><li>然后到愿望列表页，分两个区域调两个接口，一个是MyPost一个是MyWish，根据投递时间排序，然后左下角有愿望状态显示</li><li>再之后就是到愿望详情页，对单个愿望进行实现/删除等操作，这里都是学长的部分了也没细究</li><li>还有一个分享页面，其实也就是针对一个愿望，页面几乎一致只不过有一个单独的点亮按钮</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>嗯….好像就没了？因为其实小幸运的页面逻辑不太难，静态方面用好flex就行(因为太多图片啦),然后有一个需要仔细考虑的地方就是，愿望状态分为未点亮/点亮未实现/已实现，然后愿望自身又分为自己投递的/点亮别人的，这些愿望都会出现在wishList这个页面，然后跳转到愿望详情detail那里，就要写很多判断来决定在detail页面到底是渲染哪种愿望状态的组件上去(因为不同状态的愿望按钮不一样，比如点亮的button是确认实现，然后已实现的button就会变成灰色等)，这个页面是学长负责的，我只是提供了点思路和想法，学长一个文件写了快五百行，因为当时快到上线期了，所以估计也没怎么拆组件复用逻辑了，总之小幸运还是如期上线了，第一个上线的项目能引起很多人去参与还是蛮有成就感的嘿。</p><p>最后贴一个项目链接<a href="https://dev.azure.com/949257748/Token/_git/LuckyFrontend">lucky</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;同时打三份工的日子终于放缓了一会儿，可以静下心来学点和写点总结博客了，这篇就是关于小幸运的总结博客&lt;/p&gt;</summary>
    
    
    
    
    <category term="project" scheme="http://example.com/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>UmiJs</title>
    <link href="http://example.com/2021/10/04/dvaJs/"/>
    <id>http://example.com/2021/10/04/dvaJs/</id>
    <published>2021-10-04T05:20:18.000Z</published>
    <updated>2021-10-24T02:25:29.617Z</updated>
    
    <content type="html"><![CDATA[<p>一篇关于Umijs的学习笔记</p><span id="more"></span><p>啥是UmiJs呢！？ 甭管他 我们先滚去了解 redux / redux-saga / dvajs</p><h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><p>这个网上教程一堆 自己也有博客 就不多说了 反正知道他是react中最火的一个状态管理的方案就行</p><h1 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h1><p>然后嘞 我们就看看啥是redux-saga,我们先想想redux是怎么写异步action的，哎，同步action是啥，dispatch一个对象，异步呢，就是dispatch一个函数嘛，然后在applyMiddleWare里面加上thunk，具体的实现原理大概就是tunk会帮你在函数action里面再调dispatch返回出原生的action对象，所以就可以在这个函数里面执行异步操作，因为最后返回的都是action对象，不影响reducer对action的处理，然后applyMiddleWare的作用原理是store=&gt;next=&gt;action=&gt;{}这种形式把所有的middleware串联起来再在最后调dispatch，就是enhancer，create Store()的第三个参数（前两个参数分别是reducer和initalState,这里enhancer可以理解为一种HOF，高阶函数，类似react的高阶组件，起到一个包装修饰的作用），这里就不多说了，这篇博客的重点也不是这个。</p><p>然后就有大佬觉得，哎呀thunk太麻烦啦，我不同的异步操作要分散在不同的action里面啊，我action形式也不统一一会儿object一会儿function的太丑了啊，你这轮子不行我要自己造。 这就是大佬的思考方式，别人的轮子不好用就自己造，我等凡人要么是硬着头皮用轮子要么是硬着头皮去找自己不喜欢的轮子。</p><p>于是，redux-saga出来了，官方一点的介绍是<br><strong>redux-saga 是一个用于管理 Redux 应用异步操作的中间件（又称异步 action）。 redux-saga 通过创建 Sagas 将所有的异步操作逻辑收集在一个地方集中处理，可以用来代替 redux-thunk 中间件。</strong>。<br>好，有了saga之后，redux的项目逻辑就被分成了两部分</p><ul><li>Reducers 处理由action带过来的state</li><li>Sagas 协调异步操作 (主要是网络请求)</li></ul><p>然后saga跟thunk的作用原理也不一样<br><img src="/2021/10/04/dvaJs/1.jpg" alt="saga"><br>看这张图，thunk作用在Middleware那里，用来帮你给action函数调disapatch，是在action创建后才起作用的。<br>然后saga，是在你应用启动后就被调用了，他的层级和reducer，store，view是一样的，就可以把他理解为一个被创建的进程，reducer处理action，store管理action，view渲染action带来的state，saga就负责在后台监听action，判断你是同步还是异步，然后帮你调其他API，比如发起异步请求啦，发起同步action啦，甚至是调用其他的saga。</p><p>大概了解了saga的原理后，我们就来看一下相关的API</p><h2 id="相应API"><a href="#相应API" class="headerlink" title="相应API"></a>相应API</h2><p>先看两个辅助函数 </p><ul><li>takeEvery</li><li>takeLatest</li></ul><p><strong>takeEvery()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建一个发送网络请求的异步action</span></span><br><span class="line"><span class="keyword">import</span> &#123; call, put &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">fetchUser</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">yield</span> call(Api.fetchUser, action.payload.url);</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;<span class="attr">type</span>: <span class="string">&quot;FETCH_SUCCEEDED&quot;</span>, data&#125;);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;<span class="attr">type</span>: <span class="string">&quot;FETCH_FAILED&quot;</span>, error&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后用takeEvery()触发他</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchFetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeEvery(<span class="string">&#x27;USER_REQUESTED&#x27;</span>, fetchUser)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这怎么理解？ 就假设有一个按钮，点一次可以加载列表，然后有人手欠就一直点点点点点点， 所以’USER_REQUESTED’就不断被分发(算是允许并发，处理多个相同的action)，也就是会一直调用fetchUser()这个saga。列表就会不断加载更新。So,如何解决有人喜欢显摆自己手速的问题呢？</p><p>takeLatest()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeLatest &#125; <span class="keyword">from</span> <span class="string">`redux-saga/effects`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetchUser</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchLastFetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> takeLatest(<span class="string">&#x27;USER_REQUESTED&#x27;</span>, fetchUser)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>这个辅助函数的意思就是说，当一个<code>USER_REQUESTED</code> action 被发起时，使用 <code>takeLatest</code> 来启动一个新的 <code>fetchUser</code> 任务。 由于 <code>takeLatest</code> 取消了所有之前启动且未完成的任务，这样便可以保证：即使用户以极快的速度连续多次触发 <code>USER_REQUESTED</code> action，我们都只会以最后的一个结束。</p><p>辅助函数介绍完了，我们来看看saga里面比较重要一个部分 Effect</p><h3 id="Effect函数"><a href="#Effect函数" class="headerlink" title="Effect函数"></a>Effect函数</h3><p>saga里面有很多执行Effect的函数，而这些是saga实现作用的关键，看一下常用的吧，为什么叫Effect呢，就是和纯函数对应吗，你异步操作肯定会有副作用产生，所以管你叫Effect没啥问题对吧</p><ul><li><strong>take(pattern)</strong></li></ul><p>take函数可以理解为监听未来的action，它创建了一个命令对象，告诉middleware等待一个特定的action， Generator会暂停，直到一个与pattern匹配的action被发起，才会继续执行下面的语句，也就是说，take是一个阻塞的 effect</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchFetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 监听一个type为 &#x27;FETCH_REQUESTED&#x27; 的action的执行，直到等到这个Action被触发，才会接着执行下面的 yield fork(fetchData)  语句</span></span><br><span class="line">     <span class="keyword">yield</span> take(<span class="string">&#x27;FETCH_REQUESTED&#x27;</span>);</span><br><span class="line">     <span class="keyword">yield</span> fork(fetchData);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>put(action)</strong></li></ul><p>put函数是用来发送action的 effect，你可以简单的把它理解成为redux框架中的dispatch函数，当put一个action后，reducer中就会计算新的state并返回，<strong>注意：</strong> put 也是阻塞 effect</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">toggleItemFlow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> list = []</span><br><span class="line"><span class="comment">// 发送一个type为 &#x27;UPDATE_DATA&#x27; 的Action，用来更新数据，参数为 `data：list`</span></span><br><span class="line"><span class="keyword">yield</span> put(&#123;</span><br><span class="line">      <span class="attr">type</span>: actionTypes.UPDATE_DATA,</span><br><span class="line">      <span class="attr">data</span>: list</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>call(fn, …args)</strong></li></ul><p>call函数你可以把它简单的理解为就是可以调用其他函数的函数，它命令 middleware 来调用fn 函数， args为函数的参数，<strong>注意：</strong>  fn 函数可以是一个 Generator 函数，也可以是一个返回 Promise 的普通函数，call 函数也是阻塞 effect</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> delay = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">removeItem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 这里call 函数就调用了 delay 函数，delay 函数为一个返回promise 的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> call(delay, <span class="number">500</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;<span class="attr">type</span>: actionTypes.ERROR&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>fork(fn, …args)</strong></li></ul><p>fork 函数和 call 函数很像，都是用来调用其他函数的，但是fork函数是非阻塞函数，也就是说，程序执行完 <code>yield fork(fn， args)</code> 这一行代码后，会立即接着执行下一行代码语句，而不会等待fn函数返回结果后，在执行下面的语句 (takeEvery就是利用take和fork实现的高级API)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fork &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 下面的四个 Generator 函数会一次执行，不会阻塞执行</span></span><br><span class="line">  <span class="keyword">yield</span> fork(addItemFlow)</span><br><span class="line">  <span class="keyword">yield</span> fork(removeItemFlow)</span><br><span class="line">  <span class="keyword">yield</span> fork(toggleItemFlow)</span><br><span class="line">  <span class="keyword">yield</span> fork(modifyItem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>select(selector, …args)</strong></li></ul><p>select 函数是用来指示 middleware调用提供的选择器获取Store上的state数据，你也可以简单的把它理解为redux框架中获取store上的 state数据一样的功能 ：<code>store.getState()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">toggleItemFlow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 通过 select effect 来获取 全局 state上的 `getTodoList` 中的 list</span></span><br><span class="line"> <span class="keyword">let</span> tempList = <span class="keyword">yield</span> select(<span class="function"><span class="params">state</span> =&gt;</span> state.getTodoList.list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>createSagaMiddleware()</strong></li></ul><p>createSagaMiddleware 函数是用来创建一个 Redux 中间件，将 Sagas 与 Redux Store 链接起来</p><p>sagas 中的每个函数都必须返回一个 Generator 对象，middleware 会迭代这个 Generator 并执行所有 yield 后的 Effect（Effect 可以看作是 redux-saga 的任务单元）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore, applyMiddleware&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-saga&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">import</span> rootSaga <span class="keyword">from</span> <span class="string">&#x27;./rootSaga&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个saga中间件</span></span><br><span class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducers,</span><br><span class="line">  将sagaMiddleware 中间件传入到 applyMiddleware 函数中</span><br><span class="line">  applyMiddleware(sagaMiddleware)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态执行saga，注意：run函数只能在store创建好之后调用</span></span><br><span class="line">sagaMiddleware.run(rootSaga)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果有多个中间件需要使用的话</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">const sagaMiddleware = createSagaMiddleware()</span></span><br><span class="line"><span class="comment">let middlewares = []</span></span><br><span class="line"><span class="comment">middlewares.push(sagaMiddleware)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">const createStoreWithMiddleware = applyMiddleware(...middlewares)(createStore)</span></span><br><span class="line"><span class="comment">const store = createStoreWithMiddleware(rootReducer)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sagaMiddleware.run(rootSaga)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">const action = type =&gt; store.dispatch(&#123; type &#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>大致就是这些吧，我们目前停留用轮子的阶段也别想着深入探讨原理了，react都还没玩明白呢TnT，会常用 API开发就行，等成为开发大佬后再去走源码看底层比较好吧。</p><h1 id="dvaJs"><a href="#dvaJs" class="headerlink" title="dvaJs"></a>dvaJs</h1><p>好嘞，了解了saga后，我们接下来就来看dvaJs，dva 首先是一个基于 <a href="https://github.com/reduxjs/redux">redux</a> 和 <a href="https://github.com/redux-saga/redux-saga">redux-saga</a> 的数据流方案，然后为了简化开发体验，dva 还额外内置了 <a href="https://github.com/ReactTraining/react-router">react-router</a> 和 <a href="https://github.com/github/fetch">fetch</a>，所以也可以理解为一个轻量级的应用框架。</p><ul><li><strong>易学易用</strong>，仅有 6 个 api，对 redux 用户尤其友好，<a href="https://umijs.org/guide/with-dva.html">配合 umi 使用</a>后更是降低为 0 API</li><li><strong>elm 概念</strong>，通过 reducers, effects 和 subscriptions 组织 model</li><li><strong>插件机制</strong>，比如 <a href="https://github.com/dvajs/dva/tree/master/packages/dva-loading">dva-loading</a> 可以自动处理 loading 状态，不用一遍遍地写 showLoading 和 hideLoading</li><li><strong>支持 HMR</strong>，基于 <a href="https://github.com/dvajs/babel-plugin-dva-hmr">babel-plugin-dva-hmr</a> 实现 components、routes 和 models 的 HMR</li></ul><p>翻了官网文档，好像dvaJS的思想其实就是多了一个model，把state/reducer/saga统一到了model中，然后用connect把model和page连接起来，而不是和react- redux一样直接连接store了。直接看代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">app.model(&#123;</span><br><span class="line">  <span class="attr">namespace</span>: <span class="string">&#x27;todos&#x27;</span>,  <span class="comment">// 表示全局state上的key</span></span><br><span class="line">  <span class="attr">state</span>: [], <span class="comment">//如果state是一个对象一定要注意state的扁平化 不要深层嵌套</span></span><br><span class="line">  <span class="attr">effects</span>: &#123; <span class="comment">// saga副作用执行异步操作</span></span><br><span class="line">    *<span class="function"><span class="title">addRemote</span>(<span class="params">&#123; payload: todo &#125;, &#123; put, call &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> call(addTodo, todo);</span><br><span class="line">      <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">&#x27;add&#x27;</span>, <span class="attr">payload</span>: todo &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">reducers</span>: &#123; <span class="comment">// 就是redux里面的reducers</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">state, &#123; payload: todo &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.concat(todo);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">remove</span>(<span class="params">state, &#123; payload: id &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id !== id);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">update</span>(<span class="params">state, &#123; payload: updatedTodo &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.map(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (todo.id === updatedTodo.id) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; ...todo, ...updatedTodo &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> todo;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="attr">subscriptions</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">setup</span>(<span class="params">&#123; dispatch, history &#125;</span>)</span> &#123;</span><br><span class="line">        history.listen(<span class="function">(<span class="params">&#123; pathname &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (pathname === <span class="string">&#x27;/users&#x27;</span>) &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">              <span class="attr">type</span>: <span class="string">&#x27;users/fetch&#x27;</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>subscriptions</code> 是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。格式为 <code>(&#123; dispatch, history &#125;) =&gt; unsubscribe</code> 。</p><p><img src="/2021/10/04/dvaJs/2.png" alt="w"></p><p>然后翻到一个贼清晰的博客介绍，就四张图，这里我就不放了，放链接<a href="https://yuque.com/flying.ni/the-tower/tvzasn">https://yuque.com/flying.ni/the-tower/tvzasn</a></p><p>基于此，应该对dvaJs有了个大概的了解吧，就是用了一个model(重装机甲嘛)把redux+saga同一联合，直接在一个model里面就能完成action的dispatch和reducer加工，不需要一个个什么./src/redux/action/todo.js啥的。</p><p>好嘞，接下来我们就看这篇博客的真正的主角——umiJs！！</p><p>。。为什么到现在才开始真正的主角，我觉得是不是有点长有点久了。。。</p><h1 id="UmiJs"><a href="#UmiJs" class="headerlink" title="UmiJs"></a>UmiJs</h1><p>那么那么那么，什么是umiJs呢</p><p>官方介绍Umi，中文可发音为乌米<strong>，是可扩展的企业级前端应用框架。Umi 以路由为基础的，同时支持配置式路由和约定式路由，保证路由的功能完备，并以此进行功能扩展。然后配以生命周期完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求。</strong></p><p>说白了就是大佬写的脚手架。</p><p>比如我们写react项目的时候，要干嘛？</p><p><code>yarn caeate-react-app</code></p><p>是吧，这就是官方提供给我们的一个基于react的脚手架，但这是官方提供哈，一般用于基本需求，那就有大佬不乐意咯，官方不行，官方一般，我自己写一个脚手架</p><p><code>yarn create @umijs/umi-app</code></p><p>所以，umiJs其实就是一个基于react的脚手架，官方文档也说了为什么不用前者</p><ul><li>create-react-app 是基于 webpack 的打包层方案，包含 build、dev、lint 等，他在打包层把体验做到了极致，但是不包含路由，不是框架，也不支持配置。所以，如果大家想基于他修改部分配置，或者希望在打包层之外也做技术收敛时，就会遇到困难。</li><li>然后我们看看umiJs收敛了哪些依赖</li></ul><p><img src="/2021/10/04/dvaJs/3.png" alt="umi"></p><p>！！离谱不离谱！！他连antd都直接装好了。</p><p>仔细一想umi作者好像是阿里的，antd也是阿里的，啊，那没事了。</p><p>然后嘞，咱们就看看这个新脚手架的项目结构吧</p><p><img src="/2021/10/04/dvaJs/4.png" alt="pj"></p><h2 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h2><ul><li>package.json</li></ul><p>包含插件和插件集，以 <code>@umijs/preset-</code>、<code>@umijs/plugin-</code>、<code>umi-preset-</code> 和 <code>umi-plugin-</code> 开头的依赖会被自动注册为插件或插件集。</p><ul><li>.umirc.ts</li></ul><p>配置文件，包含 umi 内置功能和插件的配置。如果项目的配置不复杂，推荐在 <code>.umirc.ts</code> 中写配置； 如果项目的配置比较复杂，可以将配置写在 <code>config/config.ts</code> 中，并把配置的一部分拆分出去，比如路由配置可以拆分成单独的 <code>routes.ts</code>：</p><ul><li>.env</li></ul><p>环境变量。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PORT=8888</span><br><span class="line">COMPRESS=none</span><br></pre></td></tr></table></figure><ul><li>dist 目录</li></ul><p>执行 <code>umi build</code> 后，产物默认会存放在这里。</p><ul><li>mock 目录</li></ul><p>存储 mock 文件，此目录下所有 js 和 ts 文件会被解析为 mock 文件。</p><ul><li>public 目录</li></ul><p>此目录下所有文件会被 copy 到输出路径。</p><ul><li><p><code>/src</code> 目录</p></li><li><p>.umi 目录</p></li></ul><p>临时文件目录，比如入口文件、路由等，都会被临时生成到这里。<strong>不要提交 .umi 目录到 git 仓库，他们会在 umi dev 和 umi build 时被删除并重新生成。</strong></p><ul><li>layouts/index.tsx</li></ul><p>约定式路由时的全局布局文件。</p><ul><li>pages 目录</li></ul><p>所有路由组件存放在这里。</p><ul><li>app.ts</li></ul><p>运行时配置文件，可以在这里扩展运行时的能力，比如修改路由、修改 render 方法等。</p><p>然后umi主要就靠插件和配置来完成你的各种依赖需求，状态管理的主要方式就还是dvaJS</p><h2 id="约定式路由"><a href="#约定式路由" class="headerlink" title="约定式路由"></a>约定式路由</h2><p>这里就是看看umiJs有哪些比较牛逼的点值得记一下，第一个就是约定式路由。不同于传统的配置式路由，都需要注册，umiJs要在.umirc.ts里写，react要通过route注册，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// umi中的配置路由</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">       <span class="attr">component</span>: <span class="string">&#x27;@/layouts/index&#x27;</span>,</span><br><span class="line">       <span class="attr">routes</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>: <span class="string">&#x27;@/pages/hero&#x27;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">path</span>: <span class="string">&#x27;/hero&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>: <span class="string">&#x27;@/pages/hero&#x27;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">path</span>: <span class="string">&#x27;/item&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>: <span class="string">&#x27;@/pages/item&#x27;</span></span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="attr">path</span>: <span class="string">&#x27;/summoner&#x27;</span>,</span><br><span class="line">           <span class="attr">component</span>: <span class="string">&#x27;@/pages/summoner&#x27;</span></span><br><span class="line">         &#125;,</span><br><span class="line">       ]</span><br><span class="line">     &#125;,</span><br><span class="line">   ],</span><br><span class="line"><span class="comment">// 小幸运里面的配置路由</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/login&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Login&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/home&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/send&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Send&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/detail&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Detail&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/wish/:tag&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Wishes&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/mywish&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;MyWish&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&#x27;/login&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">Redirect</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>哎，那什么是约定路由呢<a href="https://umijs.org/zh-CN/docs/convention-routing">https://umijs.org/zh-CN/docs/convention-routing</a></p><p>官方介绍是：约定式路由也叫文件路由，就是不需要手写配置，文件系统即路由，通过目录和文件及其命名分析出路由配置。</p><p>这个很牛逼，不需要手写配置给你自动生成，但感觉不太好管理和debug</p><p>然后还有一些很牛的地方就是umiJs的插件集，之前也说了umiJs是靠插件集来对应解决相应组件，这部分有点杂，配置文件是最难看也是最难理解的，等以后牛逼了再说吧，明日复明日了哎。</p><p>所以我们就先拿umi框架搭写一个简单的王者荣耀官网！</p><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>就命令行就完事了呗 这里不贴了。真想写官网去看配置！（暴躁 卧槽我写了好几天了我受不了了卧槽我在干什么！！！）</p><p>然后初始化好了后基本的目录结构就是上面的图嘛，这咱就不管了，完整项目的umiJs框架大家可以去看菁程的代码哈，我这里就是简单介绍一下。</p><p>基本结构出来后，我们想一想我们要干嘛，懂不懂前端架构的含金量？</p><p>状态管理要用dva,组件模式用antd</p><p>于是乎我们来到.umirc.ts下，写上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">dva</span>: &#123; <span class="attr">immer</span>: <span class="literal">true</span>, <span class="attr">hmr</span>: <span class="literal">false</span>, &#125;,</span><br><span class="line">  <span class="attr">antd</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">nodeModulesTransform</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>哎，这样就可以用dva和antd了！</p><p>好，继续，就假设我们是很牛逼的前端架构师，我们制定了要用的技术栈和布局规范，手底下的开发人员要干嘛？先把大致的布局写出来是吧。</p><p>哎这就有了src/layouts/index.tsx</p><p>注意 我们采用的是约定式路由 这就会让我们的路由变成 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Layouts&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Route</span>/&gt;</span></span> <span class="comment">// 这部分都是 src/pages下的文件</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span>/&gt;</span></span></span><br><span class="line">&lt;/Layouts&gt;</span><br><span class="line"><span class="comment">// path=&#x27;/&#x27; 对应的是src/idnex.tsx文件页面</span></span><br></pre></td></tr></table></figure><p>也就是在外面包了一层</p><p>然后直接利用antd给的Layouts开始布局页面嘛 代码如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Layout, Menu &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./index.less&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; Header, Content, Footer &#125; = Layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> menuData = [</span><br><span class="line">  &#123; <span class="attr">route</span>: <span class="string">&#x27;/hero&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;英雄&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">route</span>: <span class="string">&#x27;/item&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;局内道具&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">route</span>: <span class="string">&#x27;/summoner&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;召唤师技能&#x27;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BasicLayout</span>(<span class="params">props: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">location</span>: &#123; pathname &#125;,</span><br><span class="line">    children,</span><br><span class="line">  &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Layout</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Header</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.logo&#125;</span>&gt;</span>王者荣耀资料库 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Menu</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">theme</span>=<span class="string">&quot;dark&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">mode</span>=<span class="string">&quot;horizontal&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">defaultSelectedKeys</span>=<span class="string">&#123;[pathname]&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">lineHeight:</span> &#x27;<span class="attr">64px</span>&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">          &gt;</span></span></span><br><span class="line"><span class="xml">            &#123;menuData.map(menu =&gt; (</span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>= <span class="string">&#123;</span>`/$&#123;<span class="attr">menu.route</span>&#125;`&#125;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;menu.route&#125;</span>&gt;</span>&#123;menu.name&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line"><span class="xml">            ))&#125;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Content</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">padding:</span> &#x27;<span class="attr">0</span> <span class="attr">50px</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">background:</span> &#x27;#<span class="attr">fff</span>&#x27;, <span class="attr">padding:</span> <span class="attr">24</span>, <span class="attr">minHeight:</span> <span class="attr">280</span> &#125;&#125;&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Footer</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textAlign:</span> &#x27;<span class="attr">center</span>&#x27; &#125;&#125;&gt;</span>今天是乐爷开始学umi的第一天<span class="tag">&lt;/<span class="name">Footer</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BasicLayout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*props默认传的是 </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  match?: match&lt;P&gt;;</span></span><br><span class="line"><span class="comment">  location: Location&lt;S&gt;;</span></span><br><span class="line"><span class="comment">  history: History;</span></span><br><span class="line"><span class="comment">  route: IRoute;</span></span><br><span class="line"><span class="comment">&#125; 以及React封装好的泛型Props 比如children 这里我懒得定义Interface了，还有记住最好用箭头函数写哈，function太丑*/</span></span><br></pre></td></tr></table></figure><p>然后基本的布局页面我们就弄好咯，静态结束后要干嘛，哎，搞数据，搞活的</p><p>dva这是就来咯，记住什么是dva，重机甲，放到代码里面呢？model对象，So，我们就搞一个models文件夹，里面就放这些model对象就好了。(菁程里面好像是把model和需要这个model的页面放在了一个文件夹里面，我也不知道哪种方式牛逼一点)</p><p>因为我们就看一个hero页面嘛，就直接上src/models/hero.tsx的代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Effect, Reducer, Subscription, request &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HeroProps &#123;</span><br><span class="line">  <span class="attr">ename</span>: <span class="built_in">number</span>;</span><br><span class="line">  cname: <span class="built_in">string</span>;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  new_type: <span class="built_in">number</span>;</span><br><span class="line">  hero_type: <span class="built_in">number</span>;</span><br><span class="line">  skin_name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HeroModelState &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  heros: HeroProps[];</span><br><span class="line">  freeheros: HeroProps[];</span><br><span class="line">  filterKey: <span class="built_in">number</span>;</span><br><span class="line">  itemHover: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> HeroModelType &#123;</span><br><span class="line">  <span class="attr">namespace</span>: <span class="string">&#x27;hero&#x27;</span>;</span><br><span class="line">  state: HeroModelState;</span><br><span class="line">  effects: &#123;</span><br><span class="line">    <span class="attr">query</span>: Effect;</span><br><span class="line">    fetch: Effect;</span><br><span class="line">  &#125;;</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    <span class="attr">save</span>: Reducer&lt;HeroModelState&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">  subscriptions: &#123; <span class="attr">setup</span>: Subscription &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HeroModel: HeroModelType = &#123;</span><br><span class="line">  <span class="attr">namespace</span>: <span class="string">&#x27;hero&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;hero&#x27;</span>,</span><br><span class="line">    <span class="attr">heros</span>: [],</span><br><span class="line">    <span class="attr">freeheros</span>: [],</span><br><span class="line">    <span class="attr">filterKey</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">itemHover</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">effects</span>: &#123;</span><br><span class="line">    *<span class="function"><span class="title">fetch</span>(<span class="params">&#123; <span class="keyword">type</span>, payload &#125;, &#123; put, call, select &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">yield</span> request(<span class="string">&#x27;/web201605/js/herolist.json&#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> freeheros = <span class="keyword">yield</span> request(<span class="string">&#x27;mock/freeheros.json&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">          <span class="attr">Accept</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json; charset=utf-8&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">          <span class="attr">number</span>: <span class="number">10</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> localData = [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">ename</span>: <span class="number">105</span>,</span><br><span class="line">          <span class="attr">cname</span>: <span class="string">&#x27;廉颇&#x27;</span>,</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;正义爆轰&#x27;</span>,</span><br><span class="line">          <span class="attr">new_type</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">hero_type</span>: <span class="number">3</span>,</span><br><span class="line">          <span class="attr">skin_name</span>: <span class="string">&#x27;正义爆轰|地狱岩魂&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">ename</span>: <span class="number">106</span>,</span><br><span class="line">          <span class="attr">cname</span>: <span class="string">&#x27;小乔&#x27;</span>,</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;恋之微风&#x27;</span>,</span><br><span class="line">          <span class="attr">new_type</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">hero_type</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">skin_name</span>: <span class="string">&#x27;恋之微风|万圣前夜|天鹅之梦|纯白花嫁|缤纷独角兽&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ];</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;save&#x27;</span>,</span><br><span class="line">        <span class="attr">payload</span>: &#123;</span><br><span class="line">          <span class="attr">heros</span>: data || localData,</span><br><span class="line">          freeheros</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    *<span class="function"><span class="title">query</span>(<span class="params">&#123; payload &#125;, &#123; call, put &#125;</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">save</span>(<span class="params">state, action</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        ...action.payload,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">subscriptions</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params">&#123; dispatch, history &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> history.listen(<span class="function">(<span class="params">&#123; pathname &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pathname === <span class="string">&#x27;/hero&#x27;</span>) &#123;</span><br><span class="line">          dispatch(&#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;fetch&#x27;</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HeroModel;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这应该都可以看懂吧大家 不懂我现场讲 我写不动了 真的写不动了 知识产出太累了 更何况我还没有知识</p><p>这里我们插一嘴，可以看到网络请求直接调用了request这个方法，哎，想想看他是手写的封装fetch还是很pont一样牛逼直接根据后端给的json直接生成？哈哈哈我也不知道 我只知道要在app.ts那里配置一句话就好了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ResponseError &#125; <span class="keyword">from</span> <span class="string">&#x27;umi-request&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> request = &#123;</span><br><span class="line">  <span class="attr">prefix</span>: <span class="string">&#x27;/api&#x27;</span>,</span><br><span class="line">  <span class="attr">errorHandler</span>: <span class="function">(<span class="params">error: ResponseError</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 集中处理错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🤔 这也就是给所有的请求加了一个前缀和错误处理吗，request的底层。。。再说吧再说吧</p><p>接下来还要注意一点，就是在没有mock本地测试数据的话，一般都会产生跨域问题<a href="https://juejin.cn/post/6844903882083024910%E8%AF%A6%E7%BB%86%E7%9A%84%E7%9C%8B%E8%BF%99%E4%B8%AA%E5%93%88">https://juejin.cn/post/6844903882083024910详细的看这个哈</a> 我反正没看完</p><p>然后react里有两种解决的跨域方案，简单点的就是写个在packag.json写proxy属性，缺点就是只能访问单一地址，复杂点的就是自己在src下写setupProxy中间件(用node的语法，什么moudle.export），然后umi自然也是有方法解决跨域的啦</p><p><img src="/2021/10/04/dvaJs/proxy.jpg" alt="proxy"></p><p>还是去我们的./.umirc.js</p><p>然后</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;proxy&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;/api/&quot;</span>: &#123; <span class="comment">//设置代理请求头，当访问到/api时就会触发代理</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;https://pvp.qq.com/&quot;</span>, <span class="comment">//代理访问的真实服务器地址</span></span><br><span class="line">    <span class="attr">&quot;changeOrigin&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否跨域请求地址</span></span><br><span class="line">    <span class="attr">&quot;pathRewrite&quot;</span>: &#123; <span class="attr">&quot;^/api&quot;</span>: <span class="string">&quot;&quot;</span> &#125; <span class="comment">// 是否重写请求地址，比如这里就是吧/api替换成空字符串</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便一提 <strong>代理只是请求服务代理，不是请求地址</strong></p><p>我们打开控制台，可以看到我们的请求地址是 <code>http://localhost:8000/api/web201605/js/herolist.json</code> ,响应200，并返回了真实数据。</p><p>你不会在浏览器的控制台中查看到我们真实代理的地址，这里需要注意，代理只是将请求服务做了中转，设置proxy不会修改请求地址。</p><p>弄了请求 弄了布局 就开始英雄列表页嗷</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect, HeroModelState, ConnectProps &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Row, Col, Radio, Card &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RadioChangeEvent &#125; <span class="keyword">from</span> <span class="string">&#x27;antd/es/radio/interface&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> FreeHeroItem <span class="keyword">from</span> <span class="string">&#x27;@/components/FreeHeroItem&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&#x27;./hero.less&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RadioGroup = Radio.Group;</span><br><span class="line"></span><br><span class="line">interface PageProps <span class="keyword">extends</span> ConnectProps &#123;</span><br><span class="line">  <span class="attr">hero</span>: HeroModelState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heroType = [</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">0</span>, <span class="attr">value</span>: <span class="string">&#x27;全部&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="string">&#x27;战士&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">2</span>, <span class="attr">value</span>: <span class="string">&#x27;法师&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">3</span>, <span class="attr">value</span>: <span class="string">&#x27;坦克&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">4</span>, <span class="attr">value</span>: <span class="string">&#x27;刺客&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">5</span>, <span class="attr">value</span>: <span class="string">&#x27;射手&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">6</span>, <span class="attr">value</span>: <span class="string">&#x27;辅助&#x27;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Hero: FC&lt;PageProps&gt; = <span class="function">(<span class="params">&#123; hero, dispatch &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; heros = [], filterKey = <span class="number">0</span>, freeheros = [], itemHover = <span class="number">0</span> &#125; = hero;</span><br><span class="line">  <span class="built_in">console</span>.log(freeheros)</span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e: RadioChangeEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch!(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;hero/save&quot;</span>, <span class="attr">payload</span>: &#123;</span><br><span class="line">        <span class="attr">filterKey</span>: e.target.value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onItemHover = <span class="function">(<span class="params">index: number</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch!(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;hero/save&#x27;</span>,</span><br><span class="line">      <span class="attr">payload</span>: &#123;</span><br><span class="line">        <span class="attr">itemHover</span>: index</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.normal&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.info&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Row</span> <span class="attr">className</span>=<span class="string">&#123;styles.freehero&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Col</span> <span class="attr">span</span>=<span class="string">&#123;24&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>周免英雄<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">              &#123;</span></span><br><span class="line"><span class="xml">                freeheros.map((data, index) =&gt; (</span></span><br><span class="line"><span class="xml">                  <span class="tag">&lt;<span class="name">FreeHeroItem</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">data</span>=<span class="string">&#123;data&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">itemHover</span>=<span class="string">&#123;itemHover&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">onItemHover</span>=<span class="string">&#123;onItemHover&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">thisIndex</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    <span class="attr">key</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                  /&gt;</span></span></span><br><span class="line"><span class="xml">                ))</span></span><br><span class="line"><span class="xml">              &#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Col</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Card</span> <span class="attr">className</span>=<span class="string">&#123;styles.radioPanel&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">RadioGroup</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> <span class="attr">value</span>=<span class="string">&#123;filterKey&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;heroType.map(data =&gt; (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Radio</span> <span class="attr">value</span>=<span class="string">&#123;data.key&#125;</span> <span class="attr">key</span>=<span class="string">&#123;</span>`<span class="attr">hero-rodio-</span>$&#123;<span class="attr">data.key</span>&#125;`&#125;&gt;</span></span></span><br><span class="line"><span class="xml">              &#123;data.value&#125;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Radio</span>&gt;</span></span></span><br><span class="line"><span class="xml">          ))&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;heros.filter(item =&gt; filterKey === 0 || item.hero_type === filterKey).reverse().map(item =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Col</span> <span class="attr">key</span>=<span class="string">&#123;item.ename&#125;</span> <span class="attr">span</span>=<span class="string">&#123;3&#125;</span> <span class="attr">className</span>=<span class="string">&#123;styles.heroitem&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;</span>`<span class="attr">https:</span>//<span class="attr">game.gtimg.cn</span>/<span class="attr">images</span>/<span class="attr">yxzj</span>/<span class="attr">img201606</span>/<span class="attr">heroimg</span>/$&#123;<span class="attr">item.ename</span>&#125;/$&#123;<span class="attr">item.ename</span>&#125;<span class="attr">.jpg</span>`&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;item.cname&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Col</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="function">(<span class="params">&#123; hero &#125;: &#123; hero: HeroModelState &#125;</span>) =&gt;</span> (&#123; hero &#125;))(Hero);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好嘞 效果就这样 </p><p>我还是彩笔写了这么多都没讲明白自己也没学明白呜呜呜</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一篇关于Umijs的学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>动画与Canvas图形</title>
    <link href="http://example.com/2021/09/26/%E5%8A%A8%E7%94%BB%E4%B8%8ECanvas%E5%9B%BE%E5%BD%A2/"/>
    <id>http://example.com/2021/09/26/%E5%8A%A8%E7%94%BB%E4%B8%8ECanvas%E5%9B%BE%E5%BD%A2/</id>
    <published>2021-09-26T14:47:12.000Z</published>
    <updated>2021-10-02T04:19:24.360Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客记录下红宝书上的canvas和动画</p><span id="more"></span><h1 id="Js动画"><a href="#Js动画" class="headerlink" title="Js动画"></a>Js动画</h1><p>早起的Js动画只能用定时器写，结合css的animation和transition来完成，但定时器在浏览器的时间精度是个问题，就会造成动画不流畅，延时等问题，所以这里就有新的API来解决这个问题</p><h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><p>requesetAnimationFrame()，该接口的参数是一个函数(就是用于执行动画的函数)，该接口的作用就是通知浏览器“我要放一个动画你麻溜的准备好”，然后调用参数函数来精确的完成动画。然后参数函数是一个要在重绘屏幕前调用的函数，这个函数就是修改DOM样式以及反映下一次重绘有什么变化的地方。为了实现动画循环，可以再该函数内部再次调用requesetAnimationFrame()。<br>至此，该API解决了浏览器不知道Js何时开始动画的问题，然后在调用requesetAnimationFrame()时还给执行动画的函数传递一个DOMHighResTimeStamp函数，就是一个时间戳，表示下次重绘的时间，这一点非常重要，requesetAnimationFrame()把重绘任务安排再了未来一个已知的时间点上，而且通过这个参数告诉了开发者。</p><p>然后requesetAnimationFrame()的返回值和setTimeout()类似，返回一个请求ID，通过cancelAnimationFrame()来取消重绘任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updateProgress = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;status&quot;</span>);</span><br><span class="line">  div.style.width = (<span class="built_in">parseInt</span>(div.style.width, <span class="number">10</span>) + <span class="number">5</span>) + <span class="string">&#x27;%&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (div.style.left != <span class="string">&quot;100%&quot;</span>) &#123;</span><br><span class="line">    requesetAnimationFrame(updateProgress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">requesetAnimationFrame(updateProgress) </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> id = requesetAnimationFrame(updateProgress) </span><br><span class="line"></span><br><span class="line">cancelAnimationFrame(id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在使用requesetAnimationFrame()要注意节流的使用</strong></p><h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><p>canvas是html的标签元素，写它的时候要声明id,width和height</p><h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><ul><li>getContext() 获取绘图上下文，比如传参’2d’，就表示要获取2D上下文对象</li><li>toDataURL() 导出canvas元素上的图像</li></ul><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p>对于2d上下文对象，会建一个坐标系，然后根据坐标来绘图<br>坐标原点在canvas元素的左上角，然后width和height就限定了坐标的最大值，2d绘图有两个基本操作，填充和描边</p><ul><li>strokeStyle() 用于描边</li><li>fillStyle() 用于填充<br>绘制矩形的API，都接受四个参数，分别是起始x,y坐标和宽度高度</li><li>fillRect() 填充矩形</li><li>strokeRect() 绘制矩形边框</li><li>clearRect() 擦除指定区域</li></ul><h3 id="绘制路径的API"><a href="#绘制路径的API" class="headerlink" title="绘制路径的API"></a>绘制路径的API</h3><ul><li>beginPath() 表示开始绘制路径</li><li>closePath() 表示关闭绘制路径 图形绘制命令又重新指向到上下文中</li><li>stroke() 通过线条来绘制图形轮廓</li><li>fill() 通过填充路径的内容区域生成实心的图形<br>意思就是 创建路径之后，可以用closePath()方法绘制一条返回起点的线，如果路径已经完成，就可以用fill()或者stroke()方法来描画路径，还可以调用clip()方法基于已有路径创建一个新剪切区域。</li><li>arc() 绘制弧线，参数啥的去MDN查吧，</li><li>arcTo() </li><li>bezierCurveTo() 三次贝塞尔曲线</li><li>quadraticCurveTo() 二次贝塞尔曲线</li><li>rect() 绘制矩形 与前面的矩形相关API的区别是绘制路径和绘制图形</li><li><strong>lineTo(x,y)</strong> 绘制一条从上一点到(x,y)的直线</li><li><strong>moveTo(x,y)</strong> 不绘制线条，只把绘制光标移动到(x,y)<br>还有个isPointInPath(x,y)方法帮我们判断目前路径是否在某点(x,y)上</li></ul><h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><p>绘制文本的方法，都接受四个参数,要绘制的字符串，x坐标，y坐标，和可选的最大像素宽度。</p><ul><li>fillText()</li><li>strokeText()</li></ul><p>这两个方法最终绘制都取决于以下属性</p><ul><li>font: css语法指定的字体样式</li><li>textAlign: 指定文本对齐方式</li><li>textBaseLine: 指定文本的基线</li></ul><p>用measureText()获得文本的宽度</p><h3 id="变换、"><a href="#变换、" class="headerlink" title="变换、"></a>变换、</h3><p>。。。<br>写不下去了<br>太多API了赣</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇博客记录下红宝书上的canvas和动画&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Cookie/Session/Token/localStorage</title>
    <link href="http://example.com/2021/09/24/Cookie-Session-Token-localStorage/"/>
    <id>http://example.com/2021/09/24/Cookie-Session-Token-localStorage/</id>
    <published>2021-09-24T11:12:02.000Z</published>
    <updated>2021-09-25T13:47:24.592Z</updated>
    
    <content type="html"><![CDATA[<p>目前对于和http相关的东西了解不算多，认知还比较浅，就来写一篇博客对cookie这些东西简单的了解一下</p><span id="more"></span><h1 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="什么是Cookie"></a>什么是Cookie</h1><p>什么是cookie？</p><ol><li>Cookie是浏览器访问服务器后，服务器传给浏览器的数据</li><li>浏览器需要保存这段数据，不能轻易删除</li><li>以后每次浏览器都要访问该服务器，都需要带上刚数据</li></ol><h2 id="如何使用Cookie"><a href="#如何使用Cookie" class="headerlink" title="如何使用Cookie"></a>如何使用Cookie</h2><p>cookie一般有两个作用</p><ol><li>识别用户身份<br>如果用户A用浏览器访问了服务器a.com,a.com的服务器就会立刻给A返回一段数据“uid = 1”(可以理解为这就是cookie)。当A再次访问a.com的其他页面时，就会附带上”uid = 1”的数据。<br>同理，用户B再次访问服务器a.com,然后a.com发现用户B没有附带uid数据，就给B分配了一个新的uid,为2，然后给B返回一段数据”uid = 2”,B之后再次访问a.com的时候就会一直带上“uid = 2”这段数据，借此a.com就能就能区分A和B两个用户了。</li><li>记录历史<br>假设 <a href="http://a.com/">http://a.com</a> 是一个购物网站，当 A 在上面将商品 A1 、A2 加入购物车时，JS 可以改写 Cookie，改为「uid=1; cart=A1,A2」，表示购物车里有 A1 和 A2 两样商品了。<br>这样一来，当用户关闭网页，过三天再打开网页的时候，依然可以看到 A1、A2 躺在购物车里，因为浏览器并不会无缘无故地删除这个 Cookie。<br>借此，就达到里记录用户操作历史的目的了。<br>（上面的例子只是为了让大家了解 Cookie 的作用而构想出来的，实际的网站使用 Cookie 时会更谨慎一些。）</li></ol><h2 id="cookie和localstorage-sessionStorge"><a href="#cookie和localstorage-sessionStorge" class="headerlink" title="cookie和localstorage,sessionStorge"></a>cookie和localstorage,sessionStorge</h2><p><img src="/2021/09/24/Cookie-Session-Token-localStorage/cookie.png" alt="cookie"></p><h3 id="场景考虑"><a href="#场景考虑" class="headerlink" title="场景考虑"></a>场景考虑</h3><p>因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 当然是能精简就精简啦，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假了~</p><p>而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。</p><p>需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。</p><h2 id="cookie和session，token"><a href="#cookie和session，token" class="headerlink" title="cookie和session，token"></a>cookie和session，token</h2><p><img src="/2021/09/24/Cookie-Session-Token-localStorage/1515111-20200405090920745-1422513552.png" alt="1"></p><h3 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie/session"></a>cookie/session</h3><p>HTTP 协议是一种无状态协议，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。</p><p>Session 是什么<br>客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个对象便是 Session 对象，存储结构为 ConcurrentHashMap。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。</p><p>Session 如何判断是否是同一会话<br>服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 **Set-Cookie：JSESSIONID=XXXXXXX **命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 **JSESSIONID=XXXXXXX **的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束<br><img src="/2021/09/24/Cookie-Session-Token-localStorage/2.png" alt="2"><br>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。</p><p>Session 的缺点<br>Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p><p>而HTTP 协议中的 Cookie 包括 Web Cookie 和浏览器 Cookie，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。</p><p>也就是说<br>由于http的无状态性，为了使某个域名下的所有网页能够共享某些数据，session和cookie出现了。客户端访问服务器的流程如下</p><ol><li>首先，客户端会发送一个http请求到服务器端。</li><li>服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看Cookie详解 Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]</li><li>在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie</li><li>服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端<br><img src="/2021/09/24/Cookie-Session-Token-localStorage/3.png" alt="3"></li></ol><p><strong>注意</strong><br>cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中<br>现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用<br>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用cookie，数据量大的时候客户端是没有那么多空间的。<br>如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大<br>简而言之, session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证</p><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>token 也称作令牌，由uid+time+sign[+固定参数]<br>token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。<br>组成</p><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p><p>token 的认证流程与cookie很相似</p><ul><li>用户登录，成功后服务器返回Token给客户端。</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将token放入headers中</li><li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li></ul><p><strong>token可以抵抗csrf，cookie+session不行</strong><br>假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为<a href="http://www.bank.com/api/transfer%EF%BC%8Cbody%E4%B8%BAcount=1000&amp;to=Tom%E3%80%82%E5%80%98%E8%8B%A5%E6%98%AFsession+cookie%EF%BC%8C%E7%94%A8%E6%88%B7%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E5%B7%B2%E7%BB%8F%E8%BD%AC%E7%BB%99Tom1000%E5%85%83%E4%BA%86.%E5%9B%A0%E4%B8%BAform">http://www.bank.com/api/transfer，body为count=1000&amp;to=Tom。倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了.因为form</a> 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但token不同，token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p><p>分布式情况下的session和token<br>我们已经知道session时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，session就会面对负载均衡问题。</p><ul><li>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享session。这个问题也可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。当今的几种解决session负载均衡的方法。</li></ul><p>而token是无状态的，token字符串里就保存了所有的用户信息</p><ul><li>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做JWT(Json Web Token)<br>关于JWT可以看 （<a href="https://www.cnblogs.com/cxuanBlog/p/12635842.html%EF%BC%89">https://www.cnblogs.com/cxuanBlog/p/12635842.html）</a></li></ul><p>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie<br>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。<br>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。<br>jwt只是一个跨域认证的方案</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前对于和http相关的东西了解不算多，认知还比较浅，就来写一篇博客对cookie这些东西简单的了解一下&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="网络知识" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Flux与Redux</title>
    <link href="http://example.com/2021/09/19/Flux%E4%B8%8ERedux/"/>
    <id>http://example.com/2021/09/19/Flux%E4%B8%8ERedux/</id>
    <published>2021-09-19T02:53:05.000Z</published>
    <updated>2021-09-21T12:55:09.076Z</updated>
    
    <content type="html"><![CDATA[<p>基于React的比较重要的思想和库，这里也简单的写个博客记录一下学习过程</p><span id="more"></span><p>Flux架构说到底就是一种思想，就比如说我们写一个组件的时候，就很容易在一个组件内又写请求数据的函数又把这些数据展示出来，就会让一个组件显得很长很长，但其实业务逻辑不需要关心数据从哪里来，只需要定义好传入的接口就行了，数据应该抽象到其他地方去做，比如把数据抽象到父组件中去。这样就完成了数据请求和业务逻辑的分开。我们称只有数据请求的组件叫<strong>容器型组件</strong>，而只有业务逻辑没有数据请求的组件叫<strong>展示型组件</strong>。这样抽象后的代码是具有更多的可读性和可维护性，但是！！！！这不是最佳的办法，因为请求数据这部分还是写在了组件当中，数据与逻辑解耦才是我们真正想要的！这是，Flux架构就来了。</p><h1 id="Flux架构"><a href="#Flux架构" class="headerlink" title="Flux架构"></a>Flux架构</h1><p>Flux可以说是MVC模式的一种变体，更为清晰和简单，对于MVC可以自行搜索了解。Flux的核心思想就是<strong>数据和逻辑永久单向流动</strong>我们看一下他的流程图<br><img src="/2021/09/19/Flux%E4%B8%8ERedux/flux.png" alt="flux"><br>详细点就是<br><img src="/2021/09/19/Flux%E4%B8%8ERedux/flux2.png" alt="flux"><br>简单的用语言说就是：</p><ol><li>用户访问 View</li><li>View 发出用户的 Action</li><li>Dispatcher 收到 Action，要求 Store 进行相应的更新</li><li>Store 更新后，发出一个”change”事件</li><li>View 收到”change”事件后，更新页面</li></ol><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>简单的了解了Flux后，我们就看看Redux，Redux就是基于Flux架构实现的一个react库，用于集中式管理状态，我们先看看他的原理图<br><img src="/2021/09/19/Flux%E4%B8%8ERedux/redux.png" alt="redux"></p><ul><li>这个原理图就是，比如我们在UI界面端点击了一个按钮，要把这个按钮从白色变成红色，在我们点击后会触发点击时间，调用了store.dispath()方法把一个action传给store，然后store就会再帮我们调用reducer函数。reducer是个纯函数，他会根据action修改相应的状态并返回给store，然后store更新状态，我们button的颜色就会相应更改了(store.getState())</li></ul><p>我们用形象点的语言来解释一下</p><ul><li>我们是顾客，去一个饭店吃饭，ReactComponents就是菜单，是我们能看到的UI图，然后我们点菜，就会告诉店小二我们要吃啥，这个店小二就是ActionCreators，店小二就会拿着我们的想要的食物(action)去告诉(dispatch)老板，老板就是store，然后老板再把这个消息告诉后厨(Reducers)，后厨知道我们要吃啥了，就刷刷刷加工给我们上食材(返回新状态)。</li></ul><p>重点API</p><ol><li>store.getState() 获取状态</li><li>store.dispatch() 更改状态</li><li>store.subscribe() 监听状态的改变</li></ol><p><strong>注意中间件的使用！并且中间件一般是是在dispatch里生效的</strong></p><h1 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h1><p>就是 Facebook团队基于redux的影响出了一个可以更好的使用redux的一个库。<br>重点有如下API</p><ul><li>connect()</li><li>&lt;Provider/&gt;组件</li></ul><p>先看看react-redux的模型图<br><img src="/2021/09/19/Flux%E4%B8%8ERedux/react-redux.png" alt="react-redux"><br>react-redux中把一个组件拆开，分成UI组件和容器组件(更贴合于Flux架构)，然后UI组件不接受任何业务逻辑，就类似与纯函数，他就像一个“纯组件”，只通过接受过来的props参数来改变渲染结果，然后Count组件就负责承担业务逻辑和与redux沟通，并把store中的state以及更改state的方法(dispatch)分发给UI组件，而connect()方法就是起这个作用的。</p><h2 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h2><p><code>const Container = connect(mapStateToProp,mapDispatchToProps)(UI)</code><br>这样Container就是一个被加工的容器组件，这传代码的意思是，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。<br>从本质上说connect可以看作是一个高阶函数</p><p>mapStateToProps</p><ol><li>mapStateToProps函数返回的是一个对象；</li><li>返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value</li><li>mapStateToProps用于传递状态</li></ol><p>mapDispatchToProps</p><ol><li>mapDispatchToProps函数返回的是一个对象；</li><li>返回的对象中的key就作为传递给UI组件props的key,value就作为传递给UI组件props的value</li><li>mapDispatchToProps用于传递操作状态的方法</li></ol><h2 id="lt-Provider-gt"><a href="#lt-Provider-gt" class="headerlink" title="&lt;Provider/&gt;"></a>&lt;Provider/&gt;</h2><p>Provider组件就是基于react中的Context实现的，connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。这里用Provider就可以直接让容器组件拿到了。具体源码实现这里就不放了。</p><h1 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h1><p>就看看redux在生产环境中是如何使用的吧,我们做出这样一个效果<br><img src="/2021/09/19/Flux%E4%B8%8ERedux/ui.png" alt="ui"><br>上方Count组件可以拿到下方Person组件的人数，然后Person组件也可以取到上方Count组件的求和数，先看项目文件<br><img src="/2021/09/19/Flux%E4%B8%8ERedux/code.png" alt="code"></p><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>除了redux文件夹里面的东西要讲一讲外其他的都没啥必要了。那就按顺序，我们分析需求，要用到redux，就先把这些文件夹建起来，该装的依赖装好，然后分需求，看看有什么，Count组件要计算， Person组件要添加人数，然后根据这些需求去写action</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constant.js 文件</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">该模块是用于定义action对象中type类型的常量值，目的只有一个：便于管理的同时防止程序员单词写错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">&#x27;increment&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT = <span class="string">&#x27;decrement&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_PERSON = <span class="string">&#x27;add_person&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">该文件专门为Count组件生成action对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT,DECREMENT&#125; <span class="keyword">from</span> <span class="string">&#x27;../constant&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同步action，就是指action的值为Object类型的一般对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;<span class="attr">type</span>:INCREMENT,data&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;<span class="attr">type</span>:DECREMENT,data&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步action，就是指action的值为函数,异步action中一般都会调用同步action，异步action不是必须要用的。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> incrementAsync = <span class="function">(<span class="params">data,time</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">dispatch(increment(data))</span><br><span class="line">&#125;,time)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Person组件生成action对象</span></span><br><span class="line"><span class="keyword">import</span> &#123; ADD_PERSON &#125; <span class="keyword">from</span> <span class="string">&quot;../constant&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addPerson = <span class="function"><span class="params">personObj</span> =&gt;</span> (&#123;<span class="attr">type</span>:ADD_PERSON,<span class="attr">data</span>:personObj&#125;)</span><br></pre></td></tr></table></figure><p>然后就根据action写reducer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1.该文件是用于创建一个为Count组件服务的reducer，reducer的本质就是一个函数</span></span><br><span class="line"><span class="comment">2.reducer函数会接到两个参数，分别为：之前的状态(preState)，动作对象(action)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initState = <span class="number">0</span> <span class="comment">//初始化状态</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">countReducer</span>(<span class="params">preState=initState,action</span>)</span>&#123;</span><br><span class="line"><span class="comment">//从action对象中获取：type、data</span></span><br><span class="line"><span class="keyword">const</span> &#123;type,data&#125; = action</span><br><span class="line"><span class="comment">//根据type决定如何加工数据</span></span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>: <span class="comment">//如果是加</span></span><br><span class="line"><span class="keyword">return</span> preState + data</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>: <span class="comment">//若果是减</span></span><br><span class="line"><span class="keyword">return</span> preState - data</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line"><span class="keyword">return</span> preState</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person</span></span><br><span class="line"><span class="keyword">import</span> &#123;ADD_PERSON&#125; <span class="keyword">from</span> <span class="string">&#x27;../constant&#x27;</span></span><br><span class="line"><span class="comment">//初始化人的列表</span></span><br><span class="line"><span class="keyword">const</span> initState = [&#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">personReducer</span>(<span class="params">preState=initState,action</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123;type,data&#125; = action</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> ADD_PERSON: <span class="comment">//若是添加一个人</span></span><br><span class="line"><span class="keyword">return</span> [data,...preState]</span><br><span class="line"><span class="attr">default</span>:</span><br><span class="line"><span class="keyword">return</span> preState</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后联合reducer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">该文件用于汇总所有的reducer为一个总的reducer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//引入combineReducers，用于汇总多个reducer</span></span><br><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="comment">//引入为Count组件服务的reducer</span></span><br><span class="line"><span class="keyword">import</span> count <span class="keyword">from</span> <span class="string">&#x27;./count&#x27;</span></span><br><span class="line"><span class="comment">//引入为Person组件服务的reducer</span></span><br><span class="line"><span class="keyword">import</span> persons <span class="keyword">from</span> <span class="string">&#x27;./person&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//汇总所有的reducer变为一个总的reducer</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  combineReducers(&#123;</span><br><span class="line">count,</span><br><span class="line">persons</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后创建store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">该文件专门用于暴露一个store对象，整个应用只有一个store对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入createStore，专门用于创建redux中最为核心的store对象</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore,applyMiddleware&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="comment">//引入汇总之后的reducer</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="comment">//引入redux-thunk，用于支持异步action</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露store </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer,applyMiddleware(thunk))</span><br></pre></td></tr></table></figure><p>至此，关于redux的文件就弄好了，接下来就去弄容器组件，Count组件要的state是Count和跟Person人数，Action是数字的运算，则有</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line"><span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line"><span class="attr">count</span>:state.count,</span><br><span class="line"><span class="attr">personCount</span>:state.persons.length</span><br><span class="line">&#125;),</span><br><span class="line">&#123;increment,decrement,incrementAsync&#125;</span><br><span class="line">)(CountUI)</span><br></pre></td></tr></table></figure><p>Person类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line"><span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line"><span class="attr">count</span>:state.count,</span><br><span class="line"><span class="attr">personCount</span>:state.persons.length</span><br><span class="line">&#125;),</span><br><span class="line">&#123;increment,decrement,incrementAsync&#125;</span><br><span class="line">)(CountUI)</span><br></pre></td></tr></table></figure><p>至此，对于react的基本介绍就到这里了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于React的比较重要的思想和库，这里也简单的写个博客记录一下学习过程&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://example.com/2021/09/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://example.com/2021/09/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2021-09-18T06:08:07.000Z</published>
    <updated>2021-09-18T06:38:55.316Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客简单介绍一下二分查找算法及其框架</p><span id="more"></span><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找的思路其实很简单，无非就是一堆数据过来，你就不断分分分分分，就能把一堆数据分成仅剩一个，但细节真的很多，一个不注意就会漏掉数据，这里我们利用二分查找的一个固定框架来简单的介绍一下这些细节问题。<br>先直接上代码框架</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> binarySearch = <span class="function">(<span class="params">nums,target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>); <span class="comment">// 防止left + right 太大导致计算溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> ...; &#125;</span><br></pre></td></tr></table></figure><p>记住，写二分查找千万不能偷懒直接写else，要用else if 写明每一个情况。当然十分自信的话用else来简化代码也不是不可以,然后利用这个框架，我们写一个最简单的查找数组里面的元素。代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> binarySearch = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(left + (right - left) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后注意几点， while 里面是 &lt;= ,因为这里初始化right是length -1，表示数组最后一个值的索引，所以可以取等号，直接就是二分查找需要考虑的一个重点问题 **边界问题**<br>这就看具体题型了，因为这题属于是闭区间【】，数组的头和尾都有可能是查找的值，取等号是没问题的，有些左闭右开区间 【 ）就要考虑是否该用&lt;来代替&lt;=了。这里我们再说一下终止条件和搜索区间的联系。<br>当while取 &lt;= 时，终止条件是 left &gt; right, 大概就是让你在[3,2]中找一个值，这根本不可能找到对吧，然后 &lt; 的终止条件是left == right情况就是在(2,2)中找，也找不到，因为是开区间取不到2。</p><p>再然后，为什么left和right要是mid + 1/ - 1。 还是从搜索区间来看吗，当我们发现mid不是我们要找的值，那mid是不是就不用找了？那搜索区间就理所应当的是[mid + 1,right],[left,mid - 1]。<br>至此二分查找应该可以有个基本的理解了，但这个框架有缺陷，比如给个有序数组 nums = [1,2,2,2,3]，想找2，确实能找到，但是只能找到最中间的2，左右两边2是不可能查的到的，哎，这就很烦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇博客简单介绍一下二分查找算法及其框架&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>初探动态规划/回溯</title>
    <link href="http://example.com/2021/09/15/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://example.com/2021/09/15/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-09-15T11:41:21.000Z</published>
    <updated>2021-09-17T11:32:08.697Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构上刷算法… 好说歹说算是入门了</p><span id="more"></span><h1 id="何为动态规划"><a href="#何为动态规划" class="headerlink" title="何为动态规划"></a>何为动态规划</h1><p>怎么说呢，动态规划就是是一种分治的思想，换句话说，就是把一个大问题，拆分成小问题，再把小问题接着拆分，拆到无可再分的时候，会得到最小的子问题，而子问题的答案很轻松就能得到，根据这个答案递推回去，就能得到原本问题的答案，是一种自底而上的做法。（当然也有自顶而下的方法）。动态规划核心套路是“穷举求最优解”，然后利用状态转移方程进行<strong>正确的穷举</strong>，也就是取消重叠子问题。<br>即，动态规划分治穷举后，两个重要特性就是 <strong>重叠子问题</strong>和<strong>最优子结构</strong></p><h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><p>刚刚提到一个核心的概念，就是状态转移方程，这是做动态规划类问题最重要的一个步骤，也是最抽象的一个步骤，我们能想到状态转移方程就代表这道题我们理解了大半了，我们由斐波那契数列入手来引出这个概念。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span> (<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单吧，直接暴力递归，但是贼低效，鲁迅说过“所有递归问题都可以看作是树问题”，那我们就看看这个递归调用时的树，假设i = 20;<br><img src="/2021/09/15/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/fib.png" alt="fib"><br>看看时间复杂度？O(2^n)，直接裂开来，而且你会发现有大量的重复计算，比如f(18)和f(17)都被计算了两次，更往下的子节点被重复计算的次数更多，这就是之前提到的<strong>重叠子问题</strong>，所以为了解决这个问题，我们引入一个备忘录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span> (<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>)</span><br><span class="line">  dp[<span class="number">1</span>] = dp [<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] +  dp[i - <span class="number">2</span>]</span><br><span class="line">  <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这我们可以得知，我们知道这是第n代的兔子，让我们去求第n代兔子的总数，也就是dp(n),并且dp(n) = dp(n-1) + dp(n-2)，哎，那求dp(n)的问题是不是就转移到求dp(n-1) + dp(n-2)了，这个就叫状态转移方程，当然不要忘了n = 1 和n = 2的情况。综上，我们得到斐波那契数列的状态转移方程</p><p>dp(n) = { 1,  n = 1,2<br>{dp(n-1) + dp(n-2), n &gt; 2</p><p>这里解决了<strong>重叠子问题</strong>，那动态规划另一个重要特性<strong>最优子结构</strong>呢？<br>因为斐波那契不算真正的动态规划问题，写这个主要是为了引入如何抽象出状态转移方程，对于最优子结构，让我们往下看。</p><h2 id="典中典的凑硬币"><a href="#典中典的凑硬币" class="headerlink" title="典中典的凑硬币"></a>典中典的凑硬币</h2><p>说起动态规划就不得不提凑硬币的问题，太经典了属于是。再说凑硬币问题前我们简单聊一聊贪心算法，贪心算法其实是动态规划的一个特例，动态规划是一只分分分分分到最后找出最优解，而贪心是先分解若干个子问题，找出最优，再从这个最优子问题中接着分解，也就是说<strong>贪心算法是每一都要求出最优解的动态规划问题</strong>。<br>这里说回来凑硬币问题，比如我们有面值为1，5，11元的硬币，要求凑出15元所用的最少硬币数。用贪心的话就是，第一步的最优解肯定是面值最大的11元，然后还差四元就需要用四枚一元硬币，一共五枚。而这道题真正的最优解其实是三枚五元硬币，这样就能看出贪心和动态规划的区别了。<br>那么这道题我们该如何思考呢？又或者是说怎么列出状态转移方程？仔细思考一下，我们之前有提到过动态分解到最小子问题后往上递归，也就是“自低而上”的思维，那这个问题的最底部显然就是0个硬币凑0元，再往上也就是一个硬币， 也就是凑了1，5，11元还剩14，10，4元，分别需要 dp[14]+1,dp[10]+1,dp[4]+1个，（这里dp[n]是凑n元需要的硬币数，这里因为要求最少硬币数，所以需要在dp[14],dp[10],dp[1]中找出最优的情况，所以底层往上的第一步，就是<br>dp[15] = min(dp[15-1],dp[15-5],dp[15-10])+1,这里15由未知数代替，考虑边界情况，也就是n&lt;=0的情况，那我们不就能得到状态转移方程了？<br>dp[n] = { 0 ,n&lt;=0<br>{min(dp[15 - coin]), n&gt;0<br>得到状态转移方程，再用自底而上的思维，得出代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> changeCoin = <span class="function">(<span class="params">coins,amount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化备忘录,用Infinity填满备忘录，Infinity说明该值不可以用硬币凑出来</span></span><br><span class="line">  <span class="keyword">let</span> dp = newArray(amount + <span class="number">1</span>).fill(<span class="literal">Infinity</span>)</span><br><span class="line">  dp[<span class="number">0</span>] = [<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> coin <span class="keyword">of</span> coins)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coin &lt;= i)</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - coin] + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[amount] === <span class="literal">Infinity</span> ? -<span class="number">1</span> : dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就结束啦！<br>那么最后，怎样判断一个问题是不是动态规划问题呢？<br>一般有</p><ul><li>求最大值，最小值</li><li>判断方案是否可行</li><li>统计方案个数</li><li>子问题是否满足最优子结构，即每个子问题都不影响其他子问题</li></ul><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>看完动态规划，我们就简单说一下回溯，回溯重点就是这个“回”字，他从本质上来说就是遍历决策树的过程，我们需要抓住这三点：</p><ul><li>路径 也就是做过的选择</li><li>选择列表 当前可以选择的部分</li><li>结束条件 到达决策树底部，没有新的选择</li></ul><p>回溯是有框架的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表): <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">result.add(路径) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表: 做选择</span><br><span class="line">backtrack(路径, 选择列表) 撤销选择</span><br></pre></td></tr></table></figure><p>可以看到 这串代码的核心是，递归调用 backtrack，并且在递归之前做选择，递归之后撤销选择就行。</p><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>最基本的回溯问题就是全排列问题了，就比如给我们【1，2，3】三个数字，求出他们不重复情况的全排列，可以得到以下决策树<br><img src="/2021/09/15/%E5%88%9D%E6%8E%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/jueceshu.png" alt="jcs"><br>我们站在决策树的顶端，此时我们的选择列表是【1，2，3】，没有路径，因为我们还没做过选择，假设我们选择2后到达第二个节点，那么我们的选择列表是【1，3】，2就变成了我们的路径，然后 backtrack函数，就像是个指针，在这个树上游走，要维护每个节点的选择列表和路径，当它走到树的底层后，就触发了结束条件。<br>再然后，如何遍历一个树？ 要记住，所有搜索问题其实都是树的遍历问题，而多叉树的遍历，有两个重要框架，前序遍历和后序遍历，前序遍历在递归进入下一个节点前进行，后续遍历在进入一个节点后执行，前序遍历让多叉树得以向某一子节点递归，后序遍历可以让多叉树依次对多个子节点递归遍历，依照这个思路以及前面的框架，我们得出全排列代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> allSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  backTrack = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 判断是否满足结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(nums.length === path.length)&#123;</span><br><span class="line">      res.push([...path])  </span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决重复路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(path.indexOf(nums[i]) !== -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/** 前序遍历 */</span></span><br><span class="line">      path.push(nums[i])</span><br><span class="line"></span><br><span class="line">      backTrack(path)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 后序遍历</span></span><br><span class="line">      path.pop()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backTrack([])</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p>这个也是回溯经典啊，单比全排列稍微复杂一丢丢，题目的意思就是给我们一个N x N的棋盘，在上面摆N个皇后，让这些皇后不能互相攻击，问我们有几种摆法。<br>然后写回溯问题，我们一定要想明白它的决策树，和写动态规划要想明白df方程是一样的。<br>对于N皇后的决策树，我们可以想决策树的每一层，就是棋盘上的每一行，然后那一层的每一个节点，对应的就是棋盘上那一行的每个列。<br>直接套用上面框架</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Queen = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> board = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="string">&#x27;.&#x27;</span>.repeat(n))</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  isValid = <span class="function">(<span class="params">board, row, col</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = board.length</span><br><span class="line">    <span class="comment">//检查列皇后是否冲突</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(board[i][col] === <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左对角线冲突</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>,j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(board[i][j] === <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右对角线冲突，</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>,j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(board[i][j] === <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  repalceAt = <span class="function">(<span class="params">str,index,target</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">const</span> strAry = str.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    strAry[index] = target</span><br><span class="line">    <span class="keyword">return</span> strAry.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  backTrack = <span class="function">(<span class="params">board, row</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(row === board.length)&#123;</span><br><span class="line">      res.push([...board])</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> len = board.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; len; col++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!isValid(board,row,col))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="comment">//前序</span></span><br><span class="line">      board[row] = repalceAt(board[row],col,<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line"></span><br><span class="line">      backTrack(board, row + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">//后序</span></span><br><span class="line">      board[row] =repalceAt(board[row],col,<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  backTrack(board,<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="回溯和动态规划"><a href="#回溯和动态规划" class="headerlink" title="回溯和动态规划"></a>回溯和动态规划</h2><p>至此回溯就简单的说到这了啊<br>这里我们看到回溯和动态规划的联系和区别，联系就是，二者都需要通过穷举来解题，但动态规划需要通过备忘录解决重叠子问题来优化并找出最佳答案，而回溯就算真正的暴力求解了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据结构上刷算法… 好说歹说算是入门了&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>react源码初探</title>
    <link href="http://example.com/2021/09/15/react%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/"/>
    <id>http://example.com/2021/09/15/react%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/</id>
    <published>2021-09-15T02:45:41.000Z</published>
    <updated>2021-09-17T12:32:48.010Z</updated>
    
    <content type="html"><![CDATA[<p>总算到这一步了 看react源码部分的笔记</p><span id="more"></span><h1 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h1><p>Virtual DOM 是 React 的核心与精髓所在,React就是靠着VDOM和高效的diff算法大量减少了渲染DOM的代价。<br>VDOM中转换成浏览器中真实的DOM树，即VDOM其实也存在于树这种数据结构中，那他就会有自己的节点，他的节点被称为 ReactNode， 分为3种类型 ReactElement、ReactFragment 和ReactText，其中，ReactElement 又分为 ReactComponentElement 和 ReactDOMElement。<br>先看看这些类型源码，涉及到Ts部分、</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReactNode = ReactElement | ReactFragment | ReactText;</span><br><span class="line"><span class="keyword">type</span> ReactElement = ReactComponentElement | ReactDOMElement;</span><br><span class="line"><span class="keyword">type</span> ReactDOMElement = &#123; <span class="attr">type</span> : <span class="built_in">string</span>,</span><br><span class="line"><span class="attr">props</span> : &#123;</span><br><span class="line"><span class="attr">children</span> : ReactNodeList, <span class="attr">className</span> : <span class="built_in">string</span>,</span><br><span class="line">etc.</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">key</span> : <span class="built_in">string</span> | <span class="built_in">boolean</span> | <span class="built_in">number</span> | <span class="literal">null</span>, <span class="attr">ref</span> : <span class="built_in">string</span> | <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> ReactComponentElement&lt;TProps&gt; = &#123; <span class="attr">type</span> : ReactClass&lt;TProps&gt;,</span><br><span class="line">props : TProps,</span><br><span class="line"><span class="attr">key</span> : <span class="built_in">string</span> | <span class="built_in">boolean</span> | <span class="built_in">number</span> | <span class="literal">null</span>, <span class="attr">ref</span> : <span class="built_in">string</span> | <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> ReactFragment = <span class="built_in">Array</span>&lt;ReactNode | ReactEmpty&gt;; <span class="keyword">type</span> ReactNodeList = ReactNode | ReactEmpty;</span><br><span class="line"><span class="keyword">type</span> ReactText = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> ReactEmpty = <span class="literal">null</span> | <span class="literal">undefined</span> | <span class="built_in">boolean</span>;</span><br></pre></td></tr></table></figure><p>然后我们写JSX的时候，react会帮我吗掉createElement方法构造虚拟节点，这是个蛮重要的部分，直接上代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createElement 只是做了简单的参数修正，返回一个 ReactElement 实例对象， // 也就是虚拟元素的实例</span></span><br><span class="line">ReactElement.createElement = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">type</span>, config, children</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 初始化参数</span></span><br><span class="line"><span class="keyword">var</span> propName;</span><br><span class="line"><span class="keyword">var</span> props = &#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> key = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">var</span> ref = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">var</span> self = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">var</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在 config，则提取里面的内容 if (config != null) &#123;</span></span><br><span class="line"><span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">  ref = config.ref === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.ref;</span><br><span class="line">  key = config.key === <span class="literal">undefined</span> ? <span class="literal">null</span> : <span class="string">&#x27;&#x27;</span> + config.key;</span><br><span class="line">  self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self; </span><br><span class="line">  source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source; </span><br><span class="line"><span class="comment">// 复制 config 里的内容到 props(如 id 和 className 等)</span></span><br><span class="line">  <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.hasOwnProperty(propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class="line">      props[propName] = config[propName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 children，全部挂载到 props 的 children 属性上。如果只有一个参数，直接赋值给 children， // 否则做合并处理</span></span><br><span class="line"><span class="keyword">var</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">  props.children = children;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> childArray = <span class="built_in">Array</span>(childrenLength); </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">    childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>]; </span><br><span class="line">  &#125;</span><br><span class="line">  props.children = childArray; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果某个 prop 为空且存在默认的 prop，则将默认 prop 赋给当前的 prop </span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">type</span> &amp;&amp; <span class="keyword">type</span>.defaultProps) &#123;</span><br><span class="line">  <span class="keyword">var</span> defaultProps = <span class="keyword">type</span>.defaultProps;</span><br><span class="line">  <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> props[propName] === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">       props[propName] = defaultProps[propName];</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回一个 ReactElement 实例对象</span></span><br><span class="line"><span class="keyword">return</span> ReactElement(<span class="keyword">type</span>, key, ref, self, source, ReactCurrentOwner.current, props); &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><p>Virtual DOM 模型通过 createElement 创建虚拟元素，那又是如何创建组件的呢?</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;总算到这一步了 看react源码部分的笔记&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>HOC | render props | hook</title>
    <link href="http://example.com/2021/09/14/HOC-render-props-hook/"/>
    <id>http://example.com/2021/09/14/HOC-render-props-hook/</id>
    <published>2021-09-14T12:08:34.000Z</published>
    <updated>2021-09-14T13:01:03.474Z</updated>
    
    <content type="html"><![CDATA[<p>react的中 对于一些复用的节点，我们可以抽成一个组件，而对于一些复用的逻辑，我们也可以抽象化这个逻辑来优化代码，主要有三种方法，HOC，render props，和自定义hook</p><span id="more"></span><h1 id="HOC"><a href="#HOC" class="headerlink" title="HOC"></a>HOC</h1><p>HOC 就是高阶组件吗，之前有博客介绍了的，虽然写的有点烂但我这里就不赘述了，这里用一个计数器的demo，直接上高阶组件实现计数器的代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;View, Text,Button&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Count</span>(<span class="params">&#123;count,add,minus&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flex:1,alignItems:</span>&#x27;<span class="attr">center</span>&#x27;,<span class="attr">justifyContent:</span>&#x27;<span class="attr">center</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Text</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;add&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">add</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;minus&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">minus</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;changeTheme&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">ChangeTheme</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> countNumber=<span class="function">(<span class="params">initNumber</span>)=&gt;</span> <span class="function">(<span class="params">WrappedComponent</span>)=&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CountNumber</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        state = &#123;<span class="attr">count</span>: initNumber&#125;;</span><br><span class="line">        add = <span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span>&#125;);</span><br><span class="line">        minus = <span class="function">() =&gt;</span> <span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>: <span class="built_in">this</span>.state.count - <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                &#123;<span class="attr">...this.props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">count</span>=<span class="string">&#123;this.state.count&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">add</span>=<span class="string">&#123;this.add.bind(this)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">minus</span>=<span class="string">&#123;this.minus.bind(this)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            /&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> countNumber(<span class="number">0</span>)(Count);</span><br></pre></td></tr></table></figure><p>优点:<br>可以看到，高阶组件是把逻辑和UI分开了，Count组件指负责渲染UI，被传入HOC中才有了计数的逻辑，这很好的维护了内层组件的状态，降低了耦合度<br>缺点:</p><ol><li>注意一下HOC的state是写死的，也就是说传入给Count组件的prop是写死的，这就有可能产生命名冲突，覆盖掉Count组件原有的props</li><li>HOC是链式调用，会导致错误难以定位</li></ol><h1 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h1><p>先直接上代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;View, Text,Button&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">RenderProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;flex:1,alignItems:</span>&#x27;<span class="attr">center</span>&#x27;,<span class="attr">justifyContent:</span>&#x27;<span class="attr">center</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">CountNumber</span> <span class="attr">initNumber</span>=<span class="string">&#123;0&#125;</span> <span class="attr">render</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                    (&#123;<span class="attr">count</span>,<span class="attr">add</span>,<span class="attr">minus</span>&#125;)=&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Text</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;add&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">add</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;minus&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">minus</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;changeTheme&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">ChangeTheme</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">                &#125;&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">CountNumber</span>&gt;</span></span></span><br><span class="line">        &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountNumber</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    state=&#123;<span class="attr">count</span>:<span class="built_in">this</span>.props.initNumber&#125;;</span><br><span class="line">    add=<span class="function">()=&gt;</span><span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count+<span class="number">1</span>&#125;);</span><br><span class="line">    minus=<span class="function">()=&gt;</span><span class="built_in">this</span>.setState(&#123;<span class="attr">count</span>:<span class="built_in">this</span>.state.count-<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.props.render(&#123;</span><br><span class="line">            <span class="attr">count</span>: <span class="built_in">this</span>.state.count,</span><br><span class="line">            <span class="attr">add</span>: <span class="built_in">this</span>.add,</span><br><span class="line">            <span class="attr">minus</span>:<span class="built_in">this</span>.minus</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样也实现了逻辑复用，还留下了一个“插槽”，也就是预留位置，缺点就是不能在return语句外访问数据，同时用的过多的话会跟HOC差不多，HOC是过长的链式调用形成异常栈，而render props则会形成潜逃地狱</p><h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><p>最后看一看最新的自定义hook</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;View, Text,Button&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">HookCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,addCount,minusCount] = useCountNumber(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;&#123;backgroundColor:theme,flex:1,alignItems:</span>&#x27;<span class="attr">center</span>&#x27;,<span class="attr">justifyContent:</span>&#x27;<span class="attr">center</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Text</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;addCount&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">add</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;minusCount&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">minus</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;changeTheme&#125;</span> <span class="attr">title</span>=<span class="string">&#123;</span>&#x27;<span class="attr">ChangeTheme</span>&#x27;&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCountNumber</span>(<span class="params">initNumber</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(initNumber);</span><br><span class="line">    <span class="keyword">const</span> addCount=<span class="function">()=&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> minusCount=<span class="function">()=&gt;</span>setCount(count -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        count,</span><br><span class="line">        addCount,</span><br><span class="line">        minusCount</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>反正 hook作为最新的语法，最好还是多用他，但也不能完全代替</p><ul><li>Hooks：<ul><li>替代 Class 的大部分用例，除了 getSnapshotBeforeUpdate 和 componentDidCatch 还不支持。</li><li>提取复用逻辑。除了有明确父子关系的，其他场景都可以使用 Hooks。</li></ul></li><li>Render Props：在组件渲染上拥有更高的自由度，可以根据父组件提供的数据进行动态渲染。适合有明确父子关系的场景。</li><li>高阶组件：适合用来做注入，并且生成一个新的可复用组件。适合用来写插件。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;react的中 对于一些复用的节点，我们可以抽成一个组件，而对于一些复用的逻辑，我们也可以抽象化这个逻辑来优化代码，主要有三种方法，HOC，render props，和自定义hook&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>高阶组件</title>
    <link href="http://example.com/2021/09/13/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2021/09/13/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</id>
    <published>2021-09-13T11:36:08.000Z</published>
    <updated>2021-09-13T12:50:44.790Z</updated>
    
    <content type="html"><![CDATA[<p>呜呜呜介绍一下高阶组件</p><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>这里直接看官方文档: <strong>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。</strong><br>组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。</p><p>官方文档用了一个demo解释了一下，这里我就说个大概，就是当我们需要两个组件，一个是CommentList用于获取用户评论，一个是BlogPost用于订阅单篇博客，他们都共享<strong>订阅数据————渲染————取消订阅</strong>这么一个逻辑，这样我们就可以把这个公共逻辑抽象成一个函数，这个函数就是一个<strong>高阶组件</strong>，因为这个函数接受了一个普通组件作为参数返回了一个有着订阅逻辑后的新组件，直接上代码: (这里我随便写写，跟官方不一样了)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原本组件逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CommentList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState()</span><br><span class="line">  useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    DataSource.getComment(handleChange())<span class="comment">//获取订阅</span></span><br><span class="line">    <span class="keyword">return</span> DataSource.removeComment(handleChange())<span class="comment">//清除订阅</span></span><br><span class="line">  &#125;)</span><br><span class="line">  handleChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setData(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handleChange&#125;</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlogPost</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState()</span><br><span class="line">  useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    DataSource.getBlog(handleChange())<span class="comment">//获取订阅</span></span><br><span class="line">    <span class="keyword">return</span> DataSource.removeBlog(handleChange())<span class="comment">//清除订阅</span></span><br><span class="line">  &#125;)</span><br><span class="line">  handleChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setData(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;handleChange&#125;</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶组件函数</span></span><br><span class="line"></span><br><span class="line">getDataComp = <span class="function">(<span class="params">Comp, getDataType,removeDataType</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      DataSource.getDataType()</span><br><span class="line">      <span class="keyword">return</span> DataSource.removeDateType()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setData(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">data</span>=<span class="string">&#123;state.data&#125;</span> <span class="attr">props</span>=<span class="string">&#123;...props&#125;/</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的订阅数据就会作为props传递了，可能这里我写的没有很明白，那就还是可以去官方文档看看。<br>然后高阶组件是纯函数，绝不要在高阶组件中修改原组件模型，并且要将不向关的props传给被包裹的组件，大多数 HOC 都应该包含一个类似于下面的 render 方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 过滤掉非此 HOC 额外的 props，且不要进行透传</span></span><br><span class="line">  <span class="keyword">const</span> &#123; extraProp, ...passThroughProps &#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 props 注入到被包装的组件中。</span></span><br><span class="line">  <span class="comment">// 通常为 state 的值或者实例方法。</span></span><br><span class="line">  <span class="keyword">const</span> injectedProp = someStateOrInstanceMethod;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 props 传递给被包装组件</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">injectedProp</span>=<span class="string">&#123;injectedProp&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      &#123;<span class="attr">...passThroughProps</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mad 写着写着突然发现，自定义hook是不是可以代替高阶组件和 render props？？？哇日！？我麻了我麻了我麻了<br>这东西可以深挖，先放一放</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;呜呜呜介绍一下高阶组件&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Deep react</title>
    <link href="http://example.com/2021/09/12/Deep-react/"/>
    <id>http://example.com/2021/09/12/Deep-react/</id>
    <published>2021-09-12T12:28:15.000Z</published>
    <updated>2021-09-14T07:11:38.076Z</updated>
    
    <content type="html"><![CDATA[<p>《深入react技术栈》读书笔记</p><span id="more"></span><h1 id="第一章-初入react世界"><a href="#第一章-初入react世界" class="headerlink" title="第一章 初入react世界"></a>第一章 初入react世界</h1><p>这章大致的介绍了react的一些基本概念 ，以及利用一个tab栏的例子引出了state，props，ref和生命周期函数的概念。要点如下：</p><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><ul><li>就是react是操纵虚拟DOM的<br><img src="/2021/09/12/Deep-react/vdom.png" alt="vdom"></li><li>写react的编程方式是<strong>函数式编程</strong>，也就是声明式。</li><li>虚拟DOM其实是以JSON对象的形式存在的，直接上代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">const</span> buttonJSX = <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-blue&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">em</span>&gt;</span>Confirm<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml">                  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> buttonJSON = &#123;</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">                    <span class="attr">props</span>: &#123;</span><br><span class="line">                    <span class="attr">className</span>: <span class="string">&#x27;btn btn-blue&#x27;</span>, </span><br><span class="line">                    <span class="attr">children</span>: [&#123;</span><br><span class="line">                      <span class="attr">type</span>: <span class="string">&#x27;em&#x27;</span>,</span><br><span class="line">                      <span class="attr">props</span>: &#123;</span><br><span class="line">                        <span class="attr">children</span>: <span class="string">&#x27;Confirm&#x27;</span> </span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;] </span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br></pre></td></tr></table></figure><p>其他的部分没怎么细看了 似懂非懂</p><h1 id="第二章-漫谈React"><a href="#第二章-漫谈React" class="headerlink" title="第二章 漫谈React"></a>第二章 漫谈React</h1><h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><p>即react中的事件都是封装好的合成事件。</p><ol><li>事件委派<br>在虚拟DOM被渲染后，react会把所有的事件处理函数绑定到结构的最外层，用一个统一的事件监听器管理，也就是说并不会直接绑定到单一的DOM节点上。这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是 在这个统一的事件监听器上插入或删除一些对象;当事件发生时，首先被这个统一的事件监听器 处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升。</li><li>自动绑定<br>在 React 组件中，每个方法的上下文都会指向该组件的实例，即自动绑定 this 为当前组件。 而且 React 还会对这种引用进行缓存，以达到CPU和内存的最优化。在使用 ES6 classes 或者纯函数时，这种自动绑定就不复存在了，我们需要手动实现 this 的绑定。</li></ol><p>绑定this用bind方法或者使用箭头函数(在不传参的情况下可以用::的语法代替bind(),也就是说其实bind()方法在某种意义上已经被废弃了)。<br>然后现在有了hooks后函数组件的出现率应该会大于类组件了，而在函数组件中就没必要担心this的指向问题了。<br>然后我们也可以利用ref实现原生Js的事件，但没必要，都用上react不到  万不得已绝不轻易操纵真实DOM。</p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>无非就是受控组件和非受控组件的区别，这个没啥。</p><h2 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h2><p>用什么 css_moudles 复杂 看不懂 过</p><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><p>这个看之前的博客， 有总结过的</p><h2 id="组件间抽象"><a href="#组件间抽象" class="headerlink" title="组件间抽象"></a>组件间抽象</h2><ol><li>mixin 第一次见这个东西 难懂 没理解 先过 <strong>mixin 是一个包含可被其他类使用而无需继承的方法的类</strong>这是维基百科的定义</li><li>高阶组件 。。还好没深挖，react就采取高阶组件的方式代替了mixin，关于这个东西的概念C++这种面向对象的语言专业课应该会有讲</li></ol><h3 id="实现高阶组件"><a href="#实现高阶组件" class="headerlink" title="实现高阶组件"></a>实现高阶组件</h3><p>实现高阶组件的方法有两种吗，一种叫**属性代理(props proxy)<strong>。高阶组件通过被包裹的 React 组件来操作 props，还有一种是</strong>反向继承(inheritance inversion)**。高阶组件继承于被包裹的 React 组件</p><p>这个感觉东西有点多啊，专门写一篇博客吧。<br><img src="/2021/09/12/Deep-react/comp:png.png" alt="comp"></p><h2 id="组件性能优化"><a href="#组件性能优化" class="headerlink" title="组件性能优化"></a>组件性能优化</h2><p>用purerender去解决不必要的渲染，好像hooks里useEffect可以用依赖解决这个问题</p><h3 id="pure-Render"><a href="#pure-Render" class="headerlink" title="pure Render"></a>pure Render</h3><p>先说纯函数 老生常谈的问题了</p><ol><li>给定相同的输入，它总是返回相同的输出; </li><li>过程没有副作用(side effect)1;</li><li>没有额外的状态依赖。<br>再往下看好像真的很像useEffect的依赖</li></ol><h3 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h3><p>没看明白 不懂 用useEffect算了</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>之前有写了篇博客关于key的机制</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>就是可以用react的一些动画库写，就不用写繁琐的css了，好像有点东西，后面再深究<br>现有的动画</p><ul><li>css</li><li>js-svg</li><li>react一些动画库 smooth啥的</li><li>React Transition 之前有了解过，收藏夹里吃灰好久了</li><li>react-motion</li><li>cubic-bezier （上面这两条都有关于缓动动画）</li></ul><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>这…..还没上线过项目，测试啥的歇会儿吧</p><p>然后用了一堆库对第一章的tab优化了我？？？？？？？<br>人傻了  代码歇会儿放吧</p><p>后面就是看源码的部分了 难之</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《深入react技术栈》读书笔记&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>interface和type</title>
    <link href="http://example.com/2021/09/11/interface%E5%92%8Ctype/"/>
    <id>http://example.com/2021/09/11/interface%E5%92%8Ctype/</id>
    <published>2021-09-11T02:06:42.000Z</published>
    <updated>2021-09-13T11:11:49.141Z</updated>
    
    <content type="html"><![CDATA[<p>学了ts有段时间了 type跟interface的区别一直处于一个懵懂的状态，感觉很多地方他俩可以互相代替，和react联系起来后对于prop和state的定义上是用type或interface也有不明确的地方，所以写一篇博客谈谈理解和想法。</p><span id="more"></span><h1 id="简单定义"><a href="#简单定义" class="headerlink" title="简单定义"></a>简单定义</h1><p>在说区别前我们先了解一下什么是 interface 和 type</p><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p><strong>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</strong></p><p>大致意思就是用来规范对象 ｜ 类 的，对象和类需要满足接口所定义的属性， 接口可以被extend(继承)和implementing(实现)</p><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>type(类型别名)就是用来自定义类型的，什么联合类型交叉类型字面量类型等等，本质上说type其实是给你自定义类型重新取一个可读的名字<br>交叉类型(&amp;)可以实现和extend差不多的效果</p><h1 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h1><p>翻了好多博客和官方文档 得到这样一句话<br><strong>“type aliases can act sort of like interfaces, however, there are some subtle differences.”</strong><br>和开头说的差不多，type在很多地方可以替代interface，但还是有一些差别。</p><h2 id="是否创建新的变量名"><a href="#是否创建新的变量名" class="headerlink" title="是否创建新的变量名"></a>是否创建新的变量名</h2><p>官网中提到的第一处不同是“One difference is, that interfaces create a new name that is used everywhere. Type aliases don’t create a new name — for instance, error messages won’t use the alias name.”<br>这其实是不对的，在编译器中尝试会发现报错信息是一致的<br>比如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PointInterface &#123;</span><br><span class="line">   <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">   <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">type</span> PointType = &#123;</span><br><span class="line">   <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">   <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> getSquareI = <span class="function">(<span class="params">args: PointInterface</span>) =&gt;</span> args.x * args.y</span><br><span class="line"> <span class="keyword">const</span> getSquareT = <span class="function">(<span class="params">args: PointType</span>) =&gt;</span> args.x * args.y</span><br><span class="line"></span><br><span class="line"> <span class="comment">// error: 类型&#123;x: number&#125;不能赋值给squareI/T 类型的参数，因为缺少了 &#123;y: number&#125;属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="关于extend-和-implemented"><a href="#关于extend-和-implemented" class="headerlink" title="关于extend 和 implemented"></a>关于extend 和 implemented</h2><p>第二处不同<br><strong>“A second more important difference is that type aliases cannot be extended or implemented from”</strong><br>Mad！！！这也是错的！！！ 直接看代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> TreeDimeions <span class="keyword">extends</span> PointType &#123;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Rectangele</span> <span class="title">implements</span> <span class="title">PointType</span> </span>&#123;</span><br><span class="line">    x= <span class="number">2</span></span><br><span class="line">    y= <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">RectangPrism</span> <span class="title">implements</span> <span class="title">TreeDimeions</span> </span>&#123;</span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    y = <span class="number">3</span></span><br><span class="line">    z = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 也可以通过type和interface实现对类的约束</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    area(): <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">type</span> Perimeter = &#123;</span><br><span class="line">    perimeter(): <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="title">implements</span> <span class="title">PointType</span>, <span class="title">Shape</span>, <span class="title">Perimeter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    y = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    area () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.x * <span class="built_in">this</span>.y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">perimeter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">this</span>.x + <span class="built_in">this</span>.y)*<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="type不能对其他type-extend和implement"><a href="#type不能对其他type-extend和implement" class="headerlink" title="type不能对其他type extend和implement"></a>type不能对其他type extend和implement</h2><p>第三处不同说<br><strong>“type aliases cannot extend/implement other types”</strong><br>这句话也不对，但不说完全不对，只能说部分正确</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  area(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Perimeter = &#123;</span><br><span class="line">  perimeter(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 &amp; 实现 extend</span></span><br><span class="line"><span class="keyword">type</span> RectangleShape = Shape &amp; Perimeter &amp; Point</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="title">implements</span> <span class="title">RectangleShape</span> <span class="title">Perimeter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    y = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    area () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.x * <span class="built_in">this</span>.y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">perimeter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">this</span>.x + <span class="built_in">this</span>.y)*<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现映射类型</span></span><br><span class="line"><span class="keyword">type</span> RectangleShape2 = Partial&lt;Shape &amp; Perimeter&gt; &amp; Point</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartialRectangle</span> <span class="title">implements</span> <span class="title">RectangleShape2</span> </span>&#123;</span><br><span class="line">  x = <span class="number">2</span></span><br><span class="line">  y = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二者区别-真"><a href="#二者区别-真" class="headerlink" title="二者区别 真"></a>二者区别 真</h1><p>叭叭了这么多，所以二者的区别到底在哪儿呢</p><ol><li><p><strong>you cannot use implements on an class with type alias if you use union operator within your type definition</strong><br>翻译就如果一个type是联合类型，那我就不能用类去实现他了<br><img src="/2021/09/11/interface%E5%92%8Ctype/1.gif" alt="gif"></p></li><li><p><strong>you cannot use extends on an interface with type alias if you use union operator within your type definition</strong><br>差不多意思，一个type是联合类型，接口就不能继承了</p></li></ol><p>这里那篇博客的解释是，类和接口都是一个 ***“blueprint” ***<br>所以他们不能实现和继承在 <em><strong>one or another shape</strong></em> 我英语太废物了完全不懂是什么意思啊赣了</p><ol start="3"><li><strong>declaration merging doesn’t work with type alias</strong><br>type不能合并声明，这个很多博客都提到了，没啥多说的<br><img src="/2021/09/11/interface%E5%92%8Ctype/2.png" alt="png"><br>因为type是一个unique type entity，无论是在全局变量还是module scope中</li></ol><p>而在react中<br>always use interface for public API’s definition when authoring a library or 3rd party ambient type definitions<br>consider using type for your React Component Props and State</p><p>对于props和state还是用type吧， 然后interface用于公共的API和第三方库的实现<br>就是这样 具体区别可能要看看定义interface和type的源码来了解了</p><p><a href="https://medium.com/@martin_hotell/interface-vs-type-alias-in-typescript-2-7-2a8f1777af4c">参考链接</a></p><p><img src="/2021/09/11/interface%E5%92%8Ctype/3.png" alt="dif"></p><p>！在看深入react技术栈的时候看到一点:<br><strong>包括 C++ 等一些年龄较大的 OOP 语言， 它们都有一个强大但危险的多重继承特性。现代语言为了权衡利弊，大都舍弃了多重继承，只采用单继承，但单继承在实现抽象时有诸多不便之处。为了弥补缺失，Java 引入了接口(interface)， 其他一些语言则引入了像 mixin 的技巧，方法虽然不同，但都是为创造一种类似多重继承的效果， 事实上说它是组合更为贴切。</strong><br>结合Java来看，interface其实是更像抽象类的，所以用interface去规范类或许是更好的选择</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学了ts有段时间了 type跟interface的区别一直处于一个懵懂的状态，感觉很多地方他俩可以互相代替，和react联系起来后对于prop和state的定义上是用type或interface也有不明确的地方，所以写一篇博客谈谈理解和想法。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="ts" scheme="http://example.com/tags/ts/"/>
    
  </entry>
  
  <entry>
    <title>Unit14-过渡</title>
    <link href="http://example.com/2021/07/31/CssU14/"/>
    <id>http://example.com/2021/07/31/CssU14/</id>
    <published>2021-07-31T03:06:39.000Z</published>
    <updated>2021-07-31T03:07:46.845Z</updated>
    
    <content type="html"><![CDATA[<p>Css U14 学习笔记</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;Css U14 学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>git的用法</title>
    <link href="http://example.com/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2021-07-07T11:59:53.000Z</published>
    <updated>2021-07-31T02:27:12.600Z</updated>
    
    <content type="html"><![CDATA[<p>git 的笔记</p><span id="more"></span><p>git 管理的是修改<br>工作区里面有个不可见的.git文件， 是这一项目的版本库，版本库里有缓存区和分支</p><p>git add 添加文件到缓存区<br>git commit -m “” 把添加到缓存区到文件全部提交到master分支<br>git push 把提交到文件推送到远程仓库<br>git status 查看仓库状态<br>git diff 文件 查看该文件的修改<br>git log 查看修改日志<br>git checkout – [file] 把文件在工作区(就是目录or在编辑器里面)做的修改全部撤销<br>git reset HEAD [file] 当做了某修改并且 git add 后使用撤销</p><ul><li><p>git恢复版本(作出修改并git commit 后修改的方法)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用git commit 多次提交不同版本</span><br><span class="line"></span><br><span class="line">git log --pretty=oneline 简要查看日志</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD^ 恢复到上一个版本 三个以上用 HEAD～3 (HEAD表示当前版本)</span><br><span class="line"></span><br><span class="line">git reset --hard commit Id  恢复到指定版本号</span><br><span class="line"></span><br><span class="line">git reflog </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在工作区删文件</p><p>  git rm [file] 在版本库里删除文件<br>  git checkout – [file] </p></li></ul><h1 id="关于分支"><a href="#关于分支" class="headerlink" title="关于分支"></a>关于分支</h1><p>我们已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：<br><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/0.png"><br>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。</p><p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：<br><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/l.png"><br>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：<br><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/l-1.png"></p><p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p><p><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/0-1.png"></p><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p><p><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/0-2.png"></p><ul><li><p>实战代码</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">首先，我们创建dev分支，然后切换到dev分支：</span><br><span class="line">git checkout -c dev</span><br><span class="line"></span><br><span class="line">git switch命令加上-b参数表示创建并切换，相当于以下两条命令：</span><br><span class="line">git branch dev</span><br><span class="line">git switch dev</span><br><span class="line"></span><br><span class="line">然后，用git branch命令查看当前分支：</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">git branch命令会列出所有分支，当前分支前面会标一个*号。</span><br><span class="line"></span><br><span class="line">然后，我们就可以在dev分支上正常提交</span><br><span class="line"></span><br><span class="line">dev分支的工作完成，我们就可以切换回master分支</span><br><span class="line">git switch master</span><br><span class="line"></span><br><span class="line">我们把dev分支的工作成果合并到master分支上：</span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line">删除dev分支</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure></li><li><p>总结</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用git log –graph命令可以看到分支合并图</p><p><code> git log --graph --pretty=oneline --abbrev-commit</code></p><ul><li>分支策略:</li></ul><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="/2021/07/07/git%E7%9A%84%E7%94%A8%E6%B3%95/0-3.png"></p><p>Git分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p><p> <code>git stash</code> 把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p><p> 场景：出现了一个Bug，但当前分支的工作还未完成提交，却必须马上修复bug,此时就用该命令</p><p><code>git stash list</code> 查看隐藏的现场<br><code>git stash pop</code> 恢复工作现场<br><code>git cherry-pic &lt;commmit&gt;</code> 让我们能复制一个特定的提交到当前分支(多个分支修改同一个Bug，即在某一个分支修改完成后直接用该命令复制给其他人)</p><ul><li><p>feature分支用于开发某一项新需求， issue-n 分支用于改bug</p></li><li><p><code>git push origin &lt;branch&gt;</code> 推送分支</p></li></ul><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p><p>要查看远程库的信息，用<code>git remote -v</code></p><p>多人协作的工作模式通常是这样：</p><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p><p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><p><code>git rebase</code> 可以把本地未push的分叉提交历史整理成直线,目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><h1 id="关于标签"><a href="#关于标签" class="headerlink" title="关于标签"></a>关于标签</h1><p>标签就是某个版本的快照 和某个commit绑定在一起<br><code>git tag &lt;name&gt;</code> 制作标签</p><p><code>git tag</code> 查看所有标签</p><p>标签默认打在当前版本号上，如果想要打到以前的版本上，找到之前版本的commit id <code>git tag &lt;name&gt; &lt;commit id&gt;</code></p><p><code>git show &lt;tagname&gt;</code> 查看详细的标签信息</p><p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：<br><code>git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</code></p><p><code>git tag -d v0.1</code> 删除标签</p><p><code>git push origin &lt;tagname</code> 推送某个标签到远程仓库</p><p><code>git push origin --tags</code> 一次性推送</p><p>从远程删除标签</p><ol><li>先本地删除 <code> git tag -d v0.9</code></li><li>再远程删除 命令也是push <code>git push origin :refs/tags/v0.9</code></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;git 的笔记&lt;/p&gt;</summary>
    
    
    
    <category term="daily" scheme="http://example.com/categories/daily/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>react2</title>
    <link href="http://example.com/2021/06/24/react2/"/>
    <id>http://example.com/2021/06/24/react2/</id>
    <published>2021-06-24T10:54:20.000Z</published>
    <updated>2021-07-04T12:38:50.484Z</updated>
    
    <content type="html"><![CDATA[<p>看 三天精通react/ React学习手册 / the-road-to-learn-react / 读后感</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两个问题</span><br><span class="line">setstate的同步异步问题</span><br><span class="line">setstate的调用生命周期问题</span><br></pre></td></tr></table></figure><p>《三天精通react》</p><h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><p>先明白什么是组件<br>这里书上和木犀101都给出了一个类似的概念<br><strong>UI=f(x)</strong><br>即每一个组件就是一个纯函数，不过这个纯函数的返回值是UI结构，函数里面的x就是用于驱动UI更新的数据，这种通过数据驱动 UI 变化的方式，叫<strong>声明式编程</strong>，而直接对UI操作的叫命令行编程，比如原生DOM，声明式在思维上是更高级的编程范式。</p><p>无状态组件就是没state，所有的数据通过props接收，这里有个写法就是css当作变量而不是写在css文件里面</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  props: React.PropsWithChildren&lt;&#123; color?: string; onClick?: () =&gt; <span class="keyword">void</span> &#125;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; color, children, onClick &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> style = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>: color,</span><br><span class="line">    <span class="attr">border</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="attr">padding</span>: <span class="string">&quot;4px 6px&quot;</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;white&quot;</span>,</span><br><span class="line">    <span class="attr">cursor</span>: <span class="string">&quot;pointer&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;children&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有状态组件 就是带着state的组件，Hooks里面就用usestate(),具体用法也都知道，但切记不要写在生命周期函数里面，比如ComponentDidUpdate(),这样会导致无限重绘，页面假死。</p><p>即setstate()函数用于驱动页面更新，但UI更新总是有原因的</p><ul><li>⽤⼾触发的交互，如：键盘输⼊、⿏标点击、屏幕滑动等</li><li>定时器的触发，如： setTimeout 、 requestAnimationFrame 、 setInterval</li><li>IO 事件回调触发，如：AJAX 请求返回的回调</li></ul><p>总结就是， setCount 操作必须在某个回调中调⽤，不应该出现在生命周期函数的同步调⽤栈中执⾏。</p><p>useState()接收的参数是state的初始值，但在下列情况下需要接收函数作为参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始状态需要复杂计算</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> initialCount = props.data.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [count, setCount] = useState(<span class="function">() =&gt;</span> props.data.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始状态是复杂对象</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> [initialState, setState] = useState(&#123;</span><br><span class="line"><span class="attr">attr1</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line"><span class="attr">attr2</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="attr">attr50</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [initialState, setState] = useState(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line"><span class="attr">attr1</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line"><span class="attr">attr2</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="attr">attr50</span>: <span class="string">&#x27;xxxx&#x27;</span>,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>传函数的好处是，当依赖 state ⾃⾝最新状态来更新状态时，不需要访问外部变量</p><h1 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h1><p>当需要存放⼀个数据，需要⽆论在哪⾥都取到最新状态时，需要使⽤ useRef。（实际开发少用，影响效率）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;看 三天精通react/ React学习手册 / the-road-to-learn-react / 读后感&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Unit11-背景、阴影、和混合模式</title>
    <link href="http://example.com/2021/06/12/CssU11/"/>
    <id>http://example.com/2021/06/12/CssU11/</id>
    <published>2021-06-12T12:52:20.000Z</published>
    <updated>2021-06-12T12:53:25.912Z</updated>
    
    <content type="html"><![CDATA[<p>Css in depth 第四部分高级话题 第十一章笔记</p><span id="more"></span><h1 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h1><p>首先对background 这个属性有了解</p><pre><code>    background-image  //指定一个文件或者生成颜色渐变作为背景图片    background-position  //设置背景图片的初始位置    background-size  //指定背景图片的渲染尺寸    background-repeat  //决定在需要填充整个元素的时候是否平铺图片    background-origin  //决定背景图片的相对区域(content-box，border-box，默认是padding-box)    background-clip  //决定背景图片的绘制区域，值和上述一样    background-attachment  //决定背景图片是否随着页面其余部分的滚动而滚动    background-color  //指定背景颜色(渲染到背景图片下方)</code></pre><h2 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h2><p>然后我们就知道了渐变其实就是一种背景图片，用background-image 来定义，那如何定义一个渐变？ 这里就要引入 liner-gradient()这个函数了，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fade</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: liner-gradient (to right,white,blue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下<br><img src="/2021/06/12/CssU11/1.png" alt="01"></p><p>该函数有三个参数，第一个是角度，后面两个是起始颜色和终止颜色。<br>对于角度的设置可以为xdeg,比如0deg表示向上渐变，90deg表示向右渐变(顺时针旋转)，还有rad,turn,grad等单位，这里就不详细说了。<br>如果我们采用<br><code>background-image: liner-gradient (to right,red 0%,white 50%,blue 100%);</code><br>就可以实现多颜色渐变并确定它们渐变完成的位置。</p><p>如果在同一位置放多种颜色的话 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fade</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>,</span><br><span class="line"> red <span class="number">40%</span>, white <span class="number">40%</span>,</span><br><span class="line"> white <span class="number">60%</span>, blue <span class="number">60%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会出现下图的条纹效果<br><img src="/2021/06/12/CssU11/2.png"></p><p>线性渐变还有一种效果就是重复渐变，除了使用的函数repeating-linear-gradient()与线性渐变不同外，其接受参数参数和重复部分的效果都和线性渐变相同</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fade</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">repeating-linear-gradient</span>(-<span class="number">45deg</span>,</span><br><span class="line"> <span class="number">#57b</span>, <span class="number">#57b</span> <span class="number">10px</span>, <span class="number">#148</span> <span class="number">10px</span>, <span class="number">#148</span> <span class="number">20px</span>);</span><br><span class="line"> <span class="attribute">border-radius</span>: <span class="number">0.3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/12/CssU11/Snipaste_2021-06-03_18-49-51.png"></p><h2 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h2><p>和线性渐变的从一端沿直线到另一端不同，径向渐变是从一个点开始全方位向外扩展，如图<br><img src="/2021/06/12/CssU11/Snipaste_2021-06-03_18-56-45.png"></p><p>该渐变的函数是radial-gradient() ,通过类似于线性渐变函数的参数改变可以产生多种渐变效果，这里因为用的不多就不多说了。</p><h1 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h1><p>分为两种，box-shadow / text-shadow。<br>box-shadow的属性值为<br><code>box-shadow: 1em(水平位移) 1em(垂直位移) 2px(模糊半径) 1px(扩展半径) black</code><br>其中模糊半径设置阴影边缘模糊区域(更柔和)，扩展半径使阴影变大或变小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line"> <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">0.8rem</span>;</span><br><span class="line"> <span class="attribute">color</span>: white;</span><br><span class="line"> <span class="attribute">border-radius</span>: <span class="number">0.5em</span>;</span><br><span class="line"> <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to bottom, <span class="number">#57b</span>, <span class="number">#148</span>);</span><br><span class="line"> <span class="attribute">box-shadow</span>: <span class="number">0.1em</span> <span class="number">0.1em</span> <span class="number">0.5em</span> <span class="number">#124</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line"> <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">0</span> <span class="number">0.5em</span> <span class="number">#124</span>,</span><br><span class="line"> inset <span class="number">0</span> <span class="number">0.5em</span> <span class="number">1em</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码实现了如图效果<img src="/2021/06/12/CssU11/Snipaste_2021-06-03_19-09-31.png"><br>渐变阴影让元素更立体以及inset 让阴影在内部实现</p><h1 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h1><p><em><strong>background-blend-mode</strong></em> 具体不介绍，知道有这么个东西就行，要用到就现查现用</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Css in depth 第四部分高级话题 第十一章笔记&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Unit7-定位和层叠上下文</title>
    <link href="http://example.com/2021/06/12/CssU7/"/>
    <id>http://example.com/2021/06/12/CssU7/</id>
    <published>2021-06-12T12:50:20.000Z</published>
    <updated>2021-06-12T12:50:53.987Z</updated>
    
    <content type="html"><![CDATA[<p>Css in depth 第七章笔记</p><span id="more"></span><p>前面介绍的几种布局方式都是按照display属性来的，这次介绍的定位是由 position 决定，position属性的初始值是static，一旦这个值被改变来我们就说这个元素被定位了，接下来就了解一下定位的具体方式吧</p><h1 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h1><p>因为固定定位用的较少，就先从它开始了。<br>固定定位的属性值就是 position:fixed;<br>还需要搭配 top/bottom/left/right 四个属性，这些属性决定了定位元素和浏览器视口的距离，这四个值还隐式的定义了元素的宽高，比如指定left:2em;right:2em;则元素的宽度就是浏览器视口减去4em。<br>被固定定位后的元素会固定在浏览器视口的某个位置，并脱离原本的位置。(广告啊弹窗啥的)</p><h1 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h1><p>首先绝对定位不像固定定位的元素那样相对于浏览器视口实现边偏移(top/bottom/right/left)，它是相对于自身的被定位的祖先元素(有爹找爹没爹找爷)来说的，如果没有祖先元素才会找到浏览器，添加了绝对定位的元素也会释放原来的位置。绝对定位经常和Js配合实现下拉菜单，消息盒子，工具提示等功能，在这之前，我们先看看它必须得有的搭档，相对定位</p><h1 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h1><p>被相对定位的元素是相对于自身原本占有的位置进行移动的，会保留原本拥有的位置。但添加了相对定位的元素我们不会移动它，我们会把它当作绝对定位元素的祖先容器，这就是所谓的<strong>子绝父相</strong><br>因为添加绝对定位的子元素可以放在父容器的任何地方，同时释放自身原有位置也不会影响其他兄弟元素的位置，而容器盒子需要添加一个定位限制住子盒子定位在自身内部，最后容器盒子布局需要在标准流中占一个位置，因此就有了子绝父相这句话的由来。</p><h1 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h1><p>定位多了都脱离原来位置了，就容易发生层叠，用z-index属性就好，可以理解为一个z轴嘛，值越大z坐标越高元素位置越高，就不会被其他元素覆盖层叠了。</p><h1 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h1><p>粘性定位是固定定位和相对定位的结合，把被粘性定位定位后的某元素固定在浏览器某个位置，一开始会随着浏览器视口的滚动而滚动，到达特定位置后就不会再变了，占有原先位置。</p><p>定位到这也就结束啦x</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Css in depth 第七章笔记&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
</feed>
